// noop logger shouldn't be used in browser
function formatLog(log) {
    return JSON.stringify(log);
}

const LogLevels = {
    debug: 10,
    verbose: 20,
    info: 30,
    warning: 40,
    error: 50,
};
const defaultOptions$1 = {
    level: "info",
};
function createLogger(options) {
    const config = { ...defaultOptions$1, ...options };
    function log(log) {
        if (LogLevels[config.level] <= LogLevels[log.level]) {
            config.sink.log(processLog(log));
        }
    }
    return {
        log,
        debug: (message) => log({ level: "debug", message }),
        verbose: (message) => log({ level: "verbose", message }),
        info: (message) => log({ level: "info", message }),
        warn: (message) => log({ level: "warning", message }),
        error: (message) => log({ level: "error", message }),
    };
}
function processLog(log) {
    return {
        level: log.level,
        code: log.code,
        message: log.message,
        sourceLocation: getSourceLocation(log.target),
    };
}

/**
 * AST types
 */
var SyntaxKind;
(function (SyntaxKind) {
    SyntaxKind[SyntaxKind["CadlScript"] = 0] = "CadlScript";
    SyntaxKind[SyntaxKind["JsSourceFile"] = 1] = "JsSourceFile";
    SyntaxKind[SyntaxKind["ImportStatement"] = 2] = "ImportStatement";
    SyntaxKind[SyntaxKind["Identifier"] = 3] = "Identifier";
    SyntaxKind[SyntaxKind["DecoratorExpression"] = 4] = "DecoratorExpression";
    SyntaxKind[SyntaxKind["DirectiveExpression"] = 5] = "DirectiveExpression";
    SyntaxKind[SyntaxKind["MemberExpression"] = 6] = "MemberExpression";
    SyntaxKind[SyntaxKind["NamespaceStatement"] = 7] = "NamespaceStatement";
    SyntaxKind[SyntaxKind["UsingStatement"] = 8] = "UsingStatement";
    SyntaxKind[SyntaxKind["OperationStatement"] = 9] = "OperationStatement";
    SyntaxKind[SyntaxKind["OperationSignatureDeclaration"] = 10] = "OperationSignatureDeclaration";
    SyntaxKind[SyntaxKind["OperationSignatureReference"] = 11] = "OperationSignatureReference";
    SyntaxKind[SyntaxKind["ModelStatement"] = 12] = "ModelStatement";
    SyntaxKind[SyntaxKind["ModelExpression"] = 13] = "ModelExpression";
    SyntaxKind[SyntaxKind["ModelProperty"] = 14] = "ModelProperty";
    SyntaxKind[SyntaxKind["ModelSpreadProperty"] = 15] = "ModelSpreadProperty";
    SyntaxKind[SyntaxKind["InterfaceStatement"] = 16] = "InterfaceStatement";
    SyntaxKind[SyntaxKind["UnionStatement"] = 17] = "UnionStatement";
    SyntaxKind[SyntaxKind["UnionVariant"] = 18] = "UnionVariant";
    SyntaxKind[SyntaxKind["EnumStatement"] = 19] = "EnumStatement";
    SyntaxKind[SyntaxKind["EnumMember"] = 20] = "EnumMember";
    SyntaxKind[SyntaxKind["EnumSpreadMember"] = 21] = "EnumSpreadMember";
    SyntaxKind[SyntaxKind["AliasStatement"] = 22] = "AliasStatement";
    SyntaxKind[SyntaxKind["UnionExpression"] = 23] = "UnionExpression";
    SyntaxKind[SyntaxKind["IntersectionExpression"] = 24] = "IntersectionExpression";
    SyntaxKind[SyntaxKind["TupleExpression"] = 25] = "TupleExpression";
    SyntaxKind[SyntaxKind["ArrayExpression"] = 26] = "ArrayExpression";
    SyntaxKind[SyntaxKind["StringLiteral"] = 27] = "StringLiteral";
    SyntaxKind[SyntaxKind["NumericLiteral"] = 28] = "NumericLiteral";
    SyntaxKind[SyntaxKind["BooleanLiteral"] = 29] = "BooleanLiteral";
    SyntaxKind[SyntaxKind["VoidKeyword"] = 30] = "VoidKeyword";
    SyntaxKind[SyntaxKind["NeverKeyword"] = 31] = "NeverKeyword";
    SyntaxKind[SyntaxKind["UnknownKeyword"] = 32] = "UnknownKeyword";
    SyntaxKind[SyntaxKind["TypeReference"] = 33] = "TypeReference";
    SyntaxKind[SyntaxKind["ProjectionReference"] = 34] = "ProjectionReference";
    SyntaxKind[SyntaxKind["TemplateParameterDeclaration"] = 35] = "TemplateParameterDeclaration";
    SyntaxKind[SyntaxKind["EmptyStatement"] = 36] = "EmptyStatement";
    SyntaxKind[SyntaxKind["InvalidStatement"] = 37] = "InvalidStatement";
    SyntaxKind[SyntaxKind["LineComment"] = 38] = "LineComment";
    SyntaxKind[SyntaxKind["BlockComment"] = 39] = "BlockComment";
    SyntaxKind[SyntaxKind["Projection"] = 40] = "Projection";
    SyntaxKind[SyntaxKind["ProjectionParameterDeclaration"] = 41] = "ProjectionParameterDeclaration";
    SyntaxKind[SyntaxKind["ProjectionModelSelector"] = 42] = "ProjectionModelSelector";
    SyntaxKind[SyntaxKind["ProjectionOperationSelector"] = 43] = "ProjectionOperationSelector";
    SyntaxKind[SyntaxKind["ProjectionUnionSelector"] = 44] = "ProjectionUnionSelector";
    SyntaxKind[SyntaxKind["ProjectionInterfaceSelector"] = 45] = "ProjectionInterfaceSelector";
    SyntaxKind[SyntaxKind["ProjectionEnumSelector"] = 46] = "ProjectionEnumSelector";
    SyntaxKind[SyntaxKind["ProjectionExpressionStatement"] = 47] = "ProjectionExpressionStatement";
    SyntaxKind[SyntaxKind["ProjectionIfExpression"] = 48] = "ProjectionIfExpression";
    SyntaxKind[SyntaxKind["ProjectionBlockExpression"] = 49] = "ProjectionBlockExpression";
    SyntaxKind[SyntaxKind["ProjectionMemberExpression"] = 50] = "ProjectionMemberExpression";
    SyntaxKind[SyntaxKind["ProjectionLogicalExpression"] = 51] = "ProjectionLogicalExpression";
    SyntaxKind[SyntaxKind["ProjectionEqualityExpression"] = 52] = "ProjectionEqualityExpression";
    SyntaxKind[SyntaxKind["ProjectionUnaryExpression"] = 53] = "ProjectionUnaryExpression";
    SyntaxKind[SyntaxKind["ProjectionRelationalExpression"] = 54] = "ProjectionRelationalExpression";
    SyntaxKind[SyntaxKind["ProjectionArithmeticExpression"] = 55] = "ProjectionArithmeticExpression";
    SyntaxKind[SyntaxKind["ProjectionCallExpression"] = 56] = "ProjectionCallExpression";
    SyntaxKind[SyntaxKind["ProjectionLambdaExpression"] = 57] = "ProjectionLambdaExpression";
    SyntaxKind[SyntaxKind["ProjectionLambdaParameterDeclaration"] = 58] = "ProjectionLambdaParameterDeclaration";
    SyntaxKind[SyntaxKind["ProjectionModelExpression"] = 59] = "ProjectionModelExpression";
    SyntaxKind[SyntaxKind["ProjectionModelProperty"] = 60] = "ProjectionModelProperty";
    SyntaxKind[SyntaxKind["ProjectionModelSpreadProperty"] = 61] = "ProjectionModelSpreadProperty";
    SyntaxKind[SyntaxKind["ProjectionSpreadProperty"] = 62] = "ProjectionSpreadProperty";
    SyntaxKind[SyntaxKind["ProjectionTupleExpression"] = 63] = "ProjectionTupleExpression";
    SyntaxKind[SyntaxKind["ProjectionStatement"] = 64] = "ProjectionStatement";
    SyntaxKind[SyntaxKind["ProjectionDecoratorReferenceExpression"] = 65] = "ProjectionDecoratorReferenceExpression";
    SyntaxKind[SyntaxKind["Return"] = 66] = "Return";
})(SyntaxKind || (SyntaxKind = {}));
var IdentifierKind;
(function (IdentifierKind) {
    IdentifierKind[IdentifierKind["TypeReference"] = 0] = "TypeReference";
    IdentifierKind[IdentifierKind["Decorator"] = 1] = "Decorator";
    IdentifierKind[IdentifierKind["Using"] = 2] = "Using";
    IdentifierKind[IdentifierKind["Declaration"] = 3] = "Declaration";
    IdentifierKind[IdentifierKind["Other"] = 4] = "Other";
})(IdentifierKind || (IdentifierKind = {}));
const NoTarget = Symbol("NoTarget");

/**
 * Create a new diagnostics creator.
 * @param diagnostics Map of the potential diagnostics.
 * @param libraryName Optional name of the library if in the scope of a library.
 * @returns @see DiagnosticCreator
 */
function createDiagnosticCreator(diagnostics, libraryName) {
    const errorMessage = libraryName
        ? `It must match one of the code defined in the library '${libraryName}'`
        : "It must match one of the code defined in the compiler.";
    function createDiagnostic(diagnostic) {
        var _a;
        const diagnosticDef = diagnostics[diagnostic.code];
        if (!diagnosticDef) {
            const codeStr = Object.keys(diagnostics)
                .map((x) => ` - ${x}`)
                .join("\n");
            const code = String(diagnostic.code);
            throw new Error(`Unexpected diagnostic code '${code}'. ${errorMessage}. Defined codes:\n${codeStr}`);
        }
        const message = diagnosticDef.messages[(_a = diagnostic.messageId) !== null && _a !== void 0 ? _a : "default"];
        if (!message) {
            const codeStr = Object.keys(diagnosticDef.messages)
                .map((x) => ` - ${x}`)
                .join("\n");
            const messageId = String(diagnostic.messageId);
            const code = String(diagnostic.code);
            throw new Error(`Unexpected message id '${messageId}'. ${errorMessage} for code '${code}'. Defined codes:\n${codeStr}`);
        }
        const messageStr = typeof message === "string" ? message : message(diagnostic.format);
        return {
            code: libraryName ? `${libraryName}/${String(diagnostic.code)}` : diagnostic.code.toString(),
            severity: diagnosticDef.severity,
            message: messageStr,
            target: diagnostic.target,
        };
    }
    function reportDiagnostic(program, diagnostic) {
        const diag = createDiagnostic(diagnostic);
        program.reportDiagnostic(diag);
    }
    return {
        diagnostics,
        createDiagnostic,
        reportDiagnostic,
    };
}
/**
 * Represents a failure while interpreting a projection.
 */
class ProjectionError extends Error {
    constructor(message) {
        super(message);
        this.name = "ProjectionError";
    }
}
function logDiagnostics(diagnostics, logger) {
    for (const diagnostic of diagnostics) {
        logger.log({
            level: diagnostic.severity,
            message: diagnostic.message,
            code: diagnostic.code,
            sourceLocation: getSourceLocation(diagnostic.target),
        });
    }
}
function formatDiagnostic(diagnostic) {
    return formatLog({
        code: diagnostic.code,
        level: diagnostic.severity,
        message: diagnostic.message,
        sourceLocation: getSourceLocation(diagnostic.target),
    });
}
function createSourceFile(text, path) {
    let lineStarts = undefined;
    return {
        text,
        path,
        getLineStarts,
        getLineAndCharacterOfPosition,
    };
    function getLineStarts() {
        return (lineStarts = lineStarts !== null && lineStarts !== void 0 ? lineStarts : scanLineStarts(text));
    }
    function getLineAndCharacterOfPosition(position) {
        const starts = getLineStarts();
        let line = binarySearch(starts, position);
        // When binarySearch returns < 0 indicating that the value was not found, it
        // returns the bitwise complement of the index where the value would need to
        // be inserted to keep the array sorted. So flipping the bits back to this
        // positive index tells us what the line number would be if we were to
        // create a new line starting at the given position, and subtracting 1 from
        // that therefore gives us the line number we're after.
        if (line < 0) {
            line = ~line - 1;
        }
        return {
            line,
            character: position - starts[line],
        };
    }
}
function getSourceLocation(target) {
    if (target === NoTarget || target === undefined) {
        return undefined;
    }
    if ("file" in target) {
        return target;
    }
    if (!("kind" in target)) {
        // symbol
        if (target.flags & 262144 /* SymbolFlags.Using */) {
            target = target.symbolSource;
        }
        if (!target.declarations[0]) {
            return createSyntheticSourceLocation();
        }
        return getSourceLocationOfNode(target.declarations[0]);
    }
    else if (typeof target.kind === "number") {
        // node
        return getSourceLocationOfNode(target);
    }
    else {
        // type
        const targetNode = target.node;
        if (targetNode) {
            return getSourceLocationOfNode(targetNode);
        }
        return createSyntheticSourceLocation();
    }
}
function createSyntheticSourceLocation(loc = "<unknown location>") {
    return {
        file: createSourceFile("", loc),
        pos: 0,
        end: 0,
        isSynthetic: true,
    };
}
function getSourceLocationOfNode(node) {
    let root = node;
    while (root.parent !== undefined) {
        root = root.parent;
    }
    if (root.kind !== SyntaxKind.CadlScript && root.kind !== SyntaxKind.JsSourceFile) {
        return createSyntheticSourceLocation(node.flags & 8 /* NodeFlags.Synthetic */
            ? undefined
            : "<unknown location - cannot obtain source location of unbound node - file bug at https://github.com/microsoft/cadl>");
    }
    return {
        file: root.file,
        pos: node.pos,
        end: node.end,
    };
}
/**
 * Verbose output is enabled by default for runs in mocha explorer in VS Code,
 * where the output is nicely associated with the individual test, and disabled
 * by default for command line runs where we don't want to spam the console.
 *
 * If the steps taken to produce the message are expensive, pass a callback
 * instead of producing the message then passing it here only to be dropped
 * when verbose output is disabled.
 */
function logVerboseTestOutput(messageOrCallback) {
    if (process.env.CADL_VERBOSE_TEST_OUTPUT) {
        if (typeof messageOrCallback === "string") {
            // eslint-disable-next-line no-console
            console.log(messageOrCallback);
        }
        else {
            // eslint-disable-next-line no-console
            messageOrCallback(console.log);
        }
    }
}
/**
 * Use this to report bugs in the compiler, and not errors in the source code
 * being compiled.
 *
 * @param condition Throw if this is not true.
 *
 * @param message Error message.
 *
 * @param target Optional location in source code that might give a clue about
 *               what got the compiler off track.
 */
function compilerAssert(condition, message, target) {
    if (condition) {
        return;
    }
    if (target) {
        let location;
        try {
            location = getSourceLocation(target);
        }
        catch (err) { }
        if (location) {
            const pos = location.file.getLineAndCharacterOfPosition(location.pos);
            const file = location.file.path;
            const line = pos.line + 1;
            const col = pos.character + 1;
            message += `\nOccurred while compiling code in ${file} near line ${line}, column ${col}`;
        }
    }
    throw new Error(message);
}
function scanLineStarts(text) {
    const starts = [];
    let start = 0;
    let pos = 0;
    while (pos < text.length) {
        const ch = text.charCodeAt(pos);
        pos++;
        switch (ch) {
            case 13 /* CharCode.CarriageReturn */:
                if (text.charCodeAt(pos) === 10 /* CharCode.LineFeed */) {
                    pos++;
                }
            // fallthrough
            case 10 /* CharCode.LineFeed */:
                starts.push(start);
                start = pos;
                break;
        }
    }
    starts.push(start);
    return starts;
}
/**
 * Search sorted array of numbers for the given value. If found, return index
 * in array where value was found. If not found, return a negative number that
 * is the bitwise complement of the index where value would need to be inserted
 * to keep the array sorted.
 */
function binarySearch(array, value) {
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const v = array[middle];
        if (v < value) {
            low = middle + 1;
        }
        else if (v > value) {
            high = middle - 1;
        }
        else {
            return middle;
        }
    }
    return ~low;
}
/**
 * Assert that the input type has one of the kinds provided
 */
function assertType(typeDescription, t, ...kinds) {
    if (kinds.indexOf(t.kind) === -1) {
        throw new ProjectionError(`Expected ${typeDescription} to be type ${kinds.join(", ")}`);
    }
}
/**
 * Report a deprecated diagnostic.
 * @param program Cadl Program.
 * @param message Message describing the deprecation.
 * @param target Target of the deprecation.
 */
function reportDeprecated(program, message, target) {
    reportDiagnostic(program, {
        code: "deprecated",
        format: {
            message,
        },
        target,
    });
}
/**
 * Create a new instance of the @see DiagnosticCollector.
 */
function createDiagnosticCollector() {
    const diagnostics = [];
    return {
        diagnostics,
        add,
        pipe,
        wrap,
    };
    function add(diagnostic) {
        diagnostics.push(diagnostic);
    }
    function pipe(result) {
        const [value, diags] = result;
        for (const diag of diags) {
            diagnostics.push(diag);
        }
        return value;
    }
    function wrap(value) {
        return [value, diagnostics];
    }
}
/**
 * Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.
 * @param result: Accessor pattern tuple result including the actual result and the list of diagnostics.
 * @returns Actual result.
 */
function ignoreDiagnostics(result) {
    return result[0];
}

/**
 * Create a new Cadl library definition.
 * @param lib Library definition.
 * @returns Library with utility functions.
 *
 *
 * @tutorial Create the lib object with `as const` to get the full typing.
 *
 * @example
 * const libDef = {
 *   name: "myLib",
 *   diagnostics: {
 *    "my-code": {serverity: "error", messages: {default: "Foo bar"}}
 *   },
 * } as const;
 *
 * const lib = createCadlLibrary(libDef);
 */
function createCadlLibrary(lib) {
    const { reportDiagnostic, createDiagnostic } = createDiagnosticCreator(lib.diagnostics, lib.name);
    return { ...lib, reportDiagnostic, createDiagnostic };
}
function paramMessage(strings, ...keys) {
    const template = (dict) => {
        const result = [strings[0]];
        keys.forEach((key, i) => {
            const value = dict[key];
            if (value !== undefined) {
                result.push(value);
            }
            result.push(strings[i + 1]);
        });
        return result.join("");
    };
    template.keys = keys;
    return template;
}
/**
 * Set the Cadl namespace for that function.
 * @param namespace Namespace string (e.g. "Foo.Bar")
 * @param functions Functions
 */
function setCadlNamespace(namespace, ...functions) {
    functions.forEach((c) => (c.namespace = namespace));
}

// Static assert: this won't compile if one of the entries above is invalid.
const diagnostics = {
    /**
     * Scanner errors.
     */
    "digit-expected": {
        severity: "error",
        messages: {
            default: "Digit expected.",
        },
    },
    "hex-digit-expected": {
        severity: "error",
        messages: {
            default: "Hexadecimal digit expected.",
        },
    },
    "binary-digit-expected": {
        severity: "error",
        messages: {
            default: "Binary digit expected.",
        },
    },
    unterminated: {
        severity: "error",
        messages: {
            default: paramMessage `Unterminated ${"token"}.`,
        },
    },
    "creating-file": {
        severity: "error",
        messages: {
            default: paramMessage `Error creating single file: ${"filename"},  ${"error"}`,
        },
    },
    "invalid-escape-sequence": {
        severity: "error",
        messages: {
            default: "Invalid escape sequence.",
        },
    },
    "no-new-line-start-triple-quote": {
        severity: "error",
        messages: {
            default: "String content in triple quotes must begin on a new line.",
        },
    },
    "no-new-line-end-triple-quote": {
        severity: "error",
        messages: {
            default: "Closing triple quotes must begin on a new line.",
        },
    },
    "triple-quote-indent": {
        severity: "error",
        messages: {
            default: "All lines in triple-quoted string lines must have the same indentation as closing triple quotes.",
        },
    },
    "invalid-character": {
        severity: "error",
        messages: {
            default: "Invalid character.",
        },
    },
    /**
     * Utils
     */
    "file-not-found": {
        severity: "error",
        messages: {
            default: paramMessage `File ${"path"} not found.`,
        },
    },
    "file-load": {
        severity: "error",
        messages: {
            default: paramMessage `${"message"}`,
        },
    },
    /**
     * Parser errors.
     */
    "multiple-blockless-namespace": {
        severity: "error",
        messages: {
            default: "Cannot use multiple blockless namespaces.",
        },
    },
    "blockless-namespace-first": {
        severity: "error",
        messages: {
            default: "Blockless namespaces can't follow other declarations.",
            topLevel: "Blockless namespace can only be top-level.",
        },
    },
    "import-first": {
        severity: "error",
        messages: {
            default: "Imports must come prior to namespaces or other declarations.",
            topLevel: "Imports must be top-level and come prior to namespaces or other declarations.",
        },
    },
    "default-optional": {
        severity: "error",
        messages: {
            default: "Cannot use default with non optional properties",
        },
    },
    "token-expected": {
        severity: "error",
        messages: {
            default: paramMessage `${"token"} expected.`,
            unexpected: paramMessage `Unexpected token ${"token"}`,
            numericOrStringLiteral: "Expected numeric or string literal.",
            identifier: "Identifier expected.",
            projectionDirection: "from or to expected.",
            expression: "Expression expected.",
            statement: "Statement expected.",
            property: "Property expected.",
            enumMember: "Enum member expected.",
        },
    },
    "trailing-token": {
        severity: "error",
        messages: {
            default: paramMessage `Trailing ${"token"}`,
        },
    },
    "unknown-directive": {
        severity: "error",
        messages: {
            default: paramMessage `Unknown directive '#${"id"}'`,
        },
    },
    "reserved-identifier": {
        severity: "error",
        messages: {
            default: "Keyword cannot be used as identifier.",
        },
    },
    "invalid-directive-location": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot place directive on ${"nodeName"}.`,
        },
    },
    "invalid-decorator-location": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot decorate ${"nodeName"}.`,
        },
    },
    "invalid-projection": {
        severity: "error",
        messages: {
            default: "Invalid projection",
            wrongType: "Non-projection can't be used to project",
            noTo: "Projection missing to projection",
            projectionError: paramMessage `An error occurred when projecting this type: ${"message"}`,
        },
    },
    "default-required": {
        severity: "error",
        messages: {
            default: "Required template parameters must not follow optional template parameters",
        },
    },
    "invalid-template-default": {
        severity: "error",
        messages: {
            default: "Template parameter defaults can only reference previously declared type parameters.",
        },
    },
    /**
     * Checker
     */
    "using-invalid-ref": {
        severity: "error",
        messages: {
            default: "Using must refer to a namespace",
            decorator: "Can't use a decorator",
            function: "Can't use a function",
            projection: "Can't use a projection",
        },
    },
    "invalid-type-ref": {
        severity: "error",
        messages: {
            default: "Invalid type reference",
            decorator: "Can't put a decorator in a type",
            function: "Can't use a function as a type",
        },
    },
    "invalid-template-args": {
        severity: "error",
        messages: {
            default: "Invalid template arguments.",
            notTemplate: "Can't pass template arguments to non-templated type",
            tooFew: "Too few template arguments provided.",
            tooMany: "Too many template arguments provided.",
        },
    },
    "intersect-non-model": {
        severity: "error",
        messages: {
            default: "Cannot intersect non-model types (including union types).",
        },
    },
    "intersect-invalid-index": {
        severity: "error",
        messages: {
            default: "Cannot intersect incompatible models.",
            never: "Cannot intersect a model that cannot hold properties.",
            array: "Cannot intersect an array model.",
        },
    },
    "intersect-duplicate-property": {
        severity: "error",
        messages: {
            default: paramMessage `Intersection contains duplicate property definitions for ${"propName"}`,
        },
    },
    "unknown-identifier": {
        severity: "error",
        messages: {
            default: paramMessage `Unknown identifier ${"id"}`,
        },
    },
    "unknown-decorator": {
        severity: "error",
        messages: {
            default: "Unknown decorator",
        },
    },
    "invalid-decorator": {
        severity: "error",
        messages: {
            default: paramMessage `${"id"} is not a decorator`,
        },
    },
    "invalid-ref": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot resolve ${"id"}`,
            inDecorator: paramMessage `Cannot resolve ${"id"} in decorator`,
            underNamespace: paramMessage `Namespace ${"namespace"} doesn't have member ${"id"}`,
            underContainer: paramMessage `${"kind"} doesn't have member ${"id"}`,
            node: paramMessage `Cannot resolve '${"id"}' in non-namespace node ${"nodeName"}`,
        },
    },
    "duplicate-property": {
        severity: "error",
        messages: {
            default: paramMessage `Model already has a property named ${"propName"}`,
        },
    },
    "override-property": {
        severity: "error",
        messages: {
            default: paramMessage `Model has an inherited property named ${"propName"} which cannot be overridden`,
        },
    },
    "extend-model": {
        severity: "error",
        messages: {
            default: "Models must extend other models.",
        },
    },
    "extend-primitive": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot extend primitive types. Use 'model ${"modelName"} is ${"baseModelName"}' instead.`,
        },
    },
    "is-model": {
        severity: "error",
        messages: {
            default: "Model `is` must specify another model.",
        },
    },
    "is-operation": {
        severity: "error",
        messages: {
            default: "Operation can only reuse the signature of another operation.",
        },
    },
    "spread-model": {
        severity: "error",
        messages: {
            default: "Cannot spread properties of non-model type.",
            neverIndex: "Cannot spread type because it cannot hold properties.",
        },
    },
    "unsupported-default": {
        severity: "error",
        messages: {
            default: paramMessage `Default must be have a value type but has type '${"type"}'.`,
        },
    },
    unassignable: {
        severity: "error",
        messages: {
            default: paramMessage `Type '${"value"}' is not assignable to type '${"targetType"}'`,
            withDetails: paramMessage `Type '${"sourceType"}' is not assignable to type '${"targetType"}'\n  ${"details"}`,
        },
    },
    "no-prop": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propName"}' cannot be defined because model cannot hold properties.`,
        },
    },
    "missing-index": {
        severity: "error",
        messages: {
            default: paramMessage `Index signature for type '${"indexType"}' is missing in type '${"sourceType"}'.`,
        },
    },
    "missing-property": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propertyName"}' is missing on type '${"sourceType"}' but required in '${"targetType"}'`,
        },
    },
    "extends-interface": {
        severity: "error",
        messages: {
            default: "Interfaces can only extend other interfaces",
        },
    },
    "extends-interface-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Interface extends cannot have duplicate members. The duplicate member is named ${"name"}`,
        },
    },
    "interface-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Interface already has a member named ${"name"}`,
        },
    },
    "union-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Union already has a variant named ${"name"}`,
        },
    },
    "enum-member-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Enum already has a member named ${"name"}`,
        },
    },
    "spread-enum": {
        severity: "error",
        messages: {
            default: "Cannot spread members of non-enum type.",
        },
    },
    "decorator-fail": {
        severity: "error",
        messages: {
            default: paramMessage `Decorator ${"decoratorName"} failed!\n\n${"error"}`,
        },
    },
    /**
     * Program
     */
    "dynamic-import": {
        severity: "error",
        messages: {
            default: "Dynamically generated Cadl cannot have imports",
        },
    },
    "invalid-import": {
        severity: "error",
        messages: {
            default: "Import paths must reference either a directory, a .cadl file, or .js file",
        },
    },
    "invalid-main": {
        severity: "error",
        messages: {
            default: "Main file must either be a .cadl file or a .js file.",
        },
    },
    "import-not-found": {
        severity: "error",
        messages: {
            default: paramMessage `Couldn't resolve import "${"path"}"`,
        },
    },
    "library-invalid": {
        severity: "error",
        messages: {
            cadlMain: paramMessage `Library "${"path"}" has an invalid cadlMain file.`,
            default: paramMessage `Library "${"path"}" has an invalid main file.`,
        },
    },
    "compiler-version-mismatch": {
        severity: "error",
        messages: {
            default: paramMessage `Current Cadl compiler conflicts with local version of @cadl-lang/compiler referenced in ${"basedir"}. \nIf this error occurs on the command line, try running \`cadl\` with a working directory of ${"basedir"}. \nIf this error occurs in the IDE, try configuring the \`cadl-server\` path to ${"betterCadlServerPath"}.\n  Expected: ${"expected"}\n  Resolved: ${"actual"}`,
        },
    },
    "duplicate-symbol": {
        severity: "error",
        messages: {
            default: paramMessage `Duplicate name: "${"name"}"`,
        },
    },
    "projections-are-experimental": {
        severity: "warning",
        messages: {
            default: "Projections are experimental - your code will need to change as this feature evolves.",
        },
    },
    /**
     * Binder
     */
    "ambiguous-symbol": {
        severity: "error",
        messages: {
            default: paramMessage `"${"name"}" is an ambiguous name between ${"duplicateNames"}. Try using fully qualified name instead: ${"duplicateNames"}`,
        },
    },
    "duplicate-using": {
        severity: "error",
        messages: {
            default: paramMessage `duplicate using of "${"usingName"}" namespace`,
        },
    },
    /**
     * Library
     */
    "on-validate-fail": {
        severity: "error",
        messages: {
            default: paramMessage `onValidate failed with errors. ${"error"}`,
        },
    },
    "emitter-not-found": {
        severity: "error",
        messages: {
            default: paramMessage `Requested emitter package ${"emitterPackage"} does not provide an "onEmit" function.`,
        },
    },
    "missing-import": {
        severity: "error",
        messages: {
            default: paramMessage `Emitter '${"emitterName"}' requires '${"requiredImport"}' to be imported. Add 'import "${"requiredImport"}".`,
        },
    },
    /**
     * Decorator
     */
    "decorator-wrong-target": {
        severity: "error",
        messages: {
            default: paramMessage `Cannot apply ${"decorator"} decorator to ${"to"}`,
        },
    },
    "invalid-argument": {
        severity: "error",
        messages: {
            default: paramMessage `Argument '${"value"}' of type '${"actual"}' is not assignable to parameter of type '${"expected"}'`,
        },
    },
    "invalid-argument-count": {
        severity: "error",
        messages: {
            default: paramMessage `Expected ${"expected"} arguments, but got ${"actual"}.`,
            between: paramMessage `Expected between ${"min"} and ${"max"} arguments, but got ${"actual"}.`,
        },
    },
    "known-values-invalid-enum": {
        severity: "error",
        messages: {
            default: paramMessage `Enum cannot be used on this type. Member ${"member"} is not assignable to type ${"type"}.`,
        },
    },
    "invalid-value": {
        severity: "error",
        messages: {
            default: paramMessage `Type '${"kind"}' is not a value type.`,
            atPath: paramMessage `Type '${"kind"}' of '${"path"}' is not a value type.`,
        },
    },
    deprecated: {
        severity: "warning",
        messages: {
            default: paramMessage `Deprecated: ${"message"}`,
        },
    },
    "no-optional-key": {
        severity: "error",
        messages: {
            default: paramMessage `Property '${"propertyName"}' marked as key cannot be optional.`,
        },
    },
    /**
     * Service
     */
    "service-decorator-duplicate": {
        severity: "error",
        messages: {
            default: paramMessage `Service ${"name"} can only be set once per Cadl document.`,
        },
    },
    "service-namespace-duplicate": {
        severity: "error",
        messages: {
            default: "Cannot set service namespace more than once in a Cadl project.",
        },
    },
    "list-type-not-model": {
        severity: "error",
        messages: {
            default: "@list decorator's parameter must be a model type.",
        },
    },
    /**
     * Mutator
     */
    "add-response": {
        severity: "error",
        messages: {
            default: "Cannot add a response to anything except an operation statement.",
        },
    },
    "add-parameter": {
        severity: "error",
        messages: {
            default: "Cannot add a parameter to anything except an operation statement.",
        },
    },
    "add-model-property": {
        severity: "error",
        messages: {
            default: "Cannot add a model property to anything except a model statement.",
        },
    },
    "add-model-property-fail": {
        severity: "error",
        messages: {
            default: paramMessage `Could not add property/parameter "${"propertyName"}" of type "${"propertyTypeName"}"`,
        },
    },
    "add-response-type": {
        severity: "error",
        messages: {
            default: paramMessage `Could not add response type "${"responseTypeName"}" to operation ${"operationName"}"`,
        },
    },
    "circular-base-type": {
        severity: "error",
        messages: {
            default: paramMessage `Model type '${"typeName"}' recursively references itself as a base type.`,
        },
    },
    "circular-op-signature": {
        severity: "error",
        messages: {
            default: paramMessage `Operation '${"typeName"}' recursively references itself.`,
        },
    },
    "circular-alias-type": {
        severity: "error",
        messages: {
            default: paramMessage `Alias type '${"typeName"}' recursively references itself.`,
        },
    },
};
const { createDiagnostic, reportDiagnostic } = createDiagnosticCreator(diagnostics);

/**
 * Validate the decorator target is matching the expected value.
 * @param program
 * @param target
 * @param expectedType
 * @param decoratorName
 * @returns
 */
function validateDecoratorTarget(context, target, decoratorName, expectedType) {
    const isCorrectType = isCadlValueTypeOf(target, expectedType);
    if (!isCorrectType) {
        reportDiagnostic(context.program, {
            code: "decorator-wrong-target",
            format: {
                decorator: decoratorName,
                to: target.kind,
            },
            target: context.decoratorTarget,
        });
        return false;
    }
    return true;
}
function validateDecoratorTargetIntrinsic(context, target, decoratorName, expectedType) {
    const actualType = getIntrinsicModelName(context.program, getPropertyType(target));
    const isCorrect = actualType &&
        (typeof expectedType === "string"
            ? actualType === expectedType
            : expectedType.includes(actualType));
    if (!isCorrect) {
        context.program.reportDiagnostic(createDiagnostic({
            code: "decorator-wrong-target",
            format: {
                decorator: decoratorName,
                to: `type it is not one of: ${typeof expectedType === "string" ? expectedType : expectedType.join(", ")}`,
            },
            target: context.decoratorTarget,
        }));
        return false;
    }
    return true;
}
/**
 * Check if the given target is of any of the cadl types.
 * @param target Target to validate.
 * @param expectedType One or multiple allowed cadl types.
 * @returns boolean if the target is of one of the allowed types.
 */
function isCadlValueTypeOf(target, expectedType) {
    const kind = getTypeKind(target);
    if (kind === undefined) {
        return false;
    }
    return typeof expectedType === "string"
        ? expectedType === "Any" || kind === expectedType
        : expectedType.includes("Any") || expectedType.includes(kind);
}
function getTypeKind(target) {
    switch (typeof target) {
        case "object":
            return target.kind;
        case "string":
            return "String";
        case "number":
            return "Number";
        case "boolean":
            return "Boolean";
        default:
            return undefined;
    }
}
/**
 * Validate a decorator parameter has the correct type.
 * @param program Program
 * @param target Decorator target
 * @param value Value of the parameter.
 * @param expectedType Expected type or list of expected type
 * @returns true if the value is of one of the type in the list of expected types. If not emit a diagnostic.
 * @deprecated use @see createDecoratorDefinition#validate instead.
 */
function validateDecoratorParamType(program, target, value, expectedType) {
    if (!isCadlValueTypeOf(value, expectedType)) {
        reportDiagnostic(program, {
            code: "invalid-argument",
            format: {
                value: prettyValue(program, value),
                actual: getTypeKind(value),
                expected: typeof expectedType === "string" ? expectedType : expectedType.join(", "),
            },
            target,
        });
        return false;
    }
    return true;
}
function createDecoratorDefinition(definition) {
    const minParams = definition.args.filter((x) => !x.optional).length;
    const maxParams = definition.spreadArgs ? undefined : definition.args.length;
    function validate(context, target, args) {
        var _a;
        if (!validateDecoratorTarget(context, target, definition.name, definition.target) ||
            !validateDecoratorParamCount(context, minParams, maxParams, args)) {
            return false;
        }
        for (const [index, arg] of args.entries()) {
            const paramDefinition = (_a = definition.args[index]) !== null && _a !== void 0 ? _a : definition.spreadArgs;
            if (arg === undefined) {
                if (!paramDefinition.optional) {
                    reportDiagnostic(context.program, {
                        code: "invalid-argument",
                        format: {
                            value: "undefined",
                            actual: "undefined",
                            expected: expectedTypeList(paramDefinition.kind),
                        },
                        target: context.getArgumentTarget(index),
                    });
                    return false;
                }
            }
            else if (!isCadlValueTypeOf(arg, paramDefinition.kind)) {
                reportDiagnostic(context.program, {
                    code: "invalid-argument",
                    format: {
                        value: prettyValue(context.program, arg),
                        actual: getTypeKind(arg),
                        expected: expectedTypeList(paramDefinition.kind),
                    },
                    target: context.getArgumentTarget(index),
                });
                return false;
            }
        }
        return true;
    }
    return {
        validate(context, target, parameters) {
            return validate(context, target, parameters);
        },
    };
}
function expectedTypeList(expectedType) {
    return typeof expectedType === "string" ? expectedType : expectedType.join(", ");
}
function validateDecoratorParamCount(context, min, max, parameters) {
    let missing = 0;
    for (let i = parameters.length - 1; i >= 0; i--) {
        if (parameters[i] === undefined) {
            missing++;
        }
        else {
            break;
        }
    }
    const parameterCount = parameters.length - missing;
    if (parameterCount < min || (max !== undefined && parameterCount > max)) {
        if (min === max) {
            reportDiagnostic(context.program, {
                code: "invalid-argument-count",
                format: {
                    actual: parameterCount.toString(),
                    expected: min.toString(),
                },
                target: context.decoratorTarget,
            });
        }
        else {
            reportDiagnostic(context.program, {
                code: "invalid-argument-count",
                messageId: "between",
                format: {
                    actual: parameterCount.toString(),
                    min: min.toString(),
                    max: max === undefined ? "infinity" : max.toString(),
                },
                target: context.decoratorTarget,
            });
        }
        return false;
    }
    return true;
}
function prettyValue(program, value) {
    if (typeof value === "object" && value !== null && "kind" in value) {
        return program.checker.getTypeName(value);
    }
    return value;
}
/**
 * Convert a cadl type to a serializable Json object.
 * Emits diagnostics if the given type is invalid
 * @param cadlType The type to convert to Json data
 * @param target The diagnostic target in case of errors.
 */
function cadlTypeToJson(cadlType, target) {
    if (typeof cadlType !== "object") {
        return [cadlType, []];
    }
    return cadlTypeToJsonInternal(cadlType, target, []);
}
function cadlTypeToJsonInternal(cadlType, target, path) {
    var _a;
    switch (cadlType.kind) {
        case "String":
        case "Boolean":
        case "Number":
            return [cadlType.value, []];
        case "EnumMember":
            return [(_a = cadlType.value) !== null && _a !== void 0 ? _a : cadlType.name, []];
        case "Tuple": {
            const result = [];
            for (const [index, type] of cadlType.values.entries()) {
                const [item, diagnostics] = cadlTypeToJsonInternal(type, target, [
                    ...path,
                    index.toString(),
                ]);
                if (diagnostics.length > 0) {
                    return [undefined, diagnostics];
                }
                result.push(item);
            }
            return [result, []];
        }
        case "Model": {
            const result = {};
            for (const [name, type] of cadlType.properties.entries()) {
                const [item, diagnostics] = cadlTypeToJsonInternal(type.type, target, [
                    ...path,
                    name.toString(),
                ]);
                if (diagnostics.length > 0) {
                    return [undefined, diagnostics];
                }
                result[name] = item;
            }
            return [result, []];
        }
        default:
            const diagnostic = path.length === 0
                ? createDiagnostic({
                    code: "invalid-value",
                    format: {
                        kind: cadlType.kind,
                    },
                    target,
                })
                : createDiagnostic({
                    code: "invalid-value",
                    messageId: "atPath",
                    format: {
                        kind: cadlType.kind,
                        path: path.join("."),
                    },
                    target,
                });
            return [undefined, [diagnostic]];
    }
}

const programServiceDetails = new WeakMap();
function getServiceDetails(program) {
    var _a, _b;
    let serviceDetails = programServiceDetails.get((_a = program.currentProjector) !== null && _a !== void 0 ? _a : program);
    if (!serviceDetails) {
        serviceDetails = {};
        programServiceDetails.set((_b = program.currentProjector) !== null && _b !== void 0 ? _b : program, serviceDetails);
    }
    return serviceDetails;
}
function setServiceNamespace(program, namespace) {
    const serviceDetails = getServiceDetails(program);
    if (serviceDetails.namespace && serviceDetails.namespace !== namespace) {
        program.reportDiagnostic(createDiagnostic({ code: "service-namespace-duplicate", target: namespace }));
    }
    serviceDetails.namespace = namespace;
}
function checkIfServiceNamespace(program, namespace) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.namespace === namespace;
}
function $serviceTitle(context, target, title) {
    const serviceDetails = getServiceDetails(context.program);
    if (serviceDetails.title) {
        context.program.reportDiagnostic(createDiagnostic({
            code: "service-decorator-duplicate",
            format: { name: "title" },
            target,
        }));
    }
    if (!validateDecoratorTarget(context, target, "@serviceTitle", "Namespace")) {
        return;
    }
    setServiceNamespace(context.program, target);
    serviceDetails.title = title;
}
function getServiceTitle(program) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.title || "(title)";
}
function $serviceVersion(context, target, version) {
    const serviceDetails = getServiceDetails(context.program);
    if (serviceDetails.version) {
        context.program.reportDiagnostic(createDiagnostic({
            code: "service-decorator-duplicate",
            format: { name: "version" },
            target,
        }));
    }
    if (!validateDecoratorTarget(context, target, "@serviceVersion", "Namespace")) {
        return;
    }
    setServiceNamespace(context.program, target);
    serviceDetails.version = version;
}
function getServiceVersion(program) {
    const serviceDetails = getServiceDetails(program);
    return serviceDetails.version || "0000-00-00";
}
function getServiceNamespace(program) {
    var _a;
    const serviceDetails = getServiceDetails(program);
    return (_a = serviceDetails.namespace) !== null && _a !== void 0 ? _a : program.checker.getGlobalNamespaceType();
}
function getServiceNamespaceString(program) {
    const serviceDetails = getServiceDetails(program);
    return ((serviceDetails.namespace && program.checker.getNamespaceString(serviceDetails.namespace)) ||
        undefined);
}

const namespace = "Cadl";
function replaceTemplatedStringFromProperties(formatString, sourceObject) {
    // Template parameters are not valid source objects, just skip them
    if (sourceObject.kind === "TemplateParameter") {
        return formatString;
    }
    return formatString.replace(/{(\w+)}/g, (_, propName) => {
        return sourceObject[propName];
    });
}
function setTemplatedStringProperty(key, program, target, text, sourceObject) {
    // TODO: replace with built-in decorator validation https://github.com/Azure/cadl-azure/issues/1022
    if (!validateDecoratorParamType(program, target, text, "String")) {
        return;
    }
    // If an object was passed in, use it to format the documentation string
    if (sourceObject) {
        text = replaceTemplatedStringFromProperties(text, sourceObject);
    }
    program.stateMap(key).set(target, text);
}
const summaryKey = Symbol("summary");
/**
 * @summary attaches a documentation string. It is typically used to give a short, single-line
 * description, and can be used in combination with or instead of @doc.
 *
 * The first argument to @summary is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @summary can be specified on any language element -- a model, an operation, a namespace, etc.
 */
function $summary(context, target, text, sourceObject) {
    setTemplatedStringProperty(summaryKey, context.program, target, text, sourceObject);
}
function getSummary(program, type) {
    return program.stateMap(summaryKey).get(type);
}
const docsKey = Symbol("docs");
/**
 * @doc attaches a documentation string. Works great with multi-line string literals.
 *
 * The first argument to @doc is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @doc can be specified on any language element -- a model, an operation, a namespace, etc.
 */
function $doc(context, target, text, sourceObject) {
    setTemplatedStringProperty(docsKey, context.program, target, text, sourceObject);
}
function getDoc(program, target) {
    return program.stateMap(docsKey).get(target);
}
function $inspectType(program, target, text) {
    // eslint-disable-next-line no-console
    if (text)
        console.log(text);
    // eslint-disable-next-line no-console
    console.dir(target, { depth: 3 });
}
function $inspectTypeName(program, target, text) {
    // eslint-disable-next-line no-console
    if (text)
        console.log(text);
    // eslint-disable-next-line no-console
    console.log(program.checker.getTypeName(target));
}
const intrinsicsKey = Symbol("intrinsics");
function $intrinsic(context, target, name) {
    context.program.stateMap(intrinsicsKey).set(target, name);
}
function isIntrinsic(program, target) {
    if (!target) {
        return false;
    }
    return program.stateMap(intrinsicsKey).has(target);
}
const indexTypeKey = Symbol("index");
function $indexer(context, target, key, value) {
    const indexer = { key, value };
    context.program.stateMap(indexTypeKey).set(target, indexer);
}
function getIndexer(program, target) {
    return program.stateMap(indexTypeKey).get(target);
}
/**
 * The top level name of the intrinsic model.
 *
 * string => "string"
 * model CustomString is string => "string"
 */
function getIntrinsicModelName(program, target) {
    return program.stateMap(intrinsicsKey).get(target);
}
function isStringType(program, target) {
    const intrinsicType = getIntrinsicModelName(program, target);
    return intrinsicType !== undefined && intrinsicType === "string";
}
function isErrorType$1(type) {
    return type.kind === "Intrinsic" && type.name === "ErrorType";
}
function isVoidType(type) {
    return type.kind === "Intrinsic" && type.name === "void";
}
function isNeverType(type) {
    return type.kind === "Intrinsic" && type.name === "never";
}
function isUnknownType(type) {
    return type.kind === "Intrinsic" && type.name === "unknown";
}
/**
 * Check if a model is an array type.
 * @param type Model type
 */
function isArrayModelType(program, type) {
    return Boolean(type.indexer && getIntrinsicModelName(program, type.indexer.key) === "integer");
}
/**
 * Check if a model is an array type.
 * @param type Model type
 */
function isRecordModelType(program, type) {
    return Boolean(type.indexer && getIntrinsicModelName(program, type.indexer.key) === "string");
}
const numericTypesKey = Symbol("numeric");
function $numeric(context, target) {
    const { program } = context;
    if (!isIntrinsic(program, target)) {
        program.reportDiagnostic(createDiagnostic({
            code: "decorator-wrong-target",
            format: { decorator: "@numeric", to: "non-instrinsic type" },
            target,
        }));
        return;
    }
    if (!validateDecoratorTarget(context, target, "@numeric", "Model")) {
        return;
    }
    program.stateSet(numericTypesKey).add(target);
}
/**
 * Return the type of the property or the model itself.
 */
function getPropertyType(target) {
    if (target.kind === "ModelProperty") {
        return target.type;
    }
    else {
        return target;
    }
}
function isNumericType(program, target) {
    return isIntrinsic(program, target) && program.stateSet(numericTypesKey).has(target);
}
// -- @error decorator ----------------------
const errorKey = Symbol("error");
function $error(context, target) {
    if (!validateDecoratorTarget(context, target, "@error", "Model")) {
        return;
    }
    context.program.stateSet(errorKey).add(target);
}
function isErrorModel(program, target) {
    return program.stateSet(errorKey).has(target);
}
// -- @format decorator ---------------------
const formatValuesKey = Symbol("formatValues");
/**
 * `@format` - specify the data format hint for a string type
 *
 * The first argument is a string that identifies the format that the string type expects.  Any string
 * can be entered here, but a Cadl emitter must know how to interpret
 *
 * For Cadl specs that will be used with an OpenAPI emitter, the OpenAPI specification describes possible
 * valid values for a string type's format:
 *
 * https://swagger.io/specification/#data-types
 *
 * `@format` can be specified on a type that extends from `string` or a `string`-typed model property.
 */
function $format(context, target, format) {
    if (!validateDecoratorTarget(context, target, "@format", ["Model", "ModelProperty"]) ||
        !validateDecoratorTargetIntrinsic(context, target, "@format", ["string", "bytes"])) {
        return;
    }
    context.program.stateMap(formatValuesKey).set(target, format);
}
function getFormat(program, target) {
    return program.stateMap(formatValuesKey).get(target);
}
// -- @pattern decorator ---------------------
const patternValuesKey = Symbol("patternValues");
function $pattern(context, target, pattern) {
    if (!validateDecoratorTarget(context, target, "@pattern", ["Model", "ModelProperty"]) ||
        !validateDecoratorTargetIntrinsic(context, target, "@pattern", "string")) {
        return;
    }
    context.program.stateMap(patternValuesKey).set(target, pattern);
}
function getPattern(program, target) {
    return program.stateMap(patternValuesKey).get(target);
}
// -- @minLength decorator ---------------------
const minLengthValuesKey = Symbol("minLengthValues");
function $minLength(context, target, minLength) {
    if (!validateDecoratorTarget(context, target, "@minLength", ["Model", "ModelProperty"]) ||
        !validateDecoratorTargetIntrinsic(context, target, "@minLength", "string")) {
        return;
    }
    context.program.stateMap(minLengthValuesKey).set(target, minLength);
}
function getMinLength(program, target) {
    return program.stateMap(minLengthValuesKey).get(target);
}
// -- @maxLength decorator ---------------------
const maxLengthValuesKey = Symbol("maxLengthValues");
function $maxLength(context, target, maxLength) {
    if (!validateDecoratorTarget(context, target, "@maxLength", ["Model", "ModelProperty"]) ||
        !validateDecoratorTargetIntrinsic(context, target, "@maxLength", "string")) {
        return;
    }
    context.program.stateMap(maxLengthValuesKey).set(target, maxLength);
}
function getMaxLength(program, target) {
    return program.stateMap(maxLengthValuesKey).get(target);
}
// -- @minValue decorator ---------------------
const minValuesKey = Symbol("minValues");
function $minValue(context, target, minValue) {
    if (!validateDecoratorTarget(context, target, "@minValue", ["Model", "ModelProperty"])) {
        return;
    }
    const { program } = context;
    if (!isNumericType(program, getPropertyType(target))) {
        program.reportDiagnostic(createDiagnostic({
            code: "decorator-wrong-target",
            format: { decorator: "@minValue", to: "non-numeric type" },
            target,
        }));
        return;
    }
    program.stateMap(minValuesKey).set(target, minValue);
}
function getMinValue(program, target) {
    return program.stateMap(minValuesKey).get(target);
}
// -- @maxValue decorator ---------------------
const maxValuesKey = Symbol("maxValues");
function $maxValue(context, target, maxValue) {
    if (!validateDecoratorTarget(context, target, "@maxValue", ["Model", "ModelProperty"])) {
        return;
    }
    const { program } = context;
    if (!isNumericType(program, getPropertyType(target))) {
        program.reportDiagnostic(createDiagnostic({
            code: "decorator-wrong-target",
            format: { decorator: "@minValue", to: "non-numeric type" },
            target,
        }));
        return;
    }
    program.stateMap(maxValuesKey).set(target, maxValue);
}
function getMaxValue(program, target) {
    return program.stateMap(maxValuesKey).get(target);
}
// -- @secret decorator ---------------------
const secretTypesKey = Symbol("secretTypes");
const secretDecorator = createDecoratorDefinition({
    name: "@secret",
    target: ["Model", "ModelProperty"],
    args: [],
});
/**
 * Mark a string as a secret value that should be treated carefully to avoid exposure
 * @param context Decorator context
 * @param target Decorator target, either a string model or a property with type string.
 */
function $secret(context, target) {
    if (!secretDecorator.validate(context, target, []) ||
        !validateDecoratorTargetIntrinsic(context, target, "@secret", "string")) {
        return;
    }
    context.program.stateMap(secretTypesKey).set(target, true);
}
function isSecret(program, target) {
    return program.stateMap(secretTypesKey).get(target);
}
// -- @visibility decorator ---------------------
const visibilitySettingsKey = Symbol("visibilitySettings");
function $visibility(context, target, ...visibilities) {
    if (!validateDecoratorTarget(context, target, "@visibility", ["ModelProperty"])) {
        return;
    }
    context.program.stateMap(visibilitySettingsKey).set(target, visibilities);
}
function getVisibility(program, target) {
    return program.stateMap(visibilitySettingsKey).get(target);
}
function $withVisibility(context, target, ...visibilities) {
    if (!validateDecoratorTarget(context, target, "@withVisibility", "Model")) {
        return;
    }
    const filter = (_, prop) => {
        const vis = getVisibility(context.program, prop);
        return vis !== undefined && visibilities.filter((v) => !vis.includes(v)).length > 0;
    };
    mapFilterOut(target.properties, filter);
}
function mapFilterOut(map, pred) {
    for (const [key, prop] of map) {
        if (pred(key, prop)) {
            map.delete(key);
        }
    }
}
// -- @withOptionalProperties decorator ---------------------
function $withOptionalProperties(context, target) {
    if (!validateDecoratorTarget(context, target, "@withOptionalProperties", "Model")) {
        return;
    }
    // Make all properties of the target type optional
    target.properties.forEach((p) => (p.optional = true));
}
// -- @withUpdateableProperties decorator ----------------------
function $withUpdateableProperties(context, target) {
    if (!validateDecoratorTarget(context, target, "@withUpdateableProperties", "Model")) {
        return;
    }
    // remove all read-only properties from the target type
    mapFilterOut(target.properties, (key, value) => {
        const vis = getVisibility(context.program, value);
        return vis !== undefined && vis.length > 0 && !vis.includes("update");
    });
}
// -- @withoutOmittedProperties decorator ----------------------
function $withoutOmittedProperties(context, target, omitProperties) {
    if (omitProperties.kind == "TemplateParameter") {
        // Silently return because this is a templated type
        return;
    }
    if (!validateDecoratorTarget(context, target, "@withoutOmittedProperties", "Model")) {
        return;
    }
    if (!validateDecoratorParamType(context.program, target, omitProperties, ["String", "Union"])) {
        return;
    }
    // Get the property or properties to omit
    const omitNames = new Set();
    if (omitProperties.kind === "Union") {
        for (const value of omitProperties.options) {
            if (value.kind === "String") {
                omitNames.add(value.value);
            }
        }
    }
    else {
        omitNames.add(omitProperties);
    }
    // Remove all properties to be omitted
    mapFilterOut(target.properties, (key, _) => omitNames.has(key));
}
// -- @withoutDefaultValues decorator ----------------------
function $withoutDefaultValues(context, target) {
    if (!validateDecoratorTarget(context, target, "@withoutDefaultValues", "Model")) {
        return;
    }
    // remove all read-only properties from the target type
    target.properties.forEach((p) => delete p.default);
}
// -- @list decorator ---------------------
const listPropertiesKey = Symbol("listProperties");
function $list(context, target, listedType) {
    if (!validateDecoratorTarget(context, target, "@list", "Operation")) {
        return;
    }
    if (listedType && listedType.kind == "TemplateParameter") {
        // Silently return because this is probably being used in a templated interface
        return;
    }
    if (listedType && listedType.kind !== "Model") {
        reportDiagnostic(context.program, {
            code: "list-type-not-model",
            target: context.getArgumentTarget(0),
        });
        return;
    }
    context.program.stateMap(listPropertiesKey).set(target, listedType);
}
function getListOperationType(program, target) {
    return program.stateMap(listPropertiesKey).get(target);
}
function isListOperation(program, target) {
    // The type stored for the operation
    return program.stateMap(listPropertiesKey).has(target);
}
// -- @tag decorator ---------------------
const tagPropertiesKey = Symbol("tagProperties");
// Set a tag on an operation or namespace.  There can be multiple tags on either an
// operation or namespace.
function $tag(context, target, tag) {
    if (!validateDecoratorTarget(context, target, "@tag", ["Operation", "Namespace", "Interface"])) {
        return;
    }
    const tags = context.program.stateMap(tagPropertiesKey).get(target);
    if (tags) {
        tags.push(tag);
    }
    else {
        context.program.stateMap(tagPropertiesKey).set(target, [tag]);
    }
}
// Return the tags set on an operation or namespace
function getTags(program, target) {
    return program.stateMap(tagPropertiesKey).get(target) || [];
}
// Merge the tags for a operation with the tags that are on the namespace or
// interface it resides within.
function getAllTags(program, target) {
    var _a;
    const tags = new Set();
    let current = target;
    while (current !== undefined) {
        for (const t of getTags(program, current)) {
            tags.add(t);
        }
        // Move up to the parent
        if (current.kind === "Operation") {
            current = (_a = current.interface) !== null && _a !== void 0 ? _a : current.namespace;
        }
        else {
            // Type is a namespace or interface
            current = current.namespace;
        }
    }
    return tags.size > 0 ? Array.from(tags).reverse() : undefined;
}
// -- @friendlyName decorator ---------------------
const friendlyNamesKey = Symbol("friendlyNames");
function $friendlyName(context, target, friendlyName, sourceObject) {
    // TODO: replace with built-in decorator validation https://github.com/Azure/cadl-azure/issues/1022
    if (!validateDecoratorParamType(context.program, target, friendlyName, "String")) {
        return;
    }
    if (!validateDecoratorTarget(context, target, "@friendlyName", "Model")) {
        return;
    }
    // If an object was passed in, use it to format the friendly name
    if (sourceObject) {
        friendlyName = replaceTemplatedStringFromProperties(friendlyName, sourceObject);
    }
    context.program.stateMap(friendlyNamesKey).set(target, friendlyName);
}
function getFriendlyName(program, target) {
    return program.stateMap(friendlyNamesKey).get(target);
}
const knownValuesKey = Symbol("knownValues");
/**
 * `@knownValues` marks a string type with an enum that contains all known values
 *
 * The first parameter is a reference to an enum type that describes all possible values that the
 * type accepts.
 *
 * `@knownValues` can only be applied to model types that extend `string`.
 *
 * @param target Decorator target. Must be a string. (model Foo extends string)
 * @param knownValues Must be an enum.
 */
function $knownValues(context, target, knownValues) {
    if (!validateDecoratorTarget(context, target, "@format", ["Model", "ModelProperty"]) ||
        !validateDecoratorTargetIntrinsic(context, target, "@knownValues", [
            "string",
            "int8",
            "int16",
            "int32",
            "int64",
            "float32",
            "float64",
        ]) ||
        !validateDecoratorParamType(context.program, target, knownValues, "Enum")) {
        return;
    }
    for (const member of knownValues.members) {
        const intrinsicType = getIntrinsicModelName(context.program, getPropertyType(target));
        if (!isEnumMemberAssignableToType(intrinsicType, member)) {
            reportDiagnostic(context.program, {
                code: "known-values-invalid-enum",
                format: {
                    member: member.name,
                    type: intrinsicType,
                },
                target,
            });
            return;
        }
    }
    context.program.stateMap(knownValuesKey).set(target, knownValues);
}
function isEnumMemberAssignableToType(typeName, member) {
    const memberType = member.value !== undefined ? typeof member.value : "string";
    switch (memberType) {
        case "string":
            return typeName === "string";
        case "number":
            switch (typeName) {
                case "int8":
                case "int16":
                case "int32":
                case "int64":
                case "float32":
                case "float64":
                    return true;
                default:
                    return false;
            }
        default:
            return false;
    }
}
function getKnownValues(program, target) {
    return program.stateMap(knownValuesKey).get(target);
}
const keyKey = Symbol("key");
/**
 * `@key` - mark a model property as the key to identify instances of that type
 *
 * The optional first argument accepts an alternate key name which may be used by emitters.
 * Otherwise, the name of the target property will be used.
 *
 * `@key` can only be applied to model properties.
 */
function $key(context, entity, altName) {
    if (!validateDecoratorTarget(context, entity, "@key", "ModelProperty")) {
        return;
    }
    if (altName && !validateDecoratorParamType(context.program, entity, altName, "String")) {
        return;
    }
    // Ensure that the key property is not marked as optional
    if (entity.optional) {
        reportDiagnostic(context.program, {
            code: "no-optional-key",
            format: { propertyName: entity.name },
            target: entity,
        });
        return;
    }
    // Register the key property
    context.program.stateMap(keyKey).set(entity, altName || entity.name);
}
function isKey(program, property) {
    return program.stateMap(keyKey).has(property);
}
function getKeyName(program, property) {
    return program.stateMap(keyKey).get(property);
}
/**
 * `@withDefaultKeyVisibility` - set the visibility of key properties in a model if not already set
 *
 * The first argument accepts a string representing the desired default
 * visibility value.  If a key property already has a `visibility` decorator
 * then the default visibility is not applied.
 *
 * `@withDefaultKeyVisibility` can only be applied to model types.
 */
function $withDefaultKeyVisibility(context, entity, visibility) {
    if (!validateDecoratorTarget(context, entity, "@withDefaultKeyVisibility", "Model")) {
        return;
    }
    const keyProperties = [];
    entity.properties.forEach((prop) => {
        // Keep track of any key property without a visibility
        if (isKey(context.program, prop) && !getVisibility(context.program, prop)) {
            keyProperties.push(prop);
        }
    });
    // For each key property without a visibility, clone it and add the specified
    // default visibility value
    keyProperties.forEach((keyProp) => {
        entity.properties.set(keyProp.name, context.program.checker.cloneType(keyProp, {
            decorators: [
                ...keyProp.decorators,
                { decorator: $visibility, args: [{ value: visibility }] },
            ],
        }));
    });
}
/**
 * Mark a type as deprecated
 * @param context DecoratorContext
 * @param target Decorator target
 * @param message Deprecation target.
 *
 * @example
 * ``` @deprecated("Foo is deprecated, use Bar instead.")
 *     model Foo {}
 * ```
 */
function $deprecated(context, target, message) {
    return context.program.stateMap(deprecatedKey).set(target, message);
}
const deprecatedKey = Symbol("deprecated");
/**
 * Check if the given type is deprecated
 * @param program Program
 * @param type Type
 */
function isDeprecated(program, type) {
    return program.stateMap(deprecatedKey).has(type);
}
/**
 * Return the deprecated message or undefined if not deprecated
 * @param program Program
 * @param type Type
 */
function getDeprecated(program, type) {
    return program.stateMap(deprecatedKey).get(type);
}
const overloadedByKey = Symbol("overloadedByKey");
const overloadsOperationKey = Symbol("overloadsOperation");
const overloadDecorator = createDecoratorDefinition({
    name: "@overload",
    target: "Operation",
    args: [{ kind: "Operation" }],
});
/**
 * `@overload` - Indicate that the target overloads (specializes) the overloads type.
 * @param context DecoratorContext
 * @param target The specializing operation declaration
 * @param overloads The operation to be overloaded.
 */
function $overload(context, target, overloads) {
    if (!overloadDecorator.validate(context, target, [overloads])) {
        return;
    }
    // Ensure that the overloaded method arguments are a subtype of the original operation.
    const [valid, diagnostics] = context.program.checker.isTypeAssignableTo(target.parameters, overloads.parameters, target);
    if (!valid)
        context.program.reportDiagnostics(diagnostics);
    // Save the information about the overloaded operation
    context.program.stateMap(overloadsOperationKey).set(target, overloads);
    const existingOverloads = getOverloads(context.program, overloads) || new Array();
    context.program.stateMap(overloadedByKey).set(overloads, existingOverloads.concat(target));
}
/**
 * Get all operations that are marked as overloads of the given operation
 * @param context
 * @param operation
 * @returns An array of operations that overload the given operation.
 */
function getOverloads(program, operation) {
    return program.stateMap(overloadedByKey).get(operation);
}
/**
 * If the given operation overloads another operation, return that operation.
 * @param program Program
 * @param operation The operation to check for an overload target.
 * @returns The operation this operation overloads, if any.
 */
function getOverloadedOperation(program, operation) {
    return program.stateMap(overloadsOperationKey).get(operation);
}

var f0 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    namespace: namespace,
    $summary: $summary,
    getSummary: getSummary,
    $doc: $doc,
    getDoc: getDoc,
    $inspectType: $inspectType,
    $inspectTypeName: $inspectTypeName,
    $intrinsic: $intrinsic,
    isIntrinsic: isIntrinsic,
    $indexer: $indexer,
    getIndexer: getIndexer,
    getIntrinsicModelName: getIntrinsicModelName,
    isStringType: isStringType,
    isErrorType: isErrorType$1,
    isVoidType: isVoidType,
    isNeverType: isNeverType,
    isUnknownType: isUnknownType,
    isArrayModelType: isArrayModelType,
    isRecordModelType: isRecordModelType,
    $numeric: $numeric,
    getPropertyType: getPropertyType,
    isNumericType: isNumericType,
    $error: $error,
    isErrorModel: isErrorModel,
    $format: $format,
    getFormat: getFormat,
    $pattern: $pattern,
    getPattern: getPattern,
    $minLength: $minLength,
    getMinLength: getMinLength,
    $maxLength: $maxLength,
    getMaxLength: getMaxLength,
    $minValue: $minValue,
    getMinValue: getMinValue,
    $maxValue: $maxValue,
    getMaxValue: getMaxValue,
    $secret: $secret,
    isSecret: isSecret,
    $visibility: $visibility,
    getVisibility: getVisibility,
    $withVisibility: $withVisibility,
    $withOptionalProperties: $withOptionalProperties,
    $withUpdateableProperties: $withUpdateableProperties,
    $withoutOmittedProperties: $withoutOmittedProperties,
    $withoutDefaultValues: $withoutDefaultValues,
    $list: $list,
    getListOperationType: getListOperationType,
    isListOperation: isListOperation,
    $tag: $tag,
    getTags: getTags,
    getAllTags: getAllTags,
    $friendlyName: $friendlyName,
    getFriendlyName: getFriendlyName,
    $knownValues: $knownValues,
    getKnownValues: getKnownValues,
    $key: $key,
    isKey: isKey,
    getKeyName: getKeyName,
    $withDefaultKeyVisibility: $withDefaultKeyVisibility,
    $deprecated: $deprecated,
    isDeprecated: isDeprecated,
    getDeprecated: getDeprecated,
    $overload: $overload,
    getOverloads: getOverloads,
    getOverloadedOperation: getOverloadedOperation,
    setServiceNamespace: setServiceNamespace,
    checkIfServiceNamespace: checkIfServiceNamespace,
    $serviceTitle: $serviceTitle,
    getServiceTitle: getServiceTitle,
    $serviceVersion: $serviceVersion,
    getServiceVersion: getServiceVersion,
    getServiceNamespace: getServiceNamespace,
    getServiceNamespaceString: getServiceNamespaceString
});

/**
 * Cadl Language configuration. Format: https://code.visualstudio.com/api/language-extensions/language-configuration-guide
 */
const CadlLanguageConfiguration = {
    comments: {
        lineComment: "//",
        blockComment: ["/*", "*/"],
    },
    brackets: [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
    ],
    autoClosingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: "/**", close: " */", notIn: ["string"] },
        // NOTE: quotes omitted here intentionally for now as they interfere with typing """
    ],
    surroundingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: '"', close: '"' },
    ],
    // From https://github.com/Microsoft/vscode/blob/main/extensions/javascript/javascript-language-configuration.json
    indentationRules: {
        decreaseIndentPattern: {
            pattern: "^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$",
        },
        increaseIndentPattern: {
            pattern: "^((?!//).)*(\\{([^}\"'`/]*|(\\t|[ ])*//.*)|\\([^)\"'`/]*|\\[[^\\]\"'`/]*)$",
        },
        // e.g.  * ...| or */| or *-----*/|
        unIndentedLinePattern: {
            pattern: "^(\\t|[ ])*[ ]\\*[^/]*\\*/\\s*$|^(\\t|[ ])*[ ]\\*/\\s*$|^(\\t|[ ])*[ ]\\*([ ]([^\\*]|\\*(?!/))*)?$",
        },
    },
    onEnterRules: [
        {
            // e.g. /** | */
            beforeText: {
                pattern: "^\\s*/\\*\\*(?!/)([^\\*]|\\*(?!/))*$",
            },
            afterText: {
                pattern: "^\\s*\\*/$",
            },
            action: {
                indent: "indentOutdent",
                appendText: " * ",
            },
        },
        {
            // e.g. /** ...|
            beforeText: {
                pattern: "^\\s*/\\*\\*(?!/)([^\\*]|\\*(?!/))*$",
            },
            action: {
                indent: "none",
                appendText: " * ",
            },
        },
        {
            // e.g.  * ...|
            beforeText: {
                pattern: "^(\\t|[ ])*[ ]\\*([ ]([^\\*]|\\*(?!/))*)?$",
            },
            previousLineText: {
                pattern: "(?=^(\\s*(/\\*\\*|\\*)).*)(?=(?!(\\s*\\*/)))",
            },
            action: {
                indent: "none",
                appendText: "* ",
            },
        },
        {
            // e.g.  */|
            beforeText: {
                pattern: "^(\\t|[ ])*[ ]\\*/\\s*$",
            },
            action: {
                indent: "none",
                removeText: 1,
            },
        },
        {
            // e.g.  *-----*/|
            beforeText: {
                pattern: "^(\\t|[ ])*[ ]\\*[^/]*\\*/\\s*$",
            },
            action: {
                indent: "none",
                removeText: 1,
            },
        },
    ],
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var node = {exports: {}};

var main$3 = {};

var api$2 = {};

var semanticTokens = {};

var main$2 = {};

var browser$1 = {exports: {}};

var main$1 = {};

var ril = {};

var ral = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(ral, "__esModule", { value: true });
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
ral.default = RAL;

var disposable = {};

(function (exports) {
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Disposable = void 0;
	(function (Disposable) {
	    function create(func) {
	        return {
	            dispose: func
	        };
	    }
	    Disposable.create = create;
	})(exports.Disposable || (exports.Disposable = {}));
	
} (disposable));

var events = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Emitter = exports.Event = void 0;
	const ral_1 = ral;
	(function (Event) {
	    const _disposable = { dispose() { } };
	    Event.None = function () { return _disposable; };
	})(exports.Event || (exports.Event = {}));
	class CallbackList {
	    add(callback, context = null, bucket) {
	        if (!this._callbacks) {
	            this._callbacks = [];
	            this._contexts = [];
	        }
	        this._callbacks.push(callback);
	        this._contexts.push(context);
	        if (Array.isArray(bucket)) {
	            bucket.push({ dispose: () => this.remove(callback, context) });
	        }
	    }
	    remove(callback, context = null) {
	        if (!this._callbacks) {
	            return;
	        }
	        let foundCallbackWithDifferentContext = false;
	        for (let i = 0, len = this._callbacks.length; i < len; i++) {
	            if (this._callbacks[i] === callback) {
	                if (this._contexts[i] === context) {
	                    // callback & context match => remove it
	                    this._callbacks.splice(i, 1);
	                    this._contexts.splice(i, 1);
	                    return;
	                }
	                else {
	                    foundCallbackWithDifferentContext = true;
	                }
	            }
	        }
	        if (foundCallbackWithDifferentContext) {
	            throw new Error('When adding a listener with a context, you should remove it with the same context');
	        }
	    }
	    invoke(...args) {
	        if (!this._callbacks) {
	            return [];
	        }
	        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
	        for (let i = 0, len = callbacks.length; i < len; i++) {
	            try {
	                ret.push(callbacks[i].apply(contexts[i], args));
	            }
	            catch (e) {
	                // eslint-disable-next-line no-console
	                ral_1.default().console.error(e);
	            }
	        }
	        return ret;
	    }
	    isEmpty() {
	        return !this._callbacks || this._callbacks.length === 0;
	    }
	    dispose() {
	        this._callbacks = undefined;
	        this._contexts = undefined;
	    }
	}
	class Emitter {
	    constructor(_options) {
	        this._options = _options;
	    }
	    /**
	     * For the public to allow to subscribe
	     * to events from this Emitter
	     */
	    get event() {
	        if (!this._event) {
	            this._event = (listener, thisArgs, disposables) => {
	                if (!this._callbacks) {
	                    this._callbacks = new CallbackList();
	                }
	                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
	                    this._options.onFirstListenerAdd(this);
	                }
	                this._callbacks.add(listener, thisArgs);
	                const result = {
	                    dispose: () => {
	                        if (!this._callbacks) {
	                            // disposable is disposed after emitter is disposed.
	                            return;
	                        }
	                        this._callbacks.remove(listener, thisArgs);
	                        result.dispose = Emitter._noop;
	                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
	                            this._options.onLastListenerRemove(this);
	                        }
	                    }
	                };
	                if (Array.isArray(disposables)) {
	                    disposables.push(result);
	                }
	                return result;
	            };
	        }
	        return this._event;
	    }
	    /**
	     * To be kept private to fire an event to
	     * subscribers
	     */
	    fire(event) {
	        if (this._callbacks) {
	            this._callbacks.invoke.call(this._callbacks, event);
	        }
	    }
	    dispose() {
	        if (this._callbacks) {
	            this._callbacks.dispose();
	            this._callbacks = undefined;
	        }
	    }
	}
	exports.Emitter = Emitter;
	Emitter._noop = function () { };
	
} (events));

var messageBuffer = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(messageBuffer, "__esModule", { value: true });
messageBuffer.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
messageBuffer.AbstractMessageBuffer = AbstractMessageBuffer;

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(ril, "__esModule", { value: true });
const ral_1 = ral;
const disposable_1 = disposable;
const events_1 = events;
const messageBuffer_1 = messageBuffer;
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
        this.asciiDecoder = new TextDecoder('ascii');
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, _encoding) {
        return (new TextEncoder()).encode(value);
    }
    toString(value, encoding) {
        if (encoding === 'ascii') {
            return this.asciiDecoder.decode(value);
        }
        else {
            return (new TextDecoder(encoding)).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer;
        }
        else {
            return buffer.slice(0, length);
        }
    }
    allocNative(length) {
        return new Uint8Array(length);
    }
}
MessageBuffer.emptyBuffer = new Uint8Array(0);
class ReadableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
        this._onData = new events_1.Emitter();
        this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
                this._onData.fire(new Uint8Array(buffer));
            });
        };
        this.socket.addEventListener('message', this._messageListener);
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    onData(listener) {
        return this._onData.event(listener);
    }
}
class WritableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    write(data, encoding) {
        if (typeof data === 'string') {
            if (encoding !== undefined && encoding !== 'utf-8') {
                throw new Error(`In a Browser environments only utf-8 text encding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
        }
        else {
            this.socket.send(data);
        }
        return Promise.resolve();
    }
    end() {
        this.socket.close();
    }
}
const _textEncoder = new TextEncoder();
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                if (options.charset !== 'utf-8') {
                    throw new Error(`In a Browser environments only utf-8 text encding is supported. But got encoding: ${options.charset}`);
                }
                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                if (!(buffer instanceof Uint8Array)) {
                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                }
                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
            clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
            return setTimeout(callback, 0, ...args);
        },
        clearImmediate(handle) {
            clearTimeout(handle);
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
ril.default = RIL;

var api$1 = {};

var messages$1 = {};

var is$2 = {};

var hasRequiredIs;

function requireIs () {
	if (hasRequiredIs) return is$2;
	hasRequiredIs = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(is$2, "__esModule", { value: true });
	is$2.stringArray = is$2.array = is$2.func = is$2.error = is$2.number = is$2.string = is$2.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$2.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$2.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$2.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$2.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$2.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$2.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$2.stringArray = stringArray;
	
	return is$2;
}

var hasRequiredMessages;

function requireMessages () {
	if (hasRequiredMessages) return messages$1;
	hasRequiredMessages = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
		const is = requireIs();
		/**
		 * Predefined error codes.
		 */
		var ErrorCodes;
		(function (ErrorCodes) {
		    // Defined by JSON RPC
		    ErrorCodes.ParseError = -32700;
		    ErrorCodes.InvalidRequest = -32600;
		    ErrorCodes.MethodNotFound = -32601;
		    ErrorCodes.InvalidParams = -32602;
		    ErrorCodes.InternalError = -32603;
		    /**
		     * This is the start range of JSON RPC reserved error codes.
		     * It doesn't denote a real error code. No application error codes should
		     * be defined between the start and end range. For backwards
		     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
		     * are left in the range.
		     *
		     * @since 3.16.0
		    */
		    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
		    /** @deprecated use  jsonrpcReservedErrorRangeStart */
		    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
		    ErrorCodes.MessageWriteError = -32099;
		    ErrorCodes.MessageReadError = -32098;
		    ErrorCodes.ServerNotInitialized = -32002;
		    ErrorCodes.UnknownErrorCode = -32001;
		    /**
		     * This is the end range of JSON RPC reserved error codes.
		     * It doesn't denote a real error code.
		     *
		     * @since 3.16.0
		    */
		    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
		    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
		    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
		})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
		/**
		 * An error object return in a response in case a request
		 * has failed.
		 */
		class ResponseError extends Error {
		    constructor(code, message, data) {
		        super(message);
		        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
		        this.data = data;
		        Object.setPrototypeOf(this, ResponseError.prototype);
		    }
		    toJson() {
		        return {
		            code: this.code,
		            message: this.message,
		            data: this.data,
		        };
		    }
		}
		exports.ResponseError = ResponseError;
		class ParameterStructures {
		    constructor(kind) {
		        this.kind = kind;
		    }
		    static is(value) {
		        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
		    }
		    toString() {
		        return this.kind;
		    }
		}
		exports.ParameterStructures = ParameterStructures;
		/**
		 * The parameter structure is automatically inferred on the number of parameters
		 * and the parameter type in case of a single param.
		 */
		ParameterStructures.auto = new ParameterStructures('auto');
		/**
		 * Forces `byPosition` parameter structure. This is useful if you have a single
		 * parameter which has a literal type.
		 */
		ParameterStructures.byPosition = new ParameterStructures('byPosition');
		/**
		 * Forces `byName` parameter structure. This is only useful when having a single
		 * parameter. The library will report errors if used with a different number of
		 * parameters.
		 */
		ParameterStructures.byName = new ParameterStructures('byName');
		/**
		 * An abstract implementation of a MessageType.
		 */
		class AbstractMessageSignature {
		    constructor(method, numberOfParams) {
		        this.method = method;
		        this.numberOfParams = numberOfParams;
		    }
		    get parameterStructures() {
		        return ParameterStructures.auto;
		    }
		}
		exports.AbstractMessageSignature = AbstractMessageSignature;
		/**
		 * Classes to type request response pairs
		 */
		class RequestType0 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 0);
		    }
		}
		exports.RequestType0 = RequestType0;
		class RequestType extends AbstractMessageSignature {
		    constructor(method, _parameterStructures = ParameterStructures.auto) {
		        super(method, 1);
		        this._parameterStructures = _parameterStructures;
		    }
		    get parameterStructures() {
		        return this._parameterStructures;
		    }
		}
		exports.RequestType = RequestType;
		class RequestType1 extends AbstractMessageSignature {
		    constructor(method, _parameterStructures = ParameterStructures.auto) {
		        super(method, 1);
		        this._parameterStructures = _parameterStructures;
		    }
		    get parameterStructures() {
		        return this._parameterStructures;
		    }
		}
		exports.RequestType1 = RequestType1;
		class RequestType2 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 2);
		    }
		}
		exports.RequestType2 = RequestType2;
		class RequestType3 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 3);
		    }
		}
		exports.RequestType3 = RequestType3;
		class RequestType4 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 4);
		    }
		}
		exports.RequestType4 = RequestType4;
		class RequestType5 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 5);
		    }
		}
		exports.RequestType5 = RequestType5;
		class RequestType6 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 6);
		    }
		}
		exports.RequestType6 = RequestType6;
		class RequestType7 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 7);
		    }
		}
		exports.RequestType7 = RequestType7;
		class RequestType8 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 8);
		    }
		}
		exports.RequestType8 = RequestType8;
		class RequestType9 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 9);
		    }
		}
		exports.RequestType9 = RequestType9;
		class NotificationType extends AbstractMessageSignature {
		    constructor(method, _parameterStructures = ParameterStructures.auto) {
		        super(method, 1);
		        this._parameterStructures = _parameterStructures;
		    }
		    get parameterStructures() {
		        return this._parameterStructures;
		    }
		}
		exports.NotificationType = NotificationType;
		class NotificationType0 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 0);
		    }
		}
		exports.NotificationType0 = NotificationType0;
		class NotificationType1 extends AbstractMessageSignature {
		    constructor(method, _parameterStructures = ParameterStructures.auto) {
		        super(method, 1);
		        this._parameterStructures = _parameterStructures;
		    }
		    get parameterStructures() {
		        return this._parameterStructures;
		    }
		}
		exports.NotificationType1 = NotificationType1;
		class NotificationType2 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 2);
		    }
		}
		exports.NotificationType2 = NotificationType2;
		class NotificationType3 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 3);
		    }
		}
		exports.NotificationType3 = NotificationType3;
		class NotificationType4 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 4);
		    }
		}
		exports.NotificationType4 = NotificationType4;
		class NotificationType5 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 5);
		    }
		}
		exports.NotificationType5 = NotificationType5;
		class NotificationType6 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 6);
		    }
		}
		exports.NotificationType6 = NotificationType6;
		class NotificationType7 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 7);
		    }
		}
		exports.NotificationType7 = NotificationType7;
		class NotificationType8 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 8);
		    }
		}
		exports.NotificationType8 = NotificationType8;
		class NotificationType9 extends AbstractMessageSignature {
		    constructor(method) {
		        super(method, 9);
		    }
		}
		exports.NotificationType9 = NotificationType9;
		/**
		 * Tests if the given message is a request message
		 */
		function isRequestMessage(message) {
		    const candidate = message;
		    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
		}
		exports.isRequestMessage = isRequestMessage;
		/**
		 * Tests if the given message is a notification message
		 */
		function isNotificationMessage(message) {
		    const candidate = message;
		    return candidate && is.string(candidate.method) && message.id === void 0;
		}
		exports.isNotificationMessage = isNotificationMessage;
		/**
		 * Tests if the given message is a response message
		 */
		function isResponseMessage(message) {
		    const candidate = message;
		    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
		}
		exports.isResponseMessage = isResponseMessage;
		
} (messages$1));
	return messages$1;
}

var cancellation = {};

var hasRequiredCancellation;

function requireCancellation () {
	if (hasRequiredCancellation) return cancellation;
	hasRequiredCancellation = 1;
	(function (exports) {
		/*---------------------------------------------------------------------------------------------
		 *  Copyright (c) Microsoft Corporation. All rights reserved.
		 *  Licensed under the MIT License. See License.txt in the project root for license information.
		 *--------------------------------------------------------------------------------------------*/
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CancellationTokenSource = exports.CancellationToken = void 0;
		const ral_1 = ral;
		const Is = requireIs();
		const events_1 = events;
		var CancellationToken;
		(function (CancellationToken) {
		    CancellationToken.None = Object.freeze({
		        isCancellationRequested: false,
		        onCancellationRequested: events_1.Event.None
		    });
		    CancellationToken.Cancelled = Object.freeze({
		        isCancellationRequested: true,
		        onCancellationRequested: events_1.Event.None
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && (candidate === CancellationToken.None
		            || candidate === CancellationToken.Cancelled
		            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
		    }
		    CancellationToken.is = is;
		})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
		const shortcutEvent = Object.freeze(function (callback, context) {
		    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
		    return { dispose() { ral_1.default().timer.clearTimeout(handle); } };
		});
		class MutableToken {
		    constructor() {
		        this._isCancelled = false;
		    }
		    cancel() {
		        if (!this._isCancelled) {
		            this._isCancelled = true;
		            if (this._emitter) {
		                this._emitter.fire(undefined);
		                this.dispose();
		            }
		        }
		    }
		    get isCancellationRequested() {
		        return this._isCancelled;
		    }
		    get onCancellationRequested() {
		        if (this._isCancelled) {
		            return shortcutEvent;
		        }
		        if (!this._emitter) {
		            this._emitter = new events_1.Emitter();
		        }
		        return this._emitter.event;
		    }
		    dispose() {
		        if (this._emitter) {
		            this._emitter.dispose();
		            this._emitter = undefined;
		        }
		    }
		}
		class CancellationTokenSource {
		    get token() {
		        if (!this._token) {
		            // be lazy and create the token only when
		            // actually needed
		            this._token = new MutableToken();
		        }
		        return this._token;
		    }
		    cancel() {
		        if (!this._token) {
		            // save an object by returning the default
		            // cancelled token when cancellation happens
		            // before someone asks for the token
		            this._token = CancellationToken.Cancelled;
		        }
		        else {
		            this._token.cancel();
		        }
		    }
		    dispose() {
		        if (!this._token) {
		            // ensure to initialize with an empty token if we had none
		            this._token = CancellationToken.None;
		        }
		        else if (this._token instanceof MutableToken) {
		            // actually dispose
		            this._token.dispose();
		        }
		    }
		}
		exports.CancellationTokenSource = CancellationTokenSource;
		
} (cancellation));
	return cancellation;
}

var messageReader = {};

var hasRequiredMessageReader;

function requireMessageReader () {
	if (hasRequiredMessageReader) return messageReader;
	hasRequiredMessageReader = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
		const ral_1 = ral;
		const Is = requireIs();
		const events_1 = events;
		(function (MessageReader) {
		    function is(value) {
		        let candidate = value;
		        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
		            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
		    }
		    MessageReader.is = is;
		})(exports.MessageReader || (exports.MessageReader = {}));
		class AbstractMessageReader {
		    constructor() {
		        this.errorEmitter = new events_1.Emitter();
		        this.closeEmitter = new events_1.Emitter();
		        this.partialMessageEmitter = new events_1.Emitter();
		    }
		    dispose() {
		        this.errorEmitter.dispose();
		        this.closeEmitter.dispose();
		    }
		    get onError() {
		        return this.errorEmitter.event;
		    }
		    fireError(error) {
		        this.errorEmitter.fire(this.asError(error));
		    }
		    get onClose() {
		        return this.closeEmitter.event;
		    }
		    fireClose() {
		        this.closeEmitter.fire(undefined);
		    }
		    get onPartialMessage() {
		        return this.partialMessageEmitter.event;
		    }
		    firePartialMessage(info) {
		        this.partialMessageEmitter.fire(info);
		    }
		    asError(error) {
		        if (error instanceof Error) {
		            return error;
		        }
		        else {
		            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
		        }
		    }
		}
		exports.AbstractMessageReader = AbstractMessageReader;
		var ResolvedMessageReaderOptions;
		(function (ResolvedMessageReaderOptions) {
		    function fromOptions(options) {
		        var _a;
		        let charset;
		        let contentDecoder;
		        const contentDecoders = new Map();
		        let contentTypeDecoder;
		        const contentTypeDecoders = new Map();
		        if (options === undefined || typeof options === 'string') {
		            charset = options !== null && options !== void 0 ? options : 'utf-8';
		        }
		        else {
		            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
		            if (options.contentDecoder !== undefined) {
		                contentDecoder = options.contentDecoder;
		                contentDecoders.set(contentDecoder.name, contentDecoder);
		            }
		            if (options.contentDecoders !== undefined) {
		                for (const decoder of options.contentDecoders) {
		                    contentDecoders.set(decoder.name, decoder);
		                }
		            }
		            if (options.contentTypeDecoder !== undefined) {
		                contentTypeDecoder = options.contentTypeDecoder;
		                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
		            }
		            if (options.contentTypeDecoders !== undefined) {
		                for (const decoder of options.contentTypeDecoders) {
		                    contentTypeDecoders.set(decoder.name, decoder);
		                }
		            }
		        }
		        if (contentTypeDecoder === undefined) {
		            contentTypeDecoder = ral_1.default().applicationJson.decoder;
		            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
		        }
		        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
		    }
		    ResolvedMessageReaderOptions.fromOptions = fromOptions;
		})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
		class ReadableStreamMessageReader extends AbstractMessageReader {
		    constructor(readable, options) {
		        super();
		        this.readable = readable;
		        this.options = ResolvedMessageReaderOptions.fromOptions(options);
		        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
		        this._partialMessageTimeout = 10000;
		        this.nextMessageLength = -1;
		        this.messageToken = 0;
		    }
		    set partialMessageTimeout(timeout) {
		        this._partialMessageTimeout = timeout;
		    }
		    get partialMessageTimeout() {
		        return this._partialMessageTimeout;
		    }
		    listen(callback) {
		        this.nextMessageLength = -1;
		        this.messageToken = 0;
		        this.partialMessageTimer = undefined;
		        this.callback = callback;
		        const result = this.readable.onData((data) => {
		            this.onData(data);
		        });
		        this.readable.onError((error) => this.fireError(error));
		        this.readable.onClose(() => this.fireClose());
		        return result;
		    }
		    onData(data) {
		        this.buffer.append(data);
		        while (true) {
		            if (this.nextMessageLength === -1) {
		                const headers = this.buffer.tryReadHeaders();
		                if (!headers) {
		                    return;
		                }
		                const contentLength = headers.get('Content-Length');
		                if (!contentLength) {
		                    throw new Error('Header must provide a Content-Length property.');
		                }
		                const length = parseInt(contentLength);
		                if (isNaN(length)) {
		                    throw new Error('Content-Length value must be a number.');
		                }
		                this.nextMessageLength = length;
		            }
		            const body = this.buffer.tryReadBody(this.nextMessageLength);
		            if (body === undefined) {
		                /** We haven't received the full message yet. */
		                this.setPartialMessageTimer();
		                return;
		            }
		            this.clearPartialMessageTimer();
		            this.nextMessageLength = -1;
		            let p;
		            if (this.options.contentDecoder !== undefined) {
		                p = this.options.contentDecoder.decode(body);
		            }
		            else {
		                p = Promise.resolve(body);
		            }
		            p.then((value) => {
		                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
		                    this.callback(msg);
		                }, (error) => {
		                    this.fireError(error);
		                });
		            }, (error) => {
		                this.fireError(error);
		            });
		        }
		    }
		    clearPartialMessageTimer() {
		        if (this.partialMessageTimer) {
		            ral_1.default().timer.clearTimeout(this.partialMessageTimer);
		            this.partialMessageTimer = undefined;
		        }
		    }
		    setPartialMessageTimer() {
		        this.clearPartialMessageTimer();
		        if (this._partialMessageTimeout <= 0) {
		            return;
		        }
		        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
		            this.partialMessageTimer = undefined;
		            if (token === this.messageToken) {
		                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
		                this.setPartialMessageTimer();
		            }
		        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
		    }
		}
		exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
		
} (messageReader));
	return messageReader;
}

var messageWriter = {};

var semaphore = {};

var hasRequiredSemaphore;

function requireSemaphore () {
	if (hasRequiredSemaphore) return semaphore;
	hasRequiredSemaphore = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(semaphore, "__esModule", { value: true });
	semaphore.Semaphore = void 0;
	const ral_1 = ral;
	class Semaphore {
	    constructor(capacity = 1) {
	        if (capacity <= 0) {
	            throw new Error('Capacity must be greater than 0');
	        }
	        this._capacity = capacity;
	        this._active = 0;
	        this._waiting = [];
	    }
	    lock(thunk) {
	        return new Promise((resolve, reject) => {
	            this._waiting.push({ thunk, resolve, reject });
	            this.runNext();
	        });
	    }
	    get active() {
	        return this._active;
	    }
	    runNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        ral_1.default().timer.setImmediate(() => this.doRunNext());
	    }
	    doRunNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        const next = this._waiting.shift();
	        this._active++;
	        if (this._active > this._capacity) {
	            throw new Error(`To many thunks active`);
	        }
	        try {
	            const result = next.thunk();
	            if (result instanceof Promise) {
	                result.then((value) => {
	                    this._active--;
	                    next.resolve(value);
	                    this.runNext();
	                }, (err) => {
	                    this._active--;
	                    next.reject(err);
	                    this.runNext();
	                });
	            }
	            else {
	                this._active--;
	                next.resolve(result);
	                this.runNext();
	            }
	        }
	        catch (err) {
	            this._active--;
	            next.reject(err);
	            this.runNext();
	        }
	    }
	}
	semaphore.Semaphore = Semaphore;
	
	return semaphore;
}

var hasRequiredMessageWriter;

function requireMessageWriter () {
	if (hasRequiredMessageWriter) return messageWriter;
	hasRequiredMessageWriter = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
		const ral_1 = ral;
		const Is = requireIs();
		const semaphore_1 = requireSemaphore();
		const events_1 = events;
		const ContentLength = 'Content-Length: ';
		const CRLF = '\r\n';
		(function (MessageWriter) {
		    function is(value) {
		        let candidate = value;
		        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
		            Is.func(candidate.onError) && Is.func(candidate.write);
		    }
		    MessageWriter.is = is;
		})(exports.MessageWriter || (exports.MessageWriter = {}));
		class AbstractMessageWriter {
		    constructor() {
		        this.errorEmitter = new events_1.Emitter();
		        this.closeEmitter = new events_1.Emitter();
		    }
		    dispose() {
		        this.errorEmitter.dispose();
		        this.closeEmitter.dispose();
		    }
		    get onError() {
		        return this.errorEmitter.event;
		    }
		    fireError(error, message, count) {
		        this.errorEmitter.fire([this.asError(error), message, count]);
		    }
		    get onClose() {
		        return this.closeEmitter.event;
		    }
		    fireClose() {
		        this.closeEmitter.fire(undefined);
		    }
		    asError(error) {
		        if (error instanceof Error) {
		            return error;
		        }
		        else {
		            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
		        }
		    }
		}
		exports.AbstractMessageWriter = AbstractMessageWriter;
		var ResolvedMessageWriterOptions;
		(function (ResolvedMessageWriterOptions) {
		    function fromOptions(options) {
		        var _a, _b;
		        if (options === undefined || typeof options === 'string') {
		            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
		        }
		        else {
		            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
		        }
		    }
		    ResolvedMessageWriterOptions.fromOptions = fromOptions;
		})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
		class WriteableStreamMessageWriter extends AbstractMessageWriter {
		    constructor(writable, options) {
		        super();
		        this.writable = writable;
		        this.options = ResolvedMessageWriterOptions.fromOptions(options);
		        this.errorCount = 0;
		        this.writeSemaphore = new semaphore_1.Semaphore(1);
		        this.writable.onError((error) => this.fireError(error));
		        this.writable.onClose(() => this.fireClose());
		    }
		    async write(msg) {
		        return this.writeSemaphore.lock(async () => {
		            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
		                if (this.options.contentEncoder !== undefined) {
		                    return this.options.contentEncoder.encode(buffer);
		                }
		                else {
		                    return buffer;
		                }
		            });
		            return payload.then((buffer) => {
		                const headers = [];
		                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
		                headers.push(CRLF);
		                return this.doWrite(msg, headers, buffer);
		            }, (error) => {
		                this.fireError(error);
		                throw error;
		            });
		        });
		    }
		    async doWrite(msg, headers, data) {
		        try {
		            await this.writable.write(headers.join(''), 'ascii');
		            return this.writable.write(data);
		        }
		        catch (error) {
		            this.handleError(error, msg);
		            return Promise.reject(error);
		        }
		    }
		    handleError(error, msg) {
		        this.errorCount++;
		        this.fireError(error, msg, this.errorCount);
		    }
		    end() {
		        this.writable.end();
		    }
		}
		exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
		
} (messageWriter));
	return messageWriter;
}

var connection$1 = {};

var linkedMap = {};

var hasRequiredLinkedMap;

function requireLinkedMap () {
	if (hasRequiredLinkedMap) return linkedMap;
	hasRequiredLinkedMap = 1;
	(function (exports) {
		/*---------------------------------------------------------------------------------------------
		 *  Copyright (c) Microsoft Corporation. All rights reserved.
		 *  Licensed under the MIT License. See License.txt in the project root for license information.
		 *--------------------------------------------------------------------------------------------*/
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
		var Touch;
		(function (Touch) {
		    Touch.None = 0;
		    Touch.First = 1;
		    Touch.AsOld = Touch.First;
		    Touch.Last = 2;
		    Touch.AsNew = Touch.Last;
		})(Touch = exports.Touch || (exports.Touch = {}));
		class LinkedMap {
		    constructor() {
		        this[Symbol.toStringTag] = 'LinkedMap';
		        this._map = new Map();
		        this._head = undefined;
		        this._tail = undefined;
		        this._size = 0;
		        this._state = 0;
		    }
		    clear() {
		        this._map.clear();
		        this._head = undefined;
		        this._tail = undefined;
		        this._size = 0;
		        this._state++;
		    }
		    isEmpty() {
		        return !this._head && !this._tail;
		    }
		    get size() {
		        return this._size;
		    }
		    get first() {
		        var _a;
		        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
		    }
		    get last() {
		        var _a;
		        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
		    }
		    has(key) {
		        return this._map.has(key);
		    }
		    get(key, touch = Touch.None) {
		        const item = this._map.get(key);
		        if (!item) {
		            return undefined;
		        }
		        if (touch !== Touch.None) {
		            this.touch(item, touch);
		        }
		        return item.value;
		    }
		    set(key, value, touch = Touch.None) {
		        let item = this._map.get(key);
		        if (item) {
		            item.value = value;
		            if (touch !== Touch.None) {
		                this.touch(item, touch);
		            }
		        }
		        else {
		            item = { key, value, next: undefined, previous: undefined };
		            switch (touch) {
		                case Touch.None:
		                    this.addItemLast(item);
		                    break;
		                case Touch.First:
		                    this.addItemFirst(item);
		                    break;
		                case Touch.Last:
		                    this.addItemLast(item);
		                    break;
		                default:
		                    this.addItemLast(item);
		                    break;
		            }
		            this._map.set(key, item);
		            this._size++;
		        }
		        return this;
		    }
		    delete(key) {
		        return !!this.remove(key);
		    }
		    remove(key) {
		        const item = this._map.get(key);
		        if (!item) {
		            return undefined;
		        }
		        this._map.delete(key);
		        this.removeItem(item);
		        this._size--;
		        return item.value;
		    }
		    shift() {
		        if (!this._head && !this._tail) {
		            return undefined;
		        }
		        if (!this._head || !this._tail) {
		            throw new Error('Invalid list');
		        }
		        const item = this._head;
		        this._map.delete(item.key);
		        this.removeItem(item);
		        this._size--;
		        return item.value;
		    }
		    forEach(callbackfn, thisArg) {
		        const state = this._state;
		        let current = this._head;
		        while (current) {
		            if (thisArg) {
		                callbackfn.bind(thisArg)(current.value, current.key, this);
		            }
		            else {
		                callbackfn(current.value, current.key, this);
		            }
		            if (this._state !== state) {
		                throw new Error(`LinkedMap got modified during iteration.`);
		            }
		            current = current.next;
		        }
		    }
		    keys() {
		        const map = this;
		        const state = this._state;
		        let current = this._head;
		        const iterator = {
		            [Symbol.iterator]() {
		                return iterator;
		            },
		            next() {
		                if (map._state !== state) {
		                    throw new Error(`LinkedMap got modified during iteration.`);
		                }
		                if (current) {
		                    const result = { value: current.key, done: false };
		                    current = current.next;
		                    return result;
		                }
		                else {
		                    return { value: undefined, done: true };
		                }
		            }
		        };
		        return iterator;
		    }
		    values() {
		        const map = this;
		        const state = this._state;
		        let current = this._head;
		        const iterator = {
		            [Symbol.iterator]() {
		                return iterator;
		            },
		            next() {
		                if (map._state !== state) {
		                    throw new Error(`LinkedMap got modified during iteration.`);
		                }
		                if (current) {
		                    const result = { value: current.value, done: false };
		                    current = current.next;
		                    return result;
		                }
		                else {
		                    return { value: undefined, done: true };
		                }
		            }
		        };
		        return iterator;
		    }
		    entries() {
		        const map = this;
		        const state = this._state;
		        let current = this._head;
		        const iterator = {
		            [Symbol.iterator]() {
		                return iterator;
		            },
		            next() {
		                if (map._state !== state) {
		                    throw new Error(`LinkedMap got modified during iteration.`);
		                }
		                if (current) {
		                    const result = { value: [current.key, current.value], done: false };
		                    current = current.next;
		                    return result;
		                }
		                else {
		                    return { value: undefined, done: true };
		                }
		            }
		        };
		        return iterator;
		    }
		    [Symbol.iterator]() {
		        return this.entries();
		    }
		    trimOld(newSize) {
		        if (newSize >= this.size) {
		            return;
		        }
		        if (newSize === 0) {
		            this.clear();
		            return;
		        }
		        let current = this._head;
		        let currentSize = this.size;
		        while (current && currentSize > newSize) {
		            this._map.delete(current.key);
		            current = current.next;
		            currentSize--;
		        }
		        this._head = current;
		        this._size = currentSize;
		        if (current) {
		            current.previous = undefined;
		        }
		        this._state++;
		    }
		    addItemFirst(item) {
		        // First time Insert
		        if (!this._head && !this._tail) {
		            this._tail = item;
		        }
		        else if (!this._head) {
		            throw new Error('Invalid list');
		        }
		        else {
		            item.next = this._head;
		            this._head.previous = item;
		        }
		        this._head = item;
		        this._state++;
		    }
		    addItemLast(item) {
		        // First time Insert
		        if (!this._head && !this._tail) {
		            this._head = item;
		        }
		        else if (!this._tail) {
		            throw new Error('Invalid list');
		        }
		        else {
		            item.previous = this._tail;
		            this._tail.next = item;
		        }
		        this._tail = item;
		        this._state++;
		    }
		    removeItem(item) {
		        if (item === this._head && item === this._tail) {
		            this._head = undefined;
		            this._tail = undefined;
		        }
		        else if (item === this._head) {
		            // This can only happend if size === 1 which is handle
		            // by the case above.
		            if (!item.next) {
		                throw new Error('Invalid list');
		            }
		            item.next.previous = undefined;
		            this._head = item.next;
		        }
		        else if (item === this._tail) {
		            // This can only happend if size === 1 which is handle
		            // by the case above.
		            if (!item.previous) {
		                throw new Error('Invalid list');
		            }
		            item.previous.next = undefined;
		            this._tail = item.previous;
		        }
		        else {
		            const next = item.next;
		            const previous = item.previous;
		            if (!next || !previous) {
		                throw new Error('Invalid list');
		            }
		            next.previous = previous;
		            previous.next = next;
		        }
		        item.next = undefined;
		        item.previous = undefined;
		        this._state++;
		    }
		    touch(item, touch) {
		        if (!this._head || !this._tail) {
		            throw new Error('Invalid list');
		        }
		        if ((touch !== Touch.First && touch !== Touch.Last)) {
		            return;
		        }
		        if (touch === Touch.First) {
		            if (item === this._head) {
		                return;
		            }
		            const next = item.next;
		            const previous = item.previous;
		            // Unlink the item
		            if (item === this._tail) {
		                // previous must be defined since item was not head but is tail
		                // So there are more than on item in the map
		                previous.next = undefined;
		                this._tail = previous;
		            }
		            else {
		                // Both next and previous are not undefined since item was neither head nor tail.
		                next.previous = previous;
		                previous.next = next;
		            }
		            // Insert the node at head
		            item.previous = undefined;
		            item.next = this._head;
		            this._head.previous = item;
		            this._head = item;
		            this._state++;
		        }
		        else if (touch === Touch.Last) {
		            if (item === this._tail) {
		                return;
		            }
		            const next = item.next;
		            const previous = item.previous;
		            // Unlink the item.
		            if (item === this._head) {
		                // next must be defined since item was not tail but is head
		                // So there are more than on item in the map
		                next.previous = undefined;
		                this._head = next;
		            }
		            else {
		                // Both next and previous are not undefined since item was neither head nor tail.
		                next.previous = previous;
		                previous.next = next;
		            }
		            item.next = undefined;
		            item.previous = this._tail;
		            this._tail.next = item;
		            this._tail = item;
		            this._state++;
		        }
		    }
		    toJSON() {
		        const data = [];
		        this.forEach((value, key) => {
		            data.push([key, value]);
		        });
		        return data;
		    }
		    fromJSON(data) {
		        this.clear();
		        for (const [key, value] of data) {
		            this.set(key, value);
		        }
		    }
		}
		exports.LinkedMap = LinkedMap;
		class LRUCache extends LinkedMap {
		    constructor(limit, ratio = 1) {
		        super();
		        this._limit = limit;
		        this._ratio = Math.min(Math.max(0, ratio), 1);
		    }
		    get limit() {
		        return this._limit;
		    }
		    set limit(limit) {
		        this._limit = limit;
		        this.checkTrim();
		    }
		    get ratio() {
		        return this._ratio;
		    }
		    set ratio(ratio) {
		        this._ratio = Math.min(Math.max(0, ratio), 1);
		        this.checkTrim();
		    }
		    get(key, touch = Touch.AsNew) {
		        return super.get(key, touch);
		    }
		    peek(key) {
		        return super.get(key, Touch.None);
		    }
		    set(key, value) {
		        super.set(key, value, Touch.Last);
		        this.checkTrim();
		        return this;
		    }
		    checkTrim() {
		        if (this.size > this._limit) {
		            this.trimOld(Math.round(this._limit * this._ratio));
		        }
		    }
		}
		exports.LRUCache = LRUCache;
		
} (linkedMap));
	return linkedMap;
}

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection$1;
	hasRequiredConnection = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
		const ral_1 = ral;
		const Is = requireIs();
		const messages_1 = requireMessages();
		const linkedMap_1 = requireLinkedMap();
		const events_1 = events;
		const cancellation_1 = requireCancellation();
		var CancelNotification;
		(function (CancelNotification) {
		    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
		})(CancelNotification || (CancelNotification = {}));
		var ProgressNotification;
		(function (ProgressNotification) {
		    ProgressNotification.type = new messages_1.NotificationType('$/progress');
		})(ProgressNotification || (ProgressNotification = {}));
		class ProgressType {
		    constructor() {
		    }
		}
		exports.ProgressType = ProgressType;
		var StarRequestHandler;
		(function (StarRequestHandler) {
		    function is(value) {
		        return Is.func(value);
		    }
		    StarRequestHandler.is = is;
		})(StarRequestHandler || (StarRequestHandler = {}));
		exports.NullLogger = Object.freeze({
		    error: () => { },
		    warn: () => { },
		    info: () => { },
		    log: () => { }
		});
		var Trace;
		(function (Trace) {
		    Trace[Trace["Off"] = 0] = "Off";
		    Trace[Trace["Messages"] = 1] = "Messages";
		    Trace[Trace["Verbose"] = 2] = "Verbose";
		})(Trace = exports.Trace || (exports.Trace = {}));
		(function (Trace) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return Trace.Off;
		        }
		        value = value.toLowerCase();
		        switch (value) {
		            case 'off':
		                return Trace.Off;
		            case 'messages':
		                return Trace.Messages;
		            case 'verbose':
		                return Trace.Verbose;
		            default:
		                return Trace.Off;
		        }
		    }
		    Trace.fromString = fromString;
		    function toString(value) {
		        switch (value) {
		            case Trace.Off:
		                return 'off';
		            case Trace.Messages:
		                return 'messages';
		            case Trace.Verbose:
		                return 'verbose';
		            default:
		                return 'off';
		        }
		    }
		    Trace.toString = toString;
		})(Trace = exports.Trace || (exports.Trace = {}));
		var TraceFormat;
		(function (TraceFormat) {
		    TraceFormat["Text"] = "text";
		    TraceFormat["JSON"] = "json";
		})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
		(function (TraceFormat) {
		    function fromString(value) {
		        value = value.toLowerCase();
		        if (value === 'json') {
		            return TraceFormat.JSON;
		        }
		        else {
		            return TraceFormat.Text;
		        }
		    }
		    TraceFormat.fromString = fromString;
		})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
		var SetTraceNotification;
		(function (SetTraceNotification) {
		    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
		})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
		var LogTraceNotification;
		(function (LogTraceNotification) {
		    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
		})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
		var ConnectionErrors;
		(function (ConnectionErrors) {
		    /**
		     * The connection is closed.
		     */
		    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
		    /**
		     * The connection got disposed.
		     */
		    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
		    /**
		     * The connection is already in listening mode.
		     */
		    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
		})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
		class ConnectionError extends Error {
		    constructor(code, message) {
		        super(message);
		        this.code = code;
		        Object.setPrototypeOf(this, ConnectionError.prototype);
		    }
		}
		exports.ConnectionError = ConnectionError;
		var ConnectionStrategy;
		(function (ConnectionStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.cancelUndispatched);
		    }
		    ConnectionStrategy.is = is;
		})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
		var CancellationReceiverStrategy;
		(function (CancellationReceiverStrategy) {
		    CancellationReceiverStrategy.Message = Object.freeze({
		        createCancellationTokenSource(_) {
		            return new cancellation_1.CancellationTokenSource();
		        }
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.createCancellationTokenSource);
		    }
		    CancellationReceiverStrategy.is = is;
		})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
		var CancellationSenderStrategy;
		(function (CancellationSenderStrategy) {
		    CancellationSenderStrategy.Message = Object.freeze({
		        sendCancellation(conn, id) {
		            conn.sendNotification(CancelNotification.type, { id });
		        },
		        cleanup(_) { }
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
		    }
		    CancellationSenderStrategy.is = is;
		})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
		var CancellationStrategy;
		(function (CancellationStrategy) {
		    CancellationStrategy.Message = Object.freeze({
		        receiver: CancellationReceiverStrategy.Message,
		        sender: CancellationSenderStrategy.Message
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
		    }
		    CancellationStrategy.is = is;
		})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
		(function (ConnectionOptions) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
		    }
		    ConnectionOptions.is = is;
		})(exports.ConnectionOptions || (exports.ConnectionOptions = {}));
		var ConnectionState;
		(function (ConnectionState) {
		    ConnectionState[ConnectionState["New"] = 1] = "New";
		    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
		    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
		    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
		})(ConnectionState || (ConnectionState = {}));
		function createMessageConnection(messageReader, messageWriter, _logger, options) {
		    const logger = _logger !== undefined ? _logger : exports.NullLogger;
		    let sequenceNumber = 0;
		    let notificationSquenceNumber = 0;
		    let unknownResponseSquenceNumber = 0;
		    const version = '2.0';
		    let starRequestHandler = undefined;
		    const requestHandlers = Object.create(null);
		    let starNotificationHandler = undefined;
		    const notificationHandlers = Object.create(null);
		    const progressHandlers = new Map();
		    let timer;
		    let messageQueue = new linkedMap_1.LinkedMap();
		    let responsePromises = Object.create(null);
		    let requestTokens = Object.create(null);
		    let trace = Trace.Off;
		    let traceFormat = TraceFormat.Text;
		    let tracer;
		    let state = ConnectionState.New;
		    const errorEmitter = new events_1.Emitter();
		    const closeEmitter = new events_1.Emitter();
		    const unhandledNotificationEmitter = new events_1.Emitter();
		    const unhandledProgressEmitter = new events_1.Emitter();
		    const disposeEmitter = new events_1.Emitter();
		    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
		    function createRequestQueueKey(id) {
		        if (id === null) {
		            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
		        }
		        return 'req-' + id.toString();
		    }
		    function createResponseQueueKey(id) {
		        if (id === null) {
		            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
		        }
		        else {
		            return 'res-' + id.toString();
		        }
		    }
		    function createNotificationQueueKey() {
		        return 'not-' + (++notificationSquenceNumber).toString();
		    }
		    function addMessageToQueue(queue, message) {
		        if (messages_1.isRequestMessage(message)) {
		            queue.set(createRequestQueueKey(message.id), message);
		        }
		        else if (messages_1.isResponseMessage(message)) {
		            queue.set(createResponseQueueKey(message.id), message);
		        }
		        else {
		            queue.set(createNotificationQueueKey(), message);
		        }
		    }
		    function cancelUndispatched(_message) {
		        return undefined;
		    }
		    function isListening() {
		        return state === ConnectionState.Listening;
		    }
		    function isClosed() {
		        return state === ConnectionState.Closed;
		    }
		    function isDisposed() {
		        return state === ConnectionState.Disposed;
		    }
		    function closeHandler() {
		        if (state === ConnectionState.New || state === ConnectionState.Listening) {
		            state = ConnectionState.Closed;
		            closeEmitter.fire(undefined);
		        }
		        // If the connection is disposed don't sent close events.
		    }
		    function readErrorHandler(error) {
		        errorEmitter.fire([error, undefined, undefined]);
		    }
		    function writeErrorHandler(data) {
		        errorEmitter.fire(data);
		    }
		    messageReader.onClose(closeHandler);
		    messageReader.onError(readErrorHandler);
		    messageWriter.onClose(closeHandler);
		    messageWriter.onError(writeErrorHandler);
		    function triggerMessageQueue() {
		        if (timer || messageQueue.size === 0) {
		            return;
		        }
		        timer = ral_1.default().timer.setImmediate(() => {
		            timer = undefined;
		            processMessageQueue();
		        });
		    }
		    function processMessageQueue() {
		        if (messageQueue.size === 0) {
		            return;
		        }
		        const message = messageQueue.shift();
		        try {
		            if (messages_1.isRequestMessage(message)) {
		                handleRequest(message);
		            }
		            else if (messages_1.isNotificationMessage(message)) {
		                handleNotification(message);
		            }
		            else if (messages_1.isResponseMessage(message)) {
		                handleResponse(message);
		            }
		            else {
		                handleInvalidMessage(message);
		            }
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    }
		    const callback = (message) => {
		        try {
		            // We have received a cancellation message. Check if the message is still in the queue
		            // and cancel it if allowed to do so.
		            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
		                const key = createRequestQueueKey(message.params.id);
		                const toCancel = messageQueue.get(key);
		                if (messages_1.isRequestMessage(toCancel)) {
		                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
		                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
		                    if (response && (response.error !== undefined || response.result !== undefined)) {
		                        messageQueue.delete(key);
		                        response.id = toCancel.id;
		                        traceSendingResponse(response, message.method, Date.now());
		                        messageWriter.write(response);
		                        return;
		                    }
		                }
		            }
		            addMessageToQueue(messageQueue, message);
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    };
		    function handleRequest(requestMessage) {
		        if (isDisposed()) {
		            // we return here silently since we fired an event when the
		            // connection got disposed.
		            return;
		        }
		        function reply(resultOrError, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id
		            };
		            if (resultOrError instanceof messages_1.ResponseError) {
		                message.error = resultOrError.toJson();
		            }
		            else {
		                message.result = resultOrError === undefined ? null : resultOrError;
		            }
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message);
		        }
		        function replyError(error, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                error: error.toJson()
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message);
		        }
		        function replySuccess(result, method, startTime) {
		            // The JSON RPC defines that a response must either have a result or an error
		            // So we can't treat undefined as a valid response result.
		            if (result === undefined) {
		                result = null;
		            }
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                result: result
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message);
		        }
		        traceReceivedRequest(requestMessage);
		        const element = requestHandlers[requestMessage.method];
		        let type;
		        let requestHandler;
		        if (element) {
		            type = element.type;
		            requestHandler = element.handler;
		        }
		        const startTime = Date.now();
		        if (requestHandler || starRequestHandler) {
		            const tokenKey = String(requestMessage.id);
		            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
		            requestTokens[tokenKey] = cancellationSource;
		            try {
		                let handlerResult;
		                if (requestHandler) {
		                    if (requestMessage.params === undefined) {
		                        if (type !== undefined && type.numberOfParams !== 0) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(cancellationSource.token);
		                    }
		                    else if (Array.isArray(requestMessage.params)) {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
		                    }
		                }
		                else if (starRequestHandler) {
		                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
		                }
		                const promise = handlerResult;
		                if (!handlerResult) {
		                    delete requestTokens[tokenKey];
		                    replySuccess(handlerResult, requestMessage.method, startTime);
		                }
		                else if (promise.then) {
		                    promise.then((resultOrError) => {
		                        delete requestTokens[tokenKey];
		                        reply(resultOrError, requestMessage.method, startTime);
		                    }, error => {
		                        delete requestTokens[tokenKey];
		                        if (error instanceof messages_1.ResponseError) {
		                            replyError(error, requestMessage.method, startTime);
		                        }
		                        else if (error && Is.string(error.message)) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                        }
		                        else {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                        }
		                    });
		                }
		                else {
		                    delete requestTokens[tokenKey];
		                    reply(handlerResult, requestMessage.method, startTime);
		                }
		            }
		            catch (error) {
		                delete requestTokens[tokenKey];
		                if (error instanceof messages_1.ResponseError) {
		                    reply(error, requestMessage.method, startTime);
		                }
		                else if (error && Is.string(error.message)) {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                }
		                else {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                }
		            }
		        }
		        else {
		            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
		        }
		    }
		    function handleResponse(responseMessage) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        if (responseMessage.id === null) {
		            if (responseMessage.error) {
		                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
		            }
		            else {
		                logger.error(`Received response message without id. No further error information provided.`);
		            }
		        }
		        else {
		            const key = String(responseMessage.id);
		            const responsePromise = responsePromises[key];
		            traceReceivedResponse(responseMessage, responsePromise);
		            if (responsePromise) {
		                delete responsePromises[key];
		                try {
		                    if (responseMessage.error) {
		                        const error = responseMessage.error;
		                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
		                    }
		                    else if (responseMessage.result !== undefined) {
		                        responsePromise.resolve(responseMessage.result);
		                    }
		                    else {
		                        throw new Error('Should never happen.');
		                    }
		                }
		                catch (error) {
		                    if (error.message) {
		                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
		                    }
		                    else {
		                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
		                    }
		                }
		            }
		        }
		    }
		    function handleNotification(message) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        let type = undefined;
		        let notificationHandler;
		        if (message.method === CancelNotification.type.method) {
		            notificationHandler = (params) => {
		                const id = params.id;
		                const source = requestTokens[String(id)];
		                if (source) {
		                    source.cancel();
		                }
		            };
		        }
		        else {
		            const element = notificationHandlers[message.method];
		            if (element) {
		                notificationHandler = element.handler;
		                type = element.type;
		            }
		        }
		        if (notificationHandler || starNotificationHandler) {
		            try {
		                traceReceivedNotification(message);
		                if (notificationHandler) {
		                    if (message.params === undefined) {
		                        if (type !== undefined) {
		                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
		                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
		                            }
		                        }
		                        notificationHandler();
		                    }
		                    else if (Array.isArray(message.params)) {
		                        if (type !== undefined) {
		                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
		                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
		                            }
		                            if (type.numberOfParams !== message.params.length) {
		                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
		                            }
		                        }
		                        notificationHandler(...message.params);
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
		                        }
		                        notificationHandler(message.params);
		                    }
		                }
		                else if (starNotificationHandler) {
		                    starNotificationHandler(message.method, message.params);
		                }
		            }
		            catch (error) {
		                if (error.message) {
		                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
		                }
		                else {
		                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
		                }
		            }
		        }
		        else {
		            unhandledNotificationEmitter.fire(message);
		        }
		    }
		    function handleInvalidMessage(message) {
		        if (!message) {
		            logger.error('Received empty message.');
		            return;
		        }
		        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
		        // Test whether we find an id to reject the promise
		        const responseMessage = message;
		        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
		            const key = String(responseMessage.id);
		            const responseHandler = responsePromises[key];
		            if (responseHandler) {
		                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
		            }
		        }
		    }
		    function traceSendingRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose && message.params) {
		                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
		            }
		            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('send-request', message);
		        }
		    }
		    function traceSendingNotification(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose) {
		                if (message.params) {
		                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Sending notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('send-notification', message);
		        }
		    }
		    function traceSendingResponse(message, method, startTime) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
		        }
		        else {
		            logLSPMessage('send-response', message);
		        }
		    }
		    function traceReceivedRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose && message.params) {
		                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
		            }
		            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('receive-request', message);
		        }
		    }
		    function traceReceivedNotification(message) {
		        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose) {
		                if (message.params) {
		                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Received notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('receive-notification', message);
		        }
		    }
		    function traceReceivedResponse(message, responsePromise) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            if (responsePromise) {
		                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
		                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
		            }
		            else {
		                tracer.log(`Received response ${message.id} without active response promise.`, data);
		            }
		        }
		        else {
		            logLSPMessage('receive-response', message);
		        }
		    }
		    function logLSPMessage(type, message) {
		        if (!tracer || trace === Trace.Off) {
		            return;
		        }
		        const lspMessage = {
		            isLSPMessage: true,
		            type,
		            message,
		            timestamp: Date.now()
		        };
		        tracer.log(lspMessage);
		    }
		    function throwIfClosedOrDisposed() {
		        if (isClosed()) {
		            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
		        }
		        if (isDisposed()) {
		            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
		        }
		    }
		    function throwIfListening() {
		        if (isListening()) {
		            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
		        }
		    }
		    function throwIfNotListening() {
		        if (!isListening()) {
		            throw new Error('Call listen() first.');
		        }
		    }
		    function undefinedToNull(param) {
		        if (param === undefined) {
		            return null;
		        }
		        else {
		            return param;
		        }
		    }
		    function nullToUndefined(param) {
		        if (param === null) {
		            return undefined;
		        }
		        else {
		            return param;
		        }
		    }
		    function isNamedParam(param) {
		        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
		    }
		    function computeSingleParam(parameterStructures, param) {
		        switch (parameterStructures) {
		            case messages_1.ParameterStructures.auto:
		                if (isNamedParam(param)) {
		                    return nullToUndefined(param);
		                }
		                else {
		                    return [undefinedToNull(param)];
		                }
		            case messages_1.ParameterStructures.byName:
		                if (!isNamedParam(param)) {
		                    throw new Error(`Recevied parameters by name but param is not an object literal.`);
		                }
		                return nullToUndefined(param);
		            case messages_1.ParameterStructures.byPosition:
		                return [undefinedToNull(param)];
		            default:
		                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
		        }
		    }
		    function computeMessageParams(type, params) {
		        let result;
		        const numberOfParams = type.numberOfParams;
		        switch (numberOfParams) {
		            case 0:
		                result = undefined;
		                break;
		            case 1:
		                result = computeSingleParam(type.parameterStructures, params[0]);
		                break;
		            default:
		                result = [];
		                for (let i = 0; i < params.length && i < numberOfParams; i++) {
		                    result.push(undefinedToNull(params[i]));
		                }
		                if (params.length < numberOfParams) {
		                    for (let i = params.length; i < numberOfParams; i++) {
		                        result.push(null);
		                    }
		                }
		                break;
		        }
		        return result;
		    }
		    const connection = {
		        sendNotification: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            let method;
		            let messageParams;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		            }
		            const notificationMessage = {
		                jsonrpc: version,
		                method: method,
		                params: messageParams
		            };
		            traceSendingNotification(notificationMessage);
		            messageWriter.write(notificationMessage);
		        },
		        onNotification: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method;
		            if (Is.func(type)) {
		                starNotificationHandler = type;
		            }
		            else if (handler) {
		                if (Is.string(type)) {
		                    method = type;
		                    notificationHandlers[type] = { type: undefined, handler };
		                }
		                else {
		                    method = type.method;
		                    notificationHandlers[type.method] = { type, handler };
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method !== undefined) {
		                        delete notificationHandlers[method];
		                    }
		                    else {
		                        starNotificationHandler = undefined;
		                    }
		                }
		            };
		        },
		        onProgress: (_type, token, handler) => {
		            if (progressHandlers.has(token)) {
		                throw new Error(`Progress handler for token ${token} already registered`);
		            }
		            progressHandlers.set(token, handler);
		            return {
		                dispose: () => {
		                    progressHandlers.delete(token);
		                }
		            };
		        },
		        sendProgress: (_type, token, value) => {
		            connection.sendNotification(ProgressNotification.type, { token, value });
		        },
		        onUnhandledProgress: unhandledProgressEmitter.event,
		        sendRequest: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            throwIfNotListening();
		            let method;
		            let messageParams;
		            let token = undefined;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                const last = args[args.length - 1];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                if (cancellation_1.CancellationToken.is(last)) {
		                    paramEnd = paramEnd - 1;
		                    token = last;
		                }
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		                const numberOfParams = type.numberOfParams;
		                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
		            }
		            const id = sequenceNumber++;
		            let disposable;
		            if (token) {
		                disposable = token.onCancellationRequested(() => {
		                    cancellationStrategy.sender.sendCancellation(connection, id);
		                });
		            }
		            const result = new Promise((resolve, reject) => {
		                const requestMessage = {
		                    jsonrpc: version,
		                    id: id,
		                    method: method,
		                    params: messageParams
		                };
		                const resolveWithCleanup = (r) => {
		                    resolve(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
		                };
		                const rejectWithCleanup = (r) => {
		                    reject(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
		                };
		                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
		                traceSendingRequest(requestMessage);
		                try {
		                    messageWriter.write(requestMessage);
		                }
		                catch (e) {
		                    // Writing the message failed. So we need to reject the promise.
		                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
		                    responsePromise = null;
		                }
		                if (responsePromise) {
		                    responsePromises[String(id)] = responsePromise;
		                }
		            });
		            return result;
		        },
		        onRequest: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method = null;
		            if (StarRequestHandler.is(type)) {
		                method = undefined;
		                starRequestHandler = type;
		            }
		            else if (Is.string(type)) {
		                method = null;
		                if (handler !== undefined) {
		                    method = type;
		                    requestHandlers[type] = { handler: handler, type: undefined };
		                }
		            }
		            else {
		                if (handler !== undefined) {
		                    method = type.method;
		                    requestHandlers[type.method] = { type, handler };
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method === null) {
		                        return;
		                    }
		                    if (method !== undefined) {
		                        delete requestHandlers[method];
		                    }
		                    else {
		                        starRequestHandler = undefined;
		                    }
		                }
		            };
		        },
		        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
		            let _sendNotification = false;
		            let _traceFormat = TraceFormat.Text;
		            if (sendNotificationOrTraceOptions !== undefined) {
		                if (Is.boolean(sendNotificationOrTraceOptions)) {
		                    _sendNotification = sendNotificationOrTraceOptions;
		                }
		                else {
		                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
		                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
		                }
		            }
		            trace = _value;
		            traceFormat = _traceFormat;
		            if (trace === Trace.Off) {
		                tracer = undefined;
		            }
		            else {
		                tracer = _tracer;
		            }
		            if (_sendNotification && !isClosed() && !isDisposed()) {
		                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
		            }
		        },
		        onError: errorEmitter.event,
		        onClose: closeEmitter.event,
		        onUnhandledNotification: unhandledNotificationEmitter.event,
		        onDispose: disposeEmitter.event,
		        end: () => {
		            messageWriter.end();
		        },
		        dispose: () => {
		            if (isDisposed()) {
		                return;
		            }
		            state = ConnectionState.Disposed;
		            disposeEmitter.fire(undefined);
		            const error = new Error('Connection got disposed.');
		            Object.keys(responsePromises).forEach((key) => {
		                responsePromises[key].reject(error);
		            });
		            responsePromises = Object.create(null);
		            requestTokens = Object.create(null);
		            messageQueue = new linkedMap_1.LinkedMap();
		            // Test for backwards compatibility
		            if (Is.func(messageWriter.dispose)) {
		                messageWriter.dispose();
		            }
		            if (Is.func(messageReader.dispose)) {
		                messageReader.dispose();
		            }
		        },
		        listen: () => {
		            throwIfClosedOrDisposed();
		            throwIfListening();
		            state = ConnectionState.Listening;
		            messageReader.listen(callback);
		        },
		        inspect: () => {
		            // eslint-disable-next-line no-console
		            ral_1.default().console.log('inspect');
		        }
		    };
		    connection.onNotification(LogTraceNotification.type, (params) => {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
		    });
		    connection.onNotification(ProgressNotification.type, (params) => {
		        const handler = progressHandlers.get(params.token);
		        if (handler) {
		            handler(params.value);
		        }
		        else {
		            unhandledProgressEmitter.fire(params);
		        }
		    });
		    return connection;
		}
		exports.createMessageConnection = createMessageConnection;
		
} (connection$1));
	return connection$1;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api$1;
	hasRequiredApi = 1;
	(function (exports) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		/// <reference path="../../typings/thenable.d.ts" />
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
		exports.CancellationStrategy = void 0;
		const messages_1 = requireMessages();
		Object.defineProperty(exports, "RequestType", { enumerable: true, get: function () { return messages_1.RequestType; } });
		Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function () { return messages_1.RequestType0; } });
		Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function () { return messages_1.RequestType1; } });
		Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function () { return messages_1.RequestType2; } });
		Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function () { return messages_1.RequestType3; } });
		Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function () { return messages_1.RequestType4; } });
		Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function () { return messages_1.RequestType5; } });
		Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function () { return messages_1.RequestType6; } });
		Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function () { return messages_1.RequestType7; } });
		Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function () { return messages_1.RequestType8; } });
		Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function () { return messages_1.RequestType9; } });
		Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function () { return messages_1.ResponseError; } });
		Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });
		Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function () { return messages_1.NotificationType; } });
		Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function () { return messages_1.NotificationType0; } });
		Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function () { return messages_1.NotificationType1; } });
		Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function () { return messages_1.NotificationType2; } });
		Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function () { return messages_1.NotificationType3; } });
		Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function () { return messages_1.NotificationType4; } });
		Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function () { return messages_1.NotificationType5; } });
		Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function () { return messages_1.NotificationType6; } });
		Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function () { return messages_1.NotificationType7; } });
		Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function () { return messages_1.NotificationType8; } });
		Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function () { return messages_1.NotificationType9; } });
		Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });
		const disposable_1 = disposable;
		Object.defineProperty(exports, "Disposable", { enumerable: true, get: function () { return disposable_1.Disposable; } });
		const events_1 = events;
		Object.defineProperty(exports, "Event", { enumerable: true, get: function () { return events_1.Event; } });
		Object.defineProperty(exports, "Emitter", { enumerable: true, get: function () { return events_1.Emitter; } });
		const cancellation_1 = requireCancellation();
		Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });
		Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });
		const messageReader_1 = requireMessageReader();
		Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });
		Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });
		Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });
		const messageWriter_1 = requireMessageWriter();
		Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });
		Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });
		Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });
		const connection_1 = requireConnection();
		Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });
		Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });
		Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function () { return connection_1.NullLogger; } });
		Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });
		Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function () { return connection_1.ProgressType; } });
		Object.defineProperty(exports, "Trace", { enumerable: true, get: function () { return connection_1.Trace; } });
		Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function () { return connection_1.TraceFormat; } });
		Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });
		Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });
		Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });
		Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function () { return connection_1.ConnectionError; } });
		Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });
		Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });
		Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });
		const ral_1 = ral;
		exports.RAL = ral_1.default;
		
} (api$1));
	return api$1;
}

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
	const ril_1 = ril;
	// Install the browser runtime abstract.
	ril_1.default.install();
	const api_1 = requireApi();
	__exportStar(requireApi(), exports);
	class BrowserMessageReader extends api_1.AbstractMessageReader {
	    constructor(context) {
	        super();
	        this._onData = new api_1.Emitter();
	        this._messageListener = (event) => {
	            this._onData.fire(event.data);
	        };
	        context.addEventListener('error', (event) => this.fireError(event));
	        context.onmessage = this._messageListener;
	    }
	    listen(callback) {
	        return this._onData.event(callback);
	    }
	}
	exports.BrowserMessageReader = BrowserMessageReader;
	class BrowserMessageWriter extends api_1.AbstractMessageWriter {
	    constructor(context) {
	        super();
	        this.context = context;
	        this.errorCount = 0;
	        context.addEventListener('error', (event) => this.fireError(event));
	    }
	    write(msg) {
	        try {
	            this.context.postMessage(msg);
	            return Promise.resolve();
	        }
	        catch (error) {
	            this.handleError(error, msg);
	            return Promise.reject(error);
	        }
	    }
	    handleError(error, msg) {
	        this.errorCount++;
	        this.fireError(error, msg, this.errorCount);
	    }
	    end() {
	    }
	}
	exports.BrowserMessageWriter = BrowserMessageWriter;
	function createMessageConnection(reader, writer, logger, options) {
	    if (logger === undefined) {
	        logger = api_1.NullLogger;
	    }
	    if (api_1.ConnectionStrategy.is(options)) {
	        options = { connectionStrategy: options };
	    }
	    return api_1.createMessageConnection(reader, writer, logger, options);
	}
	exports.createMessageConnection = createMessageConnection;
	
} (main$1));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

(function (module) {

	module.exports = main$1;
} (browser$1));

var api = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.objectLiteral(candidate) && Is$1.uinteger(candidate.line) && Is$1.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is$1.uinteger(one) && Is$1.uinteger(two) && Is$1.uinteger(three) && Is$1.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Range.is(candidate.range) && (Is$1.string(candidate.uri) || Is$1.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Range.is(candidate.targetRange) && Is$1.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is$1.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is$1.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.numberRange(candidate.red, 0, 1)
            && Is$1.numberRange(candidate.green, 0, 1)
            && Is$1.numberRange(candidate.blue, 0, 1)
            && Is$1.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.string(candidate.label)
            && (Is$1.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is$1.undefined(candidate.additionalTextEdits) || Is$1.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is$1.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is$1.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is$1.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.uinteger(candidate.startLine) && Is$1.uinteger(candidate.startLine)
            && (Is$1.undefined(candidate.startCharacter) || Is$1.uinteger(candidate.startCharacter))
            && (Is$1.undefined(candidate.endCharacter) || Is$1.uinteger(candidate.endCharacter))
            && (Is$1.undefined(candidate.kind) || Is$1.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Location.is(candidate.location) && Is$1.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is$1.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is$1.defined(severity)) {
            result.severity = severity;
        }
        if (Is$1.defined(code)) {
            result.code = code;
        }
        if (Is$1.defined(source)) {
            result.source = source;
        }
        if (Is$1.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is$1.defined(candidate)
            && Range.is(candidate.range)
            && Is$1.string(candidate.message)
            && (Is$1.number(candidate.severity) || Is$1.undefined(candidate.severity))
            && (Is$1.integer(candidate.code) || Is$1.string(candidate.code) || Is$1.undefined(candidate.code))
            && (Is$1.undefined(candidate.codeDescription) || (Is$1.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is$1.string(candidate.source) || Is$1.undefined(candidate.source))
            && (Is$1.undefined(candidate.relatedInformation) || Is$1.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is$1.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.string(candidate.title) && Is$1.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is$1.objectLiteral(candidate)
            && Is$1.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is$1.objectLiteral(candidate) && Is$1.string(candidate.label) &&
            (Is$1.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is$1.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is$1.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is$1.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is$1.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is$1.string(candidate.oldUri) && Is$1.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is$1.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is$1.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is$1.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is$1.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is$1.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is$1.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());
/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.string(candidate.uri) && Is$1.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.string(candidate.uri) && (candidate.version === null || Is$1.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.string(candidate.uri) && Is$1.string(candidate.languageId) && Is$1.integer(candidate.version) && Is$1.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is$1.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is$1.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is$1.string(candidate) || (Is$1.objectLiteral(candidate) && Is$1.string(candidate.language) && Is$1.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is$1.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is$1.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is$1.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is$1.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is$1.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is$1.string(candidate.name) && Is$1.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is$1.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is$1.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is$1.typedArray(candidate.only, Is$1.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is$1.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is$1.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is$1.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is$1.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is$1.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Range.is(candidate.range) && (Is$1.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.uinteger(candidate.tabSize) && Is$1.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Range.is(candidate.range) && (Is$1.undefined(candidate.target) || Is$1.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is$1.defined(candidate) && Is$1.string(candidate.uri) && (Is$1.undefined(candidate.languageId) || Is$1.string(candidate.languageId)) && Is$1.uinteger(candidate.lineCount)
            && Is$1.func(candidate.getText) && Is$1.func(candidate.positionAt) && Is$1.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is$1;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined$1(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined$1;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is$1 || (Is$1 = {}));

var main = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get integer () { return integer; },
    get uinteger () { return uinteger; },
    get Position () { return Position; },
    get Range () { return Range; },
    get Location () { return Location; },
    get LocationLink () { return LocationLink; },
    get Color () { return Color; },
    get ColorInformation () { return ColorInformation; },
    get ColorPresentation () { return ColorPresentation; },
    get FoldingRangeKind () { return FoldingRangeKind; },
    get FoldingRange () { return FoldingRange; },
    get DiagnosticRelatedInformation () { return DiagnosticRelatedInformation; },
    get DiagnosticSeverity () { return DiagnosticSeverity; },
    get DiagnosticTag () { return DiagnosticTag; },
    get CodeDescription () { return CodeDescription; },
    get Diagnostic () { return Diagnostic; },
    get Command () { return Command; },
    get TextEdit () { return TextEdit; },
    get ChangeAnnotation () { return ChangeAnnotation; },
    get ChangeAnnotationIdentifier () { return ChangeAnnotationIdentifier; },
    get AnnotatedTextEdit () { return AnnotatedTextEdit; },
    get TextDocumentEdit () { return TextDocumentEdit; },
    get CreateFile () { return CreateFile; },
    get RenameFile () { return RenameFile; },
    get DeleteFile () { return DeleteFile; },
    get WorkspaceEdit () { return WorkspaceEdit; },
    WorkspaceChange: WorkspaceChange,
    get TextDocumentIdentifier () { return TextDocumentIdentifier; },
    get VersionedTextDocumentIdentifier () { return VersionedTextDocumentIdentifier; },
    get OptionalVersionedTextDocumentIdentifier () { return OptionalVersionedTextDocumentIdentifier; },
    get TextDocumentItem () { return TextDocumentItem; },
    get MarkupKind () { return MarkupKind; },
    get MarkupContent () { return MarkupContent; },
    get CompletionItemKind () { return CompletionItemKind; },
    get InsertTextFormat () { return InsertTextFormat; },
    get CompletionItemTag () { return CompletionItemTag; },
    get InsertReplaceEdit () { return InsertReplaceEdit; },
    get InsertTextMode () { return InsertTextMode; },
    get CompletionItem () { return CompletionItem; },
    get CompletionList () { return CompletionList; },
    get MarkedString () { return MarkedString; },
    get Hover () { return Hover; },
    get ParameterInformation () { return ParameterInformation; },
    get SignatureInformation () { return SignatureInformation; },
    get DocumentHighlightKind () { return DocumentHighlightKind; },
    get DocumentHighlight () { return DocumentHighlight; },
    get SymbolKind () { return SymbolKind; },
    get SymbolTag () { return SymbolTag; },
    get SymbolInformation () { return SymbolInformation; },
    get DocumentSymbol () { return DocumentSymbol; },
    get CodeActionKind () { return CodeActionKind; },
    get CodeActionContext () { return CodeActionContext; },
    get CodeAction () { return CodeAction; },
    get CodeLens () { return CodeLens; },
    get FormattingOptions () { return FormattingOptions; },
    get DocumentLink () { return DocumentLink; },
    get SelectionRange () { return SelectionRange; },
    EOL: EOL,
    get TextDocument () { return TextDocument; }
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(main);

var messages = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(messages, "__esModule", { value: true });
messages.ProtocolNotificationType = messages.ProtocolNotificationType0 = messages.ProtocolRequestType = messages.ProtocolRequestType0 = messages.RegistrationType = void 0;
const vscode_jsonrpc_1$1 = main$1;
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
messages.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1$1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
messages.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1$1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1$1.ParameterStructures.byName);
    }
}
messages.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1$1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
messages.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1$1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1$1.ParameterStructures.byName);
    }
}
messages.ProtocolNotificationType = ProtocolNotificationType;

var protocol = {};

var is$1 = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(is$1, "__esModule", { value: true });
is$1.objectLiteral = is$1.typedArray = is$1.stringArray = is$1.array = is$1.func = is$1.error = is$1.number = is$1.string = is$1.boolean = void 0;
function boolean$1(value) {
    return value === true || value === false;
}
is$1.boolean = boolean$1;
function string$1(value) {
    return typeof value === 'string' || value instanceof String;
}
is$1.string = string$1;
function number$1(value) {
    return typeof value === 'number' || value instanceof Number;
}
is$1.number = number$1;
function error$k(value) {
    return value instanceof Error;
}
is$1.error = error$k;
function func$1(value) {
    return typeof value === 'function';
}
is$1.func = func$1;
function array$1(value) {
    return Array.isArray(value);
}
is$1.array = array$1;
function stringArray$1(value) {
    return array$1(value) && value.every(elem => string$1(elem));
}
is$1.stringArray = stringArray$1;
function typedArray$1(value, check) {
    return Array.isArray(value) && value.every(check);
}
is$1.typedArray = typedArray$1;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
is$1.objectLiteral = objectLiteral;

var protocol_implementation = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ImplementationRequest = void 0;
	const messages_1 = messages;
	(function (ImplementationRequest) {
	    ImplementationRequest.method = 'textDocument/implementation';
	    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
	})(exports.ImplementationRequest || (exports.ImplementationRequest = {}));
	
} (protocol_implementation));

var protocol_typeDefinition = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TypeDefinitionRequest = void 0;
	const messages_1 = messages;
	(function (TypeDefinitionRequest) {
	    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
	    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
	})(exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
	
} (protocol_typeDefinition));

var protocol_workspaceFolders = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
	const messages_1 = messages;
	(function (WorkspaceFoldersRequest) {
	    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
	})(exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
	(function (DidChangeWorkspaceFoldersNotification) {
	    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
	})(exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
	
} (protocol_workspaceFolders));

var protocol_configuration = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ConfigurationRequest = void 0;
	const messages_1 = messages;
	(function (ConfigurationRequest) {
	    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
	})(exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
	
} (protocol_configuration));

var protocol_colorProvider = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
	const messages_1 = messages;
	(function (DocumentColorRequest) {
	    DocumentColorRequest.method = 'textDocument/documentColor';
	    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
	})(exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
	(function (ColorPresentationRequest) {
	    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
	})(exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
	
} (protocol_colorProvider));

var protocol_foldingRange = {};

(function (exports) {
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
	const messages_1 = messages;
	(function (FoldingRangeKind) {
	    /**
	     * Folding range for a comment
	     */
	    FoldingRangeKind["Comment"] = "comment";
	    /**
	     * Folding range for a imports or includes
	     */
	    FoldingRangeKind["Imports"] = "imports";
	    /**
	     * Folding range for a region (e.g. `#region`)
	     */
	    FoldingRangeKind["Region"] = "region";
	})(exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
	(function (FoldingRangeRequest) {
	    FoldingRangeRequest.method = 'textDocument/foldingRange';
	    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
	})(exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
	
} (protocol_foldingRange));

var protocol_declaration = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DeclarationRequest = void 0;
	const messages_1 = messages;
	(function (DeclarationRequest) {
	    DeclarationRequest.method = 'textDocument/declaration';
	    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
	})(exports.DeclarationRequest || (exports.DeclarationRequest = {}));
	
} (protocol_declaration));

var protocol_selectionRange = {};

(function (exports) {
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SelectionRangeRequest = void 0;
	const messages_1 = messages;
	(function (SelectionRangeRequest) {
	    SelectionRangeRequest.method = 'textDocument/selectionRange';
	    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
	})(exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
	
} (protocol_selectionRange));

var protocol_progress = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
	const vscode_jsonrpc_1 = main$1;
	const messages_1 = messages;
	(function (WorkDoneProgress) {
	    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
	    function is(value) {
	        return value === WorkDoneProgress.type;
	    }
	    WorkDoneProgress.is = is;
	})(exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
	(function (WorkDoneProgressCreateRequest) {
	    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
	})(exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
	(function (WorkDoneProgressCancelNotification) {
	    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
	})(exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
	
} (protocol_progress));

var protocol_callHierarchy = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) TypeFox and others. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
	const messages_1 = messages;
	(function (CallHierarchyPrepareRequest) {
	    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
	    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
	})(exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
	(function (CallHierarchyIncomingCallsRequest) {
	    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
	    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
	})(exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
	(function (CallHierarchyOutgoingCallsRequest) {
	    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
	    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
	})(exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
	
} (protocol_callHierarchy));

var protocol_semanticTokens = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
	const messages_1 = messages;
	(function (SemanticTokenTypes) {
	    SemanticTokenTypes["namespace"] = "namespace";
	    /**
	     * Represents a generic type. Acts as a fallback for types which can't be mapped to
	     * a specific type like class or enum.
	     */
	    SemanticTokenTypes["type"] = "type";
	    SemanticTokenTypes["class"] = "class";
	    SemanticTokenTypes["enum"] = "enum";
	    SemanticTokenTypes["interface"] = "interface";
	    SemanticTokenTypes["struct"] = "struct";
	    SemanticTokenTypes["typeParameter"] = "typeParameter";
	    SemanticTokenTypes["parameter"] = "parameter";
	    SemanticTokenTypes["variable"] = "variable";
	    SemanticTokenTypes["property"] = "property";
	    SemanticTokenTypes["enumMember"] = "enumMember";
	    SemanticTokenTypes["event"] = "event";
	    SemanticTokenTypes["function"] = "function";
	    SemanticTokenTypes["method"] = "method";
	    SemanticTokenTypes["macro"] = "macro";
	    SemanticTokenTypes["keyword"] = "keyword";
	    SemanticTokenTypes["modifier"] = "modifier";
	    SemanticTokenTypes["comment"] = "comment";
	    SemanticTokenTypes["string"] = "string";
	    SemanticTokenTypes["number"] = "number";
	    SemanticTokenTypes["regexp"] = "regexp";
	    SemanticTokenTypes["operator"] = "operator";
	})(exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
	(function (SemanticTokenModifiers) {
	    SemanticTokenModifiers["declaration"] = "declaration";
	    SemanticTokenModifiers["definition"] = "definition";
	    SemanticTokenModifiers["readonly"] = "readonly";
	    SemanticTokenModifiers["static"] = "static";
	    SemanticTokenModifiers["deprecated"] = "deprecated";
	    SemanticTokenModifiers["abstract"] = "abstract";
	    SemanticTokenModifiers["async"] = "async";
	    SemanticTokenModifiers["modification"] = "modification";
	    SemanticTokenModifiers["documentation"] = "documentation";
	    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
	})(exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
	(function (SemanticTokens) {
	    function is(value) {
	        const candidate = value;
	        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
	            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
	    }
	    SemanticTokens.is = is;
	})(exports.SemanticTokens || (exports.SemanticTokens = {}));
	(function (TokenFormat) {
	    TokenFormat.Relative = 'relative';
	})(exports.TokenFormat || (exports.TokenFormat = {}));
	(function (SemanticTokensRegistrationType) {
	    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
	    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
	})(exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
	(function (SemanticTokensRequest) {
	    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
	    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
	})(exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
	(function (SemanticTokensDeltaRequest) {
	    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
	    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
	})(exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
	(function (SemanticTokensRangeRequest) {
	    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
	    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
	})(exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
	(function (SemanticTokensRefreshRequest) {
	    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
	    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
	})(exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
	
} (protocol_semanticTokens));

var protocol_showDocument = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ShowDocumentRequest = void 0;
	const messages_1 = messages;
	(function (ShowDocumentRequest) {
	    ShowDocumentRequest.method = 'window/showDocument';
	    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
	})(exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
	
} (protocol_showDocument));

var protocol_linkedEditingRange = {};

(function (exports) {
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LinkedEditingRangeRequest = void 0;
	const messages_1 = messages;
	(function (LinkedEditingRangeRequest) {
	    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
	    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
	})(exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
	
} (protocol_linkedEditingRange));

var protocol_fileOperations = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
	const messages_1 = messages;
	(function (FileOperationPatternKind) {
	    /**
	     * The pattern matches a file only.
	     */
	    FileOperationPatternKind.file = 'file';
	    /**
	     * The pattern matches a folder only.
	     */
	    FileOperationPatternKind.folder = 'folder';
	})(exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
	(function (WillCreateFilesRequest) {
	    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
	    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
	})(exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
	(function (DidCreateFilesNotification) {
	    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
	    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
	})(exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
	(function (WillRenameFilesRequest) {
	    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
	    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
	})(exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
	(function (DidRenameFilesNotification) {
	    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
	    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
	})(exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
	(function (DidDeleteFilesNotification) {
	    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
	    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
	})(exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
	(function (WillDeleteFilesRequest) {
	    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
	    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
	})(exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
	
} (protocol_fileOperations));

var protocol_moniker = {};

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
	const messages_1 = messages;
	(function (UniquenessLevel) {
	    /**
	     * The moniker is only unique inside a document
	     */
	    UniquenessLevel["document"] = "document";
	    /**
	     * The moniker is unique inside a project for which a dump got created
	     */
	    UniquenessLevel["project"] = "project";
	    /**
	     * The moniker is unique inside the group to which a project belongs
	     */
	    UniquenessLevel["group"] = "group";
	    /**
	     * The moniker is unique inside the moniker scheme.
	     */
	    UniquenessLevel["scheme"] = "scheme";
	    /**
	     * The moniker is globally unique
	     */
	    UniquenessLevel["global"] = "global";
	})(exports.UniquenessLevel || (exports.UniquenessLevel = {}));
	(function (MonikerKind) {
	    /**
	     * The moniker represent a symbol that is imported into a project
	     */
	    MonikerKind["import"] = "import";
	    /**
	     * The moniker represents a symbol that is exported from a project
	     */
	    MonikerKind["export"] = "export";
	    /**
	     * The moniker represents a symbol that is local to a project (e.g. a local
	     * variable of a function, a class not visible outside the project, ...)
	     */
	    MonikerKind["local"] = "local";
	})(exports.MonikerKind || (exports.MonikerKind = {}));
	(function (MonikerRequest) {
	    MonikerRequest.method = 'textDocument/moniker';
	    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
	})(exports.MonikerRequest || (exports.MonikerRequest = {}));
	
} (protocol_moniker));

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
	exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
	const Is = is$1;
	const messages_1 = messages;
	const protocol_implementation_1 = protocol_implementation;
	Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });
	const protocol_typeDefinition_1 = protocol_typeDefinition;
	Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });
	const protocol_workspaceFolders_1 = protocol_workspaceFolders;
	Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } });
	Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } });
	const protocol_configuration_1 = protocol_configuration;
	Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });
	const protocol_colorProvider_1 = protocol_colorProvider;
	Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });
	Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });
	const protocol_foldingRange_1 = protocol_foldingRange;
	Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });
	const protocol_declaration_1 = protocol_declaration;
	Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });
	const protocol_selectionRange_1 = protocol_selectionRange;
	Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });
	const protocol_progress_1 = protocol_progress;
	Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });
	Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });
	Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });
	const protocol_callHierarchy_1 = protocol_callHierarchy;
	Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });
	Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });
	Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });
	const protocol_semanticTokens_1 = protocol_semanticTokens;
	Object.defineProperty(exports, "SemanticTokenTypes", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenTypes; } });
	Object.defineProperty(exports, "SemanticTokenModifiers", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenModifiers; } });
	Object.defineProperty(exports, "SemanticTokens", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokens; } });
	Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });
	Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });
	Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });
	Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });
	Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });
	Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });
	const protocol_showDocument_1 = protocol_showDocument;
	Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });
	const protocol_linkedEditingRange_1 = protocol_linkedEditingRange;
	Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });
	const protocol_fileOperations_1 = protocol_fileOperations;
	Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });
	Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });
	Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });
	Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });
	Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });
	Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });
	Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });
	const protocol_moniker_1 = protocol_moniker;
	Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });
	Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });
	Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });
	/**
	 * The DocumentFilter namespace provides helper functions to work with
	 * [DocumentFilter](#DocumentFilter) literals.
	 */
	var DocumentFilter;
	(function (DocumentFilter) {
	    function is(value) {
	        const candidate = value;
	        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
	    }
	    DocumentFilter.is = is;
	})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
	/**
	 * The DocumentSelector namespace provides helper functions to work with
	 * [DocumentSelector](#DocumentSelector)s.
	 */
	var DocumentSelector;
	(function (DocumentSelector) {
	    function is(value) {
	        if (!Array.isArray(value)) {
	            return false;
	        }
	        for (let elem of value) {
	            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    DocumentSelector.is = is;
	})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
	(function (RegistrationRequest) {
	    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
	})(exports.RegistrationRequest || (exports.RegistrationRequest = {}));
	(function (UnregistrationRequest) {
	    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
	})(exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
	(function (ResourceOperationKind) {
	    /**
	     * Supports creating new files and folders.
	     */
	    ResourceOperationKind.Create = 'create';
	    /**
	     * Supports renaming existing files and folders.
	     */
	    ResourceOperationKind.Rename = 'rename';
	    /**
	     * Supports deleting existing files and folders.
	     */
	    ResourceOperationKind.Delete = 'delete';
	})(exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
	(function (FailureHandlingKind) {
	    /**
	     * Applying the workspace change is simply aborted if one of the changes provided
	     * fails. All operations executed before the failing operation stay executed.
	     */
	    FailureHandlingKind.Abort = 'abort';
	    /**
	     * All operations are executed transactional. That means they either all
	     * succeed or no changes at all are applied to the workspace.
	     */
	    FailureHandlingKind.Transactional = 'transactional';
	    /**
	     * If the workspace edit contains only textual file changes they are executed transactional.
	     * If resource changes (create, rename or delete file) are part of the change the failure
	     * handling strategy is abort.
	     */
	    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
	    /**
	     * The client tries to undo the operations already executed. But there is no
	     * guarantee that this is succeeding.
	     */
	    FailureHandlingKind.Undo = 'undo';
	})(exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
	(function (StaticRegistrationOptions) {
	    function hasId(value) {
	        const candidate = value;
	        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
	    }
	    StaticRegistrationOptions.hasId = hasId;
	})(exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
	(function (TextDocumentRegistrationOptions) {
	    function is(value) {
	        const candidate = value;
	        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
	    }
	    TextDocumentRegistrationOptions.is = is;
	})(exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
	(function (WorkDoneProgressOptions) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
	    }
	    WorkDoneProgressOptions.is = is;
	    function hasWorkDoneProgress(value) {
	        const candidate = value;
	        return candidate && Is.boolean(candidate.workDoneProgress);
	    }
	    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
	})(exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
	(function (InitializeRequest) {
	    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
	})(exports.InitializeRequest || (exports.InitializeRequest = {}));
	(function (InitializeError) {
	    /**
	     * If the protocol version provided by the client can't be handled by the server.
	     * @deprecated This initialize error got replaced by client capabilities. There is
	     * no version handshake in version 3.0x
	     */
	    InitializeError.unknownProtocolVersion = 1;
	})(exports.InitializeError || (exports.InitializeError = {}));
	(function (InitializedNotification) {
	    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
	})(exports.InitializedNotification || (exports.InitializedNotification = {}));
	(function (ShutdownRequest) {
	    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
	})(exports.ShutdownRequest || (exports.ShutdownRequest = {}));
	(function (ExitNotification) {
	    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
	})(exports.ExitNotification || (exports.ExitNotification = {}));
	(function (DidChangeConfigurationNotification) {
	    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
	})(exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
	(function (MessageType) {
	    /**
	     * An error message.
	     */
	    MessageType.Error = 1;
	    /**
	     * A warning message.
	     */
	    MessageType.Warning = 2;
	    /**
	     * An information message.
	     */
	    MessageType.Info = 3;
	    /**
	     * A log message.
	     */
	    MessageType.Log = 4;
	})(exports.MessageType || (exports.MessageType = {}));
	(function (ShowMessageNotification) {
	    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
	})(exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
	(function (ShowMessageRequest) {
	    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
	})(exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
	(function (LogMessageNotification) {
	    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
	})(exports.LogMessageNotification || (exports.LogMessageNotification = {}));
	(function (TelemetryEventNotification) {
	    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
	})(exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
	(function (TextDocumentSyncKind) {
	    /**
	     * Documents should not be synced at all.
	     */
	    TextDocumentSyncKind.None = 0;
	    /**
	     * Documents are synced by always sending the full content
	     * of the document.
	     */
	    TextDocumentSyncKind.Full = 1;
	    /**
	     * Documents are synced by sending the full content on open.
	     * After that only incremental updates to the document are
	     * send.
	     */
	    TextDocumentSyncKind.Incremental = 2;
	})(exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
	(function (DidOpenTextDocumentNotification) {
	    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
	    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
	})(exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
	(function (TextDocumentContentChangeEvent) {
	    /**
	     * Checks whether the information describes a delta event.
	     */
	    function isIncremental(event) {
	        let candidate = event;
	        return candidate !== undefined && candidate !== null &&
	            typeof candidate.text === 'string' && candidate.range !== undefined &&
	            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
	    }
	    TextDocumentContentChangeEvent.isIncremental = isIncremental;
	    /**
	     * Checks whether the information describes a full replacement event.
	     */
	    function isFull(event) {
	        let candidate = event;
	        return candidate !== undefined && candidate !== null &&
	            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
	    }
	    TextDocumentContentChangeEvent.isFull = isFull;
	})(exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
	(function (DidChangeTextDocumentNotification) {
	    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
	    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
	})(exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
	(function (DidCloseTextDocumentNotification) {
	    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
	    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
	})(exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
	(function (DidSaveTextDocumentNotification) {
	    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
	    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
	})(exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
	(function (TextDocumentSaveReason) {
	    /**
	     * Manually triggered, e.g. by the user pressing save, by starting debugging,
	     * or by an API call.
	     */
	    TextDocumentSaveReason.Manual = 1;
	    /**
	     * Automatic after a delay.
	     */
	    TextDocumentSaveReason.AfterDelay = 2;
	    /**
	     * When the editor lost focus.
	     */
	    TextDocumentSaveReason.FocusOut = 3;
	})(exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
	(function (WillSaveTextDocumentNotification) {
	    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
	    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
	})(exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
	(function (WillSaveTextDocumentWaitUntilRequest) {
	    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
	    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
	})(exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
	(function (DidChangeWatchedFilesNotification) {
	    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
	})(exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
	(function (FileChangeType) {
	    /**
	     * The file got created.
	     */
	    FileChangeType.Created = 1;
	    /**
	     * The file got changed.
	     */
	    FileChangeType.Changed = 2;
	    /**
	     * The file got deleted.
	     */
	    FileChangeType.Deleted = 3;
	})(exports.FileChangeType || (exports.FileChangeType = {}));
	(function (WatchKind) {
	    /**
	     * Interested in create events.
	     */
	    WatchKind.Create = 1;
	    /**
	     * Interested in change events
	     */
	    WatchKind.Change = 2;
	    /**
	     * Interested in delete events
	     */
	    WatchKind.Delete = 4;
	})(exports.WatchKind || (exports.WatchKind = {}));
	(function (PublishDiagnosticsNotification) {
	    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
	})(exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
	(function (CompletionTriggerKind) {
	    /**
	     * Completion was triggered by typing an identifier (24x7 code
	     * complete), manual invocation (e.g Ctrl+Space) or via API.
	     */
	    CompletionTriggerKind.Invoked = 1;
	    /**
	     * Completion was triggered by a trigger character specified by
	     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
	     */
	    CompletionTriggerKind.TriggerCharacter = 2;
	    /**
	     * Completion was re-triggered as current completion list is incomplete
	     */
	    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
	})(exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
	(function (CompletionRequest) {
	    CompletionRequest.method = 'textDocument/completion';
	    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
	})(exports.CompletionRequest || (exports.CompletionRequest = {}));
	(function (CompletionResolveRequest) {
	    CompletionResolveRequest.method = 'completionItem/resolve';
	    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
	})(exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
	(function (HoverRequest) {
	    HoverRequest.method = 'textDocument/hover';
	    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
	})(exports.HoverRequest || (exports.HoverRequest = {}));
	(function (SignatureHelpTriggerKind) {
	    /**
	     * Signature help was invoked manually by the user or by a command.
	     */
	    SignatureHelpTriggerKind.Invoked = 1;
	    /**
	     * Signature help was triggered by a trigger character.
	     */
	    SignatureHelpTriggerKind.TriggerCharacter = 2;
	    /**
	     * Signature help was triggered by the cursor moving or by the document content changing.
	     */
	    SignatureHelpTriggerKind.ContentChange = 3;
	})(exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
	(function (SignatureHelpRequest) {
	    SignatureHelpRequest.method = 'textDocument/signatureHelp';
	    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
	})(exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
	(function (DefinitionRequest) {
	    DefinitionRequest.method = 'textDocument/definition';
	    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
	})(exports.DefinitionRequest || (exports.DefinitionRequest = {}));
	(function (ReferencesRequest) {
	    ReferencesRequest.method = 'textDocument/references';
	    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
	})(exports.ReferencesRequest || (exports.ReferencesRequest = {}));
	(function (DocumentHighlightRequest) {
	    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
	    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
	})(exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
	(function (DocumentSymbolRequest) {
	    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
	    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
	})(exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
	(function (CodeActionRequest) {
	    CodeActionRequest.method = 'textDocument/codeAction';
	    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
	})(exports.CodeActionRequest || (exports.CodeActionRequest = {}));
	(function (CodeActionResolveRequest) {
	    CodeActionResolveRequest.method = 'codeAction/resolve';
	    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
	})(exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
	(function (WorkspaceSymbolRequest) {
	    WorkspaceSymbolRequest.method = 'workspace/symbol';
	    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
	})(exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
	(function (CodeLensRequest) {
	    CodeLensRequest.method = 'textDocument/codeLens';
	    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
	})(exports.CodeLensRequest || (exports.CodeLensRequest = {}));
	(function (CodeLensResolveRequest) {
	    CodeLensResolveRequest.method = 'codeLens/resolve';
	    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
	})(exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
	(function (CodeLensRefreshRequest) {
	    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
	    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
	})(exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
	(function (DocumentLinkRequest) {
	    DocumentLinkRequest.method = 'textDocument/documentLink';
	    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
	})(exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
	(function (DocumentLinkResolveRequest) {
	    DocumentLinkResolveRequest.method = 'documentLink/resolve';
	    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
	})(exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
	(function (DocumentFormattingRequest) {
	    DocumentFormattingRequest.method = 'textDocument/formatting';
	    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
	})(exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
	(function (DocumentRangeFormattingRequest) {
	    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
	    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
	})(exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
	(function (DocumentOnTypeFormattingRequest) {
	    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
	    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
	})(exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
	(function (PrepareSupportDefaultBehavior) {
	    /**
	     * The client's default behavior is to select the identifier
	     * according the to language's syntax rule.
	     */
	    PrepareSupportDefaultBehavior.Identifier = 1;
	})(exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
	(function (RenameRequest) {
	    RenameRequest.method = 'textDocument/rename';
	    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
	})(exports.RenameRequest || (exports.RenameRequest = {}));
	(function (PrepareRenameRequest) {
	    PrepareRenameRequest.method = 'textDocument/prepareRename';
	    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
	})(exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
	(function (ExecuteCommandRequest) {
	    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
	})(exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
	(function (ApplyWorkspaceEditRequest) {
	    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
	})(exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
	
} (protocol));

var connection = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(connection, "__esModule", { value: true });
connection.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = main$1;
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
connection.createProtocolConnection = createProtocolConnection;

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
	__exportStar(main$1, exports);
	__exportStar(require$$1, exports);
	__exportStar(messages, exports);
	__exportStar(protocol, exports);
	var connection_1 = connection;
	Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });
	(function (LSPErrorCodes) {
	    /**
	    * This is the start range of LSP reserved error codes.
	    * It doesn't denote a real error code.
	    *
	    * @since 3.16.0
	    */
	    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
	    LSPErrorCodes.ContentModified = -32801;
	    LSPErrorCodes.RequestCancelled = -32800;
	    /**
	    * This is the end range of LSP reserved error codes.
	    * It doesn't denote a real error code.
	    *
	    * @since 3.16.0
	    */
	    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
	})(exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
	
} (api));

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createProtocolConnection = void 0;
	const browser_1 = browser$1.exports;
	__exportStar(browser$1.exports, exports);
	__exportStar(api, exports);
	function createProtocolConnection(reader, writer, logger, options) {
	    return browser_1.createMessageConnection(reader, writer, logger, options);
	}
	exports.createProtocolConnection = createProtocolConnection;
	
} (main$2));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(semanticTokens, "__esModule", { value: true });
semanticTokens.SemanticTokensBuilder = semanticTokens.SemanticTokensFeature = void 0;
const vscode_languageserver_protocol_1$8 = main$2;
const SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1$8.SemanticTokensRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onDelta: (handler) => {
                    const type = vscode_languageserver_protocol_1$8.SemanticTokensDeltaRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1$8.SemanticTokensRangeRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
semanticTokens.SemanticTokensFeature = SemanticTokensFeature;
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            const prevDataLength = this._prevData.length;
            const dataLength = this._data.length;
            let startIndex = 0;
            while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
                startIndex++;
            }
            if (startIndex < dataLength && startIndex < prevDataLength) {
                // Find end index
                let endIndex = 0;
                while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
                    endIndex++;
                }
                const newData = this._data.slice(startIndex, dataLength - endIndex);
                const result = {
                    resultId: this.id,
                    edits: [
                        { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
                    ]
                };
                return result;
            }
            else if (startIndex < dataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
                    ] };
            }
            else if (startIndex < prevDataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: prevDataLength - startIndex }
                    ] };
            }
            else {
                return { resultId: this.id, edits: [] };
            }
        }
        else {
            return this.build();
        }
    }
}
semanticTokens.SemanticTokensBuilder = SemanticTokensBuilder;

var server = {};

var is = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(is, "__esModule", { value: true });
is.thenable = is.typedArray = is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
is.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
is.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
is.number = number;
function error$j(value) {
    return value instanceof Error;
}
is.error = error$j;
function func(value) {
    return typeof value === 'function';
}
is.func = func;
function array(value) {
    return Array.isArray(value);
}
is.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
is.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
is.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
is.thenable = thenable;

var uuid = {};

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.generateUuid = uuid.parse = uuid.isUUID = uuid.v4 = uuid.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
uuid.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
uuid.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
uuid.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse$2(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
uuid.parse = parse$2;
function generateUuid() {
    return v4().asHex();
}
uuid.generateUuid = generateUuid;

var progress = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(progress, "__esModule", { value: true });
progress.attachPartialResult = progress.ProgressFeature = progress.attachWorkDone = void 0;
const vscode_languageserver_protocol_1$7 = main$2;
const uuid_1 = uuid;
class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1$7.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1$7.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1$7.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
}
WorkDoneProgressReporterImpl.Instances = new Map();
class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1$7.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
        super.done();
    }
    cancel() {
        this._source.cancel();
    }
}
class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1$7.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
    }
    cancel() {
        this._source.cancel();
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgressReporter();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
}
progress.attachWorkDone = attachWorkDone;
const ProgressFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._progressSupported = false;
        }
        initialize(capabilities) {
            var _a;
            if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1$7.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgressReporter();
            }
            else {
                return new WorkDoneProgressReporterImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = uuid_1.generateUuid();
                return this.connection.sendRequest(vscode_languageserver_protocol_1$7.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgressServerReporter());
            }
        }
    };
};
progress.ProgressFeature = ProgressFeature;
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1$7.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
}
progress.attachPartialResult = attachPartialResult;

var configuration = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(configuration, "__esModule", { value: true });
configuration.ConfigurationFeature = void 0;
const vscode_languageserver_protocol_1$6 = main$2;
const Is = is;
const ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1$6.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};
configuration.ConfigurationFeature = ConfigurationFeature;

var workspaceFolders = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(workspaceFolders, "__esModule", { value: true });
workspaceFolders.WorkspaceFoldersFeature = void 0;
const vscode_languageserver_protocol_1$5 = main$2;
const WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1$5.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1$5.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1$5.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1$5.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
workspaceFolders.WorkspaceFoldersFeature = WorkspaceFoldersFeature;

var callHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(callHierarchy, "__esModule", { value: true });
callHierarchy.CallHierarchyFeature = void 0;
const vscode_languageserver_protocol_1$4 = main$2;
const CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1$4.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1$4.CallHierarchyIncomingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1$4.CallHierarchyOutgoingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
callHierarchy.CallHierarchyFeature = CallHierarchyFeature;

var showDocument = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(showDocument, "__esModule", { value: true });
showDocument.ShowDocumentFeature = void 0;
const vscode_languageserver_protocol_1$3 = main$2;
const ShowDocumentFeature = (Base) => {
    return class extends Base {
        showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1$3.ShowDocumentRequest.type, params);
        }
    };
};
showDocument.ShowDocumentFeature = ShowDocumentFeature;

var fileOperations = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(fileOperations, "__esModule", { value: true });
fileOperations.FileOperationsFeature = void 0;
const vscode_languageserver_protocol_1$2 = main$2;
const FileOperationsFeature = (Base) => {
    return class extends Base {
        onDidCreateFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1$2.DidCreateFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidRenameFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1$2.DidRenameFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidDeleteFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1$2.DidDeleteFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$2.WillCreateFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$2.WillRenameFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1$2.WillDeleteFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
    };
};
fileOperations.FileOperationsFeature = FileOperationsFeature;

var linkedEditingRange = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(linkedEditingRange, "__esModule", { value: true });
linkedEditingRange.LinkedEditingRangeFeature = void 0;
const vscode_languageserver_protocol_1$1 = main$2;
const LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
        onLinkedEditingRange(handler) {
            this.connection.onRequest(vscode_languageserver_protocol_1$1.LinkedEditingRangeRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
        }
    };
};
linkedEditingRange.LinkedEditingRangeFeature = LinkedEditingRangeFeature;

var moniker = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(moniker, "__esModule", { value: true });
moniker.MonikerFeature = void 0;
const vscode_languageserver_protocol_1 = main$2;
const MonikerFeature = (Base) => {
    return class extends Base {
        get moniker() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
            };
        }
    };
};
moniker.MonikerFeature = MonikerFeature;

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createConnection = exports.combineFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = exports.TextDocuments = void 0;
	const vscode_languageserver_protocol_1 = main$2;
	const Is = is;
	const UUID = uuid;
	const progress_1 = progress;
	const configuration_1 = configuration;
	const workspaceFolders_1 = workspaceFolders;
	const callHierarchy_1 = callHierarchy;
	const semanticTokens_1 = semanticTokens;
	const showDocument_1 = showDocument;
	const fileOperations_1 = fileOperations;
	const linkedEditingRange_1 = linkedEditingRange;
	const moniker_1 = moniker;
	function null2Undefined(value) {
	    if (value === null) {
	        return undefined;
	    }
	    return value;
	}
	/**
	 * A manager for simple text documents
	 */
	class TextDocuments {
	    /**
	     * Create a new text document manager.
	     */
	    constructor(configuration) {
	        this._documents = Object.create(null);
	        this._configuration = configuration;
	        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
	        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been opened or the content changes.
	     */
	    get onDidChangeContent() {
	        return this._onDidChangeContent.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been opened.
	     */
	    get onDidOpen() {
	        return this._onDidOpen.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * will be saved.
	     */
	    get onWillSave() {
	        return this._onWillSave.event;
	    }
	    /**
	     * Sets a handler that will be called if a participant wants to provide
	     * edits during a text document save.
	     */
	    onWillSaveWaitUntil(handler) {
	        this._willSaveWaitUntil = handler;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been saved.
	     */
	    get onDidSave() {
	        return this._onDidSave.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been closed.
	     */
	    get onDidClose() {
	        return this._onDidClose.event;
	    }
	    /**
	     * Returns the document for the given URI. Returns undefined if
	     * the document is not managed by this instance.
	     *
	     * @param uri The text document's URI to retrieve.
	     * @return the text document or `undefined`.
	     */
	    get(uri) {
	        return this._documents[uri];
	    }
	    /**
	     * Returns all text documents managed by this instance.
	     *
	     * @return all text documents.
	     */
	    all() {
	        return Object.keys(this._documents).map(key => this._documents[key]);
	    }
	    /**
	     * Returns the URIs of all text documents managed by this instance.
	     *
	     * @return the URI's of all text documents.
	     */
	    keys() {
	        return Object.keys(this._documents);
	    }
	    /**
	     * Listens for `low level` notification on the given connection to
	     * update the text documents managed by this instance.
	     *
	     * Please note that the connection only provides handlers not an event model. Therefore
	     * listening on a connection will overwrite the following handlers on a connection:
	     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
	     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
	     *
	     * Use the corresponding events on the TextDocuments instance instead.
	     *
	     * @param connection The connection to listen on.
	     */
	    listen(connection) {
	        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
	        connection.onDidOpenTextDocument((event) => {
	            let td = event.textDocument;
	            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
	            this._documents[td.uri] = document;
	            let toFire = Object.freeze({ document });
	            this._onDidOpen.fire(toFire);
	            this._onDidChangeContent.fire(toFire);
	        });
	        connection.onDidChangeTextDocument((event) => {
	            let td = event.textDocument;
	            let changes = event.contentChanges;
	            if (changes.length === 0) {
	                return;
	            }
	            let document = this._documents[td.uri];
	            const { version } = td;
	            if (version === null || version === undefined) {
	                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
	            }
	            document = this._configuration.update(document, changes, version);
	            this._documents[td.uri] = document;
	            this._onDidChangeContent.fire(Object.freeze({ document }));
	        });
	        connection.onDidCloseTextDocument((event) => {
	            let document = this._documents[event.textDocument.uri];
	            if (document) {
	                delete this._documents[event.textDocument.uri];
	                this._onDidClose.fire(Object.freeze({ document }));
	            }
	        });
	        connection.onWillSaveTextDocument((event) => {
	            let document = this._documents[event.textDocument.uri];
	            if (document) {
	                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
	            }
	        });
	        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
	            let document = this._documents[event.textDocument.uri];
	            if (document && this._willSaveWaitUntil) {
	                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
	            }
	            else {
	                return [];
	            }
	        });
	        connection.onDidSaveTextDocument((event) => {
	            let document = this._documents[event.textDocument.uri];
	            if (document) {
	                this._onDidSave.fire(Object.freeze({ document }));
	            }
	        });
	    }
	}
	exports.TextDocuments = TextDocuments;
	/**
	 * Helps tracking error message. Equal occurrences of the same
	 * message are only stored once. This class is for example
	 * useful if text documents are validated in a loop and equal
	 * error message should be folded into one.
	 */
	class ErrorMessageTracker {
	    constructor() {
	        this._messages = Object.create(null);
	    }
	    /**
	     * Add a message to the tracker.
	     *
	     * @param message The message to add.
	     */
	    add(message) {
	        let count = this._messages[message];
	        if (!count) {
	            count = 0;
	        }
	        count++;
	        this._messages[message] = count;
	    }
	    /**
	     * Send all tracked messages to the connection's window.
	     *
	     * @param connection The connection established between client and server.
	     */
	    sendErrors(connection) {
	        Object.keys(this._messages).forEach(message => {
	            connection.window.showErrorMessage(message);
	        });
	    }
	}
	exports.ErrorMessageTracker = ErrorMessageTracker;
	class RemoteConsoleImpl {
	    constructor() {
	    }
	    rawAttach(connection) {
	        this._rawConnection = connection;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    initialize(_capabilities) {
	    }
	    error(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
	    }
	    warn(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
	    }
	    info(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
	    }
	    log(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
	    }
	    send(type, message) {
	        if (this._rawConnection) {
	            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
	        }
	    }
	}
	class _RemoteWindowImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    showErrorMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	    showWarningMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	    showInformationMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	}
	const RemoteWindowImpl = showDocument_1.ShowDocumentFeature(progress_1.ProgressFeature(_RemoteWindowImpl));
	(function (BulkRegistration) {
	    /**
	     * Creates a new bulk registration.
	     * @return an empty bulk registration.
	     */
	    function create() {
	        return new BulkRegistrationImpl();
	    }
	    BulkRegistration.create = create;
	})(exports.BulkRegistration || (exports.BulkRegistration = {}));
	class BulkRegistrationImpl {
	    constructor() {
	        this._registrations = [];
	        this._registered = new Set();
	    }
	    add(type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        if (this._registered.has(method)) {
	            throw new Error(`${method} is already added to this registration`);
	        }
	        const id = UUID.generateUuid();
	        this._registrations.push({
	            id: id,
	            method: method,
	            registerOptions: registerOptions || {}
	        });
	        this._registered.add(method);
	    }
	    asRegistrationParams() {
	        return {
	            registrations: this._registrations
	        };
	    }
	}
	(function (BulkUnregistration) {
	    function create() {
	        return new BulkUnregistrationImpl(undefined, []);
	    }
	    BulkUnregistration.create = create;
	})(exports.BulkUnregistration || (exports.BulkUnregistration = {}));
	class BulkUnregistrationImpl {
	    constructor(_connection, unregistrations) {
	        this._connection = _connection;
	        this._unregistrations = new Map();
	        unregistrations.forEach(unregistration => {
	            this._unregistrations.set(unregistration.method, unregistration);
	        });
	    }
	    get isAttached() {
	        return !!this._connection;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    add(unregistration) {
	        this._unregistrations.set(unregistration.method, unregistration);
	    }
	    dispose() {
	        let unregistrations = [];
	        for (let unregistration of this._unregistrations.values()) {
	            unregistrations.push(unregistration);
	        }
	        let params = {
	            unregisterations: unregistrations
	        };
	        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
	            this._connection.console.info(`Bulk unregistration failed.`);
	        });
	    }
	    disposeSingle(arg) {
	        const method = Is.string(arg) ? arg : arg.method;
	        const unregistration = this._unregistrations.get(method);
	        if (!unregistration) {
	            return false;
	        }
	        let params = {
	            unregisterations: [unregistration]
	        };
	        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
	            this._unregistrations.delete(method);
	        }, (_error) => {
	            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
	        });
	        return true;
	    }
	}
	class RemoteClientImpl {
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
	        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
	            return this.registerMany(typeOrRegistrations);
	        }
	        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
	            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
	        }
	        else {
	            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
	        }
	    }
	    registerSingle1(unregistration, type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        const id = UUID.generateUuid();
	        let params = {
	            registrations: [{ id, method, registerOptions: registerOptions || {} }]
	        };
	        if (!unregistration.isAttached) {
	            unregistration.attach(this.connection);
	        }
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
	            unregistration.add({ id: id, method: method });
	            return unregistration;
	        }, (_error) => {
	            this.connection.console.info(`Registering request handler for ${method} failed.`);
	            return Promise.reject(_error);
	        });
	    }
	    registerSingle2(type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        const id = UUID.generateUuid();
	        let params = {
	            registrations: [{ id, method, registerOptions: registerOptions || {} }]
	        };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
	            return vscode_languageserver_protocol_1.Disposable.create(() => {
	                this.unregisterSingle(id, method);
	            });
	        }, (_error) => {
	            this.connection.console.info(`Registering request handler for ${method} failed.`);
	            return Promise.reject(_error);
	        });
	    }
	    unregisterSingle(id, method) {
	        let params = {
	            unregisterations: [{ id, method }]
	        };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
	            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
	        });
	    }
	    registerMany(registrations) {
	        let params = registrations.asRegistrationParams();
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
	            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
	        }, (_error) => {
	            this.connection.console.info(`Bulk registration failed.`);
	            return Promise.reject(_error);
	        });
	    }
	}
	class _RemoteWorkspaceImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    applyEdit(paramOrEdit) {
	        function isApplyWorkspaceEditParams(value) {
	            return value && !!value.edit;
	        }
	        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
	    }
	}
	const RemoteWorkspaceImpl = fileOperations_1.FileOperationsFeature(workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl)));
	class TracerImpl {
	    constructor() {
	        this._trace = vscode_languageserver_protocol_1.Trace.Off;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    set trace(value) {
	        this._trace = value;
	    }
	    log(message, verbose) {
	        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
	            return;
	        }
	        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
	            message: message,
	            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
	        });
	    }
	}
	class TelemetryImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    logEvent(data) {
	        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
	    }
	}
	class _LanguagesImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    attachWorkDoneProgress(params) {
	        return progress_1.attachWorkDone(this.connection, params);
	    }
	    attachPartialResultProgress(_type, params) {
	        return progress_1.attachPartialResult(this.connection, params);
	    }
	}
	exports._LanguagesImpl = _LanguagesImpl;
	const LanguagesImpl = moniker_1.MonikerFeature(linkedEditingRange_1.LinkedEditingRangeFeature(semanticTokens_1.SemanticTokensFeature(callHierarchy_1.CallHierarchyFeature(_LanguagesImpl))));
	function combineConsoleFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineConsoleFeatures = combineConsoleFeatures;
	function combineTelemetryFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineTelemetryFeatures = combineTelemetryFeatures;
	function combineTracerFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineTracerFeatures = combineTracerFeatures;
	function combineClientFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineClientFeatures = combineClientFeatures;
	function combineWindowFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineWindowFeatures = combineWindowFeatures;
	function combineWorkspaceFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
	function combineLanguagesFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	exports.combineLanguagesFeatures = combineLanguagesFeatures;
	function combineFeatures(one, two) {
	    function combine(one, two, func) {
	        if (one && two) {
	            return func(one, two);
	        }
	        else if (one) {
	            return one;
	        }
	        else {
	            return two;
	        }
	    }
	    let result = {
	        __brand: 'features',
	        console: combine(one.console, two.console, combineConsoleFeatures),
	        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
	        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
	        client: combine(one.client, two.client, combineClientFeatures),
	        window: combine(one.window, two.window, combineWindowFeatures),
	        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
	    };
	    return result;
	}
	exports.combineFeatures = combineFeatures;
	function createConnection(connectionFactory, watchDog, factories) {
	    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
	    const connection = connectionFactory(logger);
	    logger.rawAttach(connection);
	    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
	    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
	    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
	    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
	    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
	    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
	    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
	    function asPromise(value) {
	        if (value instanceof Promise) {
	            return value;
	        }
	        else if (Is.thenable(value)) {
	            return new Promise((resolve, reject) => {
	                value.then((resolved) => resolve(resolved), (error) => reject(error));
	            });
	        }
	        else {
	            return Promise.resolve(value);
	        }
	    }
	    let shutdownHandler = undefined;
	    let initializeHandler = undefined;
	    let exitHandler = undefined;
	    let protocolConnection = {
	        listen: () => connection.listen(),
	        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
	        onRequest: (type, handler) => connection.onRequest(type, handler),
	        sendNotification: (type, param) => {
	            const method = Is.string(type) ? type : type.method;
	            if (arguments.length === 1) {
	                connection.sendNotification(method);
	            }
	            else {
	                connection.sendNotification(method, param);
	            }
	        },
	        onNotification: (type, handler) => connection.onNotification(type, handler),
	        onProgress: connection.onProgress,
	        sendProgress: connection.sendProgress,
	        onInitialize: (handler) => initializeHandler = handler,
	        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
	        onShutdown: (handler) => shutdownHandler = handler,
	        onExit: (handler) => exitHandler = handler,
	        get console() { return logger; },
	        get telemetry() { return telemetry; },
	        get tracer() { return tracer; },
	        get client() { return client; },
	        get window() { return remoteWindow; },
	        get workspace() { return workspace; },
	        get languages() { return languages; },
	        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
	        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
	        __textDocumentSync: undefined,
	        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
	        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
	        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
	        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
	        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
	        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
	        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
	        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
	        }),
	        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
	        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
	        }),
	        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
	        }),
	        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
	        }),
	        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
	        }),
	        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
	        }),
	        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
	            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
	        }),
	        dispose: () => connection.dispose()
	    };
	    for (let remote of allRemotes) {
	        remote.attach(protocolConnection);
	    }
	    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
	        watchDog.initialize(params);
	        if (Is.string(params.trace)) {
	            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
	        }
	        for (let remote of allRemotes) {
	            remote.initialize(params.capabilities);
	        }
	        if (initializeHandler) {
	            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), undefined);
	            return asPromise(result).then((value) => {
	                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
	                    return value;
	                }
	                let result = value;
	                if (!result) {
	                    result = { capabilities: {} };
	                }
	                let capabilities = result.capabilities;
	                if (!capabilities) {
	                    capabilities = {};
	                    result.capabilities = capabilities;
	                }
	                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
	                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
	                }
	                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
	                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
	                }
	                for (let remote of allRemotes) {
	                    remote.fillServerCapabilities(capabilities);
	                }
	                return result;
	            });
	        }
	        else {
	            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
	            for (let remote of allRemotes) {
	                remote.fillServerCapabilities(result.capabilities);
	            }
	            return result;
	        }
	    });
	    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
	        watchDog.shutdownReceived = true;
	        if (shutdownHandler) {
	            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
	        }
	        else {
	            return undefined;
	        }
	    });
	    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
	        try {
	            if (exitHandler) {
	                exitHandler();
	            }
	        }
	        finally {
	            if (watchDog.shutdownReceived) {
	                watchDog.exit(0);
	            }
	            else {
	                watchDog.exit(1);
	            }
	        }
	    });
	    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
	        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
	    });
	    return protocolConnection;
	}
	exports.createConnection = createConnection;
	
} (server));

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ProposedFeatures = exports.SemanticTokensBuilder = void 0;
	const semanticTokens_1 = semanticTokens;
	Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });
	__exportStar(main$2, exports);
	__exportStar(server, exports);
	(function (ProposedFeatures) {
	    ProposedFeatures.all = {
	        __brand: 'features'
	    };
	})(exports.ProposedFeatures || (exports.ProposedFeatures = {}));
	
} (api$2));

var browser = {exports: {}};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

(function (module) {

	module.exports = main$2;
} (browser));

(function (exports) {
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createConnection = void 0;
	const api_1 = api$2;
	__exportStar(browser.exports, exports);
	__exportStar(api$2, exports);
	let _shutdownReceived = false;
	const watchDog = {
	    initialize: (_params) => {
	    },
	    get shutdownReceived() {
	        return _shutdownReceived;
	    },
	    set shutdownReceived(value) {
	        _shutdownReceived = value;
	    },
	    exit: (_code) => {
	    }
	};
	function createConnection(arg1, arg2, arg3, arg4) {
	    let factories;
	    let reader;
	    let writer;
	    let options;
	    if (arg1 !== void 0 && arg1.__brand === 'features') {
	        factories = arg1;
	        arg1 = arg2;
	        arg2 = arg3;
	        arg3 = arg4;
	    }
	    if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
	        options = arg1;
	    }
	    else {
	        reader = arg1;
	        writer = arg2;
	        options = arg3;
	    }
	    const connectionFactory = (logger) => {
	        return api_1.createProtocolConnection(reader, writer, logger, options);
	    };
	    return api_1.createConnection(connectionFactory, watchDog, factories);
	}
	exports.createConnection = createConnection;
	
} (main$3));

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

(function (module) {

	module.exports = main$3;
} (node));

/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


var isNothing_1      = isNothing;
var isObject_1       = isObject;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common = {
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984


function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException$1(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;


YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


var exception = YAMLException$1;

// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '→') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}


function makeSnippet(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


var snippet = makeSnippet;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type$1(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type$2 = Type$1;

/*eslint-disable max-len*/





function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema$1(definition) {
  return this.extend(definition);
}


Schema$1.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof type$2) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type$1) {
    if (!(type$1 instanceof type$2)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type$1.loadKind && type$1.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type$1.multi) {
      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type$1) {
    if (!(type$1 instanceof type$2)) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema$1.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


var schema = Schema$1;

var str = new type$2('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var seq = new type$2('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var map = new type$2('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type$2('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type$2('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

var int = new type$2('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

var float = new type$2('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});

var core$3 = json;

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new type$2('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type$2('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/





// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

var binary = new type$2('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString$2.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type$2('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new type$2('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type$2('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var _default = core$3.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});

/*eslint-disable max-len,no-use-before-define*/







var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State$1(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || _default;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = snippet(mark);

  return new exception(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
        _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State$1(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load$1(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception('expected a single document in the stream, but found more');
}


var loadAll_1 = loadAll$1;
var load_1    = load$1;

var loader = {
	loadAll: loadAll_1,
	load: load_1
};

/*eslint-disable no-use-before-define*/





var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || _default;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
//                             c = flow-in   ⇒ ns-plain-safe-in
//                             c = block-key ⇒ ns-plain-safe-out
//                             c = flow-key  ⇒ ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
//                            | ( /* An ns-char preceding */ “#” )
//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump$1(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

var dump_1 = dump$1;

var dumper = {
	dump: dump_1
};

function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
      'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}


var Type                = type$2;
var Schema              = schema;
var FAILSAFE_SCHEMA     = failsafe;
var JSON_SCHEMA         = json;
var CORE_SCHEMA         = core$3;
var DEFAULT_SCHEMA      = _default;
var load                = loader.load;
var loadAll             = loader.loadAll;
var dump                = dumper.dump;
var YAMLException       = exception;

// Re-export all types in case user wants to create custom schema
var types$1 = {
  binary:    binary,
  float:     float,
  map:       map,
  null:      _null,
  pairs:     pairs,
  set:       set,
  timestamp: timestamp,
  bool:      bool,
  int:       int,
  merge:     merge,
  omap:      omap,
  seq:       seq,
  str:       str
};

// Removed functions from JS-YAML 3.0.x
var safeLoad            = renamed('safeLoad', 'load');
var safeLoadAll         = renamed('safeLoadAll', 'loadAll');
var safeDump            = renamed('safeDump', 'dump');

var jsYaml = {
	Type: Type,
	Schema: Schema,
	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
	JSON_SCHEMA: JSON_SCHEMA,
	CORE_SCHEMA: CORE_SCHEMA,
	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
	load: load,
	loadAll: loadAll,
	dump: dump,
	YAMLException: YAMLException,
	types: types$1,
	safeLoad: safeLoad,
	safeLoadAll: safeLoadAll,
	safeDump: safeDump
};

// Forked from https://github.com/microsoft/TypeScript/blob/663b19fe4a7c4d4ddaa61aedadd28da06acd27b6/src/compiler/path.ts
/**
 * Internally, we represent paths as strings with '/' as the directory separator.
 * When we make system calls (eg: LanguageServiceHost.getDirectory()),
 * we expect the host to correctly handle paths in our specified format.
 */
const directorySeparator = "/";
const altDirectorySeparator = "\\";
const urlSchemeSeparator = "://";
const backslashRegExp = /\\/g;
const relativePathSegmentRegExp = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
//#region Path Tests
/**
 * Determines whether a charCode corresponds to `/` or `\`.
 */
function isAnyDirectorySeparator(charCode) {
    return charCode === 47 /* CharacterCodes.slash */ || charCode === 92 /* CharacterCodes.backslash */;
}
/**
 * Determines whether a path starts with a URL scheme (e.g. starts with `http://`, `ftp://`, `file://`, etc.).
 */
function isUrl(path) {
    return getEncodedRootLength(path) < 0;
}
/*
 * Determines whether a path starts with an absolute path component (i.e. `/`, `c:/`, `file://`, etc.).
 *
 * ```ts
 * // POSIX
 * isPathAbsolute("/path/to/file.ext") === true
 * // DOS
 * isPathAbsolute("c:/path/to/file.ext") === true
 * // URL
 * isPathAbsolute("file:///path/to/file.ext") === true
 * // Non-absolute
 * isPathAbsolute("path/to/file.ext") === false
 * isPathAbsolute("./path/to/file.ext") === false
 * ```
 */
function isPathAbsolute(path) {
    return getEncodedRootLength(path) !== 0;
}
//#endregion
//#region Path Parsing
function isVolumeCharacter(charCode) {
    return ((charCode >= 97 /* CharacterCodes.a */ && charCode <= 122 /* CharacterCodes.z */) ||
        (charCode >= 65 /* CharacterCodes.A */ && charCode <= 90 /* CharacterCodes.Z */));
}
function getFileUrlVolumeSeparatorEnd(url, start) {
    const ch0 = url.charCodeAt(start);
    if (ch0 === 58 /* CharacterCodes.colon */)
        return start + 1;
    if (ch0 === 37 /* CharacterCodes.percent */ && url.charCodeAt(start + 1) === 51 /* CharacterCodes._3 */) {
        const ch2 = url.charCodeAt(start + 2);
        if (ch2 === 97 /* CharacterCodes.a */ || ch2 === 65 /* CharacterCodes.A */)
            return start + 3;
    }
    return -1;
}
/**
 * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
 *
 * For example:
 * ```ts
 * getRootLength("a") === 0                   // ""
 * getRootLength("/") === 1                   // "/"
 * getRootLength("c:") === 2                  // "c:"
 * getRootLength("c:d") === 0                 // ""
 * getRootLength("c:/") === 3                 // "c:/"
 * getRootLength("c:\\") === 3                // "c:\\"
 * getRootLength("//server") === 7            // "//server"
 * getRootLength("//server/share") === 8      // "//server/"
 * getRootLength("\\\\server") === 7          // "\\\\server"
 * getRootLength("\\\\server\\share") === 8   // "\\\\server\\"
 * getRootLength("file:///path") === 8        // "file:///"
 * getRootLength("file:///c:") === 10         // "file:///c:"
 * getRootLength("file:///c:d") === 8         // "file:///"
 * getRootLength("file:///c:/path") === 11    // "file:///c:/"
 * getRootLength("file://server") === 13      // "file://server"
 * getRootLength("file://server/path") === 14 // "file://server/"
 * getRootLength("http://server") === 13      // "http://server"
 * getRootLength("http://server/path") === 14 // "http://server/"
 * ```
 */
function getRootLength(path) {
    const rootLength = getEncodedRootLength(path);
    return rootLength < 0 ? ~rootLength : rootLength;
}
/**
 * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
 * If the root is part of a URL, the twos-complement of the root length is returned.
 */
function getEncodedRootLength(path) {
    if (!path)
        return 0;
    const ch0 = path.charCodeAt(0);
    // POSIX or UNC
    if (ch0 === 47 /* CharacterCodes.slash */ || ch0 === 92 /* CharacterCodes.backslash */) {
        if (path.charCodeAt(1) !== ch0)
            return 1; // POSIX: "/" (or non-normalized "\")
        const p1 = path.indexOf(ch0 === 47 /* CharacterCodes.slash */ ? directorySeparator : altDirectorySeparator, 2);
        if (p1 < 0)
            return path.length; // UNC: "//server" or "\\server"
        return p1 + 1; // UNC: "//server/" or "\\server\"
    }
    // DOS
    if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* CharacterCodes.colon */) {
        const ch2 = path.charCodeAt(2);
        if (ch2 === 47 /* CharacterCodes.slash */ || ch2 === 92 /* CharacterCodes.backslash */)
            return 3; // DOS: "c:/" or "c:\"
        if (path.length === 2)
            return 2; // DOS: "c:" (but not "c:d")
    }
    // URL
    const schemeEnd = path.indexOf(urlSchemeSeparator);
    if (schemeEnd !== -1) {
        const authorityStart = schemeEnd + urlSchemeSeparator.length;
        const authorityEnd = path.indexOf(directorySeparator, authorityStart);
        if (authorityEnd !== -1) {
            // URL: "file:///", "file://server/", "file://server/path"
            // For local "file" URLs, include the leading DOS volume (if present).
            // Per https://www.ietf.org/rfc/rfc1738.txt, a host of "" or "localhost" is a
            // special case interpreted as "the machine from which the URL is being interpreted".
            const scheme = path.slice(0, schemeEnd);
            const authority = path.slice(authorityStart, authorityEnd);
            if (scheme === "file" &&
                (authority === "" || authority === "localhost") &&
                isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
                const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
                if (volumeSeparatorEnd !== -1) {
                    if (path.charCodeAt(volumeSeparatorEnd) === 47 /* CharacterCodes.slash */) {
                        // URL: "file:///c:/", "file://localhost/c:/", "file:///c%3a/", "file://localhost/c%3a/"
                        return ~(volumeSeparatorEnd + 1);
                    }
                    if (volumeSeparatorEnd === path.length) {
                        // URL: "file:///c:", "file://localhost/c:", "file:///c$3a", "file://localhost/c%3a"
                        // but not "file:///c:d" or "file:///c%3ad"
                        return ~volumeSeparatorEnd;
                    }
                }
            }
            return ~(authorityEnd + 1); // URL: "file://server/", "http://server/"
        }
        return ~path.length; // URL: "file://server", "http://server"
    }
    // relative
    return 0;
}
function getDirectoryPath(path) {
    path = normalizeSlashes(path);
    // If the path provided is itself the root, then return it.
    const rootLength = getRootLength(path);
    if (rootLength === path.length)
        return path;
    // return the leading portion of the path up to the last (non-terminal) directory separator
    // but not including any trailing directory separator.
    path = removeTrailingDirectorySeparator(path);
    return path.slice(0, Math.max(rootLength, path.lastIndexOf(directorySeparator)));
}
/**
 * Returns the path except for its containing directory name.
 * Semantics align with NodeJS's `path.basename` except that we support URL's as well.
 *
 * ```ts
 * // POSIX
 * getBaseFileName("/path/to/file.ext") === "file.ext"
 * getBaseFileName("/path/to/") === "to"
 * getBaseFileName("/") === ""
 * // DOS
 * getBaseFileName("c:/path/to/file.ext") === "file.ext"
 * getBaseFileName("c:/path/to/") === "to"
 * getBaseFileName("c:/") === ""
 * getBaseFileName("c:") === ""
 * // URL
 * getBaseFileName("http://typescriptlang.org/path/to/file.ext") === "file.ext"
 * getBaseFileName("http://typescriptlang.org/path/to/") === "to"
 * getBaseFileName("http://typescriptlang.org/") === ""
 * getBaseFileName("http://typescriptlang.org") === ""
 * getBaseFileName("file://server/path/to/file.ext") === "file.ext"
 * getBaseFileName("file://server/path/to/") === "to"
 * getBaseFileName("file://server/") === ""
 * getBaseFileName("file://server") === ""
 * getBaseFileName("file:///path/to/file.ext") === "file.ext"
 * getBaseFileName("file:///path/to/") === "to"
 * getBaseFileName("file:///") === ""
 * getBaseFileName("file://") === ""
 * ```
 */
function getBaseFileName(path) {
    path = normalizeSlashes(path);
    // if the path provided is itself the root, then it has not file name.
    const rootLength = getRootLength(path);
    if (rootLength === path.length)
        return "";
    // return the trailing portion of the path starting after the last (non-terminal) directory
    // separator but not including any trailing directory separator.
    path = removeTrailingDirectorySeparator(path);
    return path.slice(Math.max(getRootLength(path), path.lastIndexOf(directorySeparator) + 1));
}
/**
 * Gets the file extension for a path.
 * Normalizes it to lower case.
 *
 * ```ts
 * getAnyExtensionFromPath("/path/to/file.ext") === ".ext"
 * getAnyExtensionFromPath("/path/to/file.ext/") === ".ext"
 * getAnyExtensionFromPath("/path/to/file") === ""
 * getAnyExtensionFromPath("/path/to.ext/file") === ""
 * ```
 */
function getAnyExtensionFromPath(path) {
    // Retrieves any string from the final "." onwards from a base file name.
    // Unlike extensionFromPath, which throws an exception on unrecognized extensions.
    const baseFileName = getBaseFileName(path);
    const extensionIndex = baseFileName.lastIndexOf(".");
    if (extensionIndex >= 0) {
        return baseFileName.substring(extensionIndex).toLowerCase();
    }
    return "";
}
function pathComponents(path, rootLength) {
    const root = path.substring(0, rootLength);
    const rest = path.substring(rootLength).split(directorySeparator);
    if (rest.length && !rest[rest.length - 1])
        rest.pop();
    return [root, ...rest];
}
/**
 * Parse a path into an array containing a root component (at index 0) and zero or more path
 * components (at indices > 0). The result is not normalized.
 * If the path is relative, the root component is `""`.
 * If the path is absolute, the root component includes the first path separator (`/`).
 *
 * ```ts
 * // POSIX
 * getPathComponents("/path/to/file.ext") === ["/", "path", "to", "file.ext"]
 * getPathComponents("/path/to/") === ["/", "path", "to"]
 * getPathComponents("/") === ["/"]
 * // DOS
 * getPathComponents("c:/path/to/file.ext") === ["c:/", "path", "to", "file.ext"]
 * getPathComponents("c:/path/to/") === ["c:/", "path", "to"]
 * getPathComponents("c:/") === ["c:/"]
 * getPathComponents("c:") === ["c:"]
 * // URL
 * getPathComponents("http://typescriptlang.org/path/to/file.ext") === ["http://typescriptlang.org/", "path", "to", "file.ext"]
 * getPathComponents("http://typescriptlang.org/path/to/") === ["http://typescriptlang.org/", "path", "to"]
 * getPathComponents("http://typescriptlang.org/") === ["http://typescriptlang.org/"]
 * getPathComponents("http://typescriptlang.org") === ["http://typescriptlang.org"]
 * getPathComponents("file://server/path/to/file.ext") === ["file://server/", "path", "to", "file.ext"]
 * getPathComponents("file://server/path/to/") === ["file://server/", "path", "to"]
 * getPathComponents("file://server/") === ["file://server/"]
 * getPathComponents("file://server") === ["file://server"]
 * getPathComponents("file:///path/to/file.ext") === ["file:///", "path", "to", "file.ext"]
 * getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
 * getPathComponents("file:///") === ["file:///"]
 * getPathComponents("file://") === ["file://"]
 */
function getPathComponents(path, currentDirectory = "") {
    path = joinPaths(currentDirectory, path);
    return pathComponents(path, getRootLength(path));
}
//#endregion
//#region Path Formatting
/**
 * Reduce an array of path components to a more simplified path by navigating any
 * `"."` or `".."` entries in the path.
 */
function reducePathComponents(components) {
    if (!components.some((x) => x !== undefined))
        return [];
    const reduced = [components[0]];
    for (let i = 1; i < components.length; i++) {
        const component = components[i];
        if (!component)
            continue;
        if (component === ".")
            continue;
        if (component === "..") {
            if (reduced.length > 1) {
                if (reduced[reduced.length - 1] !== "..") {
                    reduced.pop();
                    continue;
                }
            }
            else if (reduced[0])
                continue;
        }
        reduced.push(component);
    }
    return reduced;
}
/**
 * Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.
 *
 * ```ts
 * // Non-rooted
 * joinPaths("path", "to", "file.ext") === "path/to/file.ext"
 * joinPaths("path", "dir", "..", "to", "file.ext") === "path/dir/../to/file.ext"
 * // POSIX
 * joinPaths("/path", "to", "file.ext") === "/path/to/file.ext"
 * joinPaths("/path", "/to", "file.ext") === "/to/file.ext"
 * // DOS
 * joinPaths("c:/path", "to", "file.ext") === "c:/path/to/file.ext"
 * joinPaths("c:/path", "c:/to", "file.ext") === "c:/to/file.ext"
 * // URL
 * joinPaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
 * joinPaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
 * ```
 */
function joinPaths(path, ...paths) {
    if (path)
        path = normalizeSlashes(path);
    for (let relativePath of paths) {
        if (!relativePath)
            continue;
        relativePath = normalizeSlashes(relativePath);
        if (!path || getRootLength(relativePath) !== 0) {
            path = relativePath;
        }
        else {
            path = ensureTrailingDirectorySeparator(path) + relativePath;
        }
    }
    return path;
}
/**
 * Combines and resolves paths. If a path is absolute, it replaces any previous path. Any
 * `.` and `..` path components are resolved. Trailing directory separators are preserved.
 *
 * ```ts
 * resolvePath("/path", "to", "file.ext") === "path/to/file.ext"
 * resolvePath("/path", "to", "file.ext/") === "path/to/file.ext/"
 * resolvePath("/path", "dir", "..", "to", "file.ext") === "path/to/file.ext"
 * ```
 */
function resolvePath(path, ...paths) {
    return normalizePath(paths.some((x) => x !== undefined) ? joinPaths(path, ...paths) : normalizeSlashes(path));
}
/**
 * Parse a path into an array containing a root component (at index 0) and zero or more path
 * components (at indices > 0). The result is normalized.
 * If the path is relative, the root component is `""`.
 * If the path is absolute, the root component includes the first path separator (`/`).
 *
 * ```ts
 * getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
 * ```
 */
function getNormalizedPathComponents(path, currentDirectory) {
    return reducePathComponents(getPathComponents(path, currentDirectory));
}
function getNormalizedAbsolutePath(fileName, currentDirectory) {
    return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));
}
function normalizePath(path) {
    path = normalizeSlashes(path);
    // Most paths don't require normalization
    if (!relativePathSegmentRegExp.test(path)) {
        return path;
    }
    // Some paths only require cleanup of `/./` or leading `./`
    const simplified = path.replace(/\/\.\//g, "/").replace(/^\.\//, "");
    if (simplified !== path) {
        path = simplified;
        if (!relativePathSegmentRegExp.test(path)) {
            return path;
        }
    }
    // Other paths require full normalization
    const normalized = getPathFromPathComponents(reducePathComponents(getPathComponents(path)));
    return normalized && hasTrailingDirectorySeparator(path)
        ? ensureTrailingDirectorySeparator(normalized)
        : normalized;
}
//#endregion
function getPathWithoutRoot(pathComponents) {
    if (pathComponents.length === 0)
        return "";
    return pathComponents.slice(1).join(directorySeparator);
}
function getNormalizedAbsolutePathWithoutRoot(fileName, currentDirectory) {
    return getPathWithoutRoot(getNormalizedPathComponents(fileName, currentDirectory));
}
/**
 * Formats a parsed path consisting of a root component (at index 0) and zero or more path
 * segments (at indices > 0).
 *
 * ```ts
 * getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
 * ```
 */
function getPathFromPathComponents(pathComponents) {
    if (pathComponents.length === 0)
        return "";
    const root = pathComponents[0] && ensureTrailingDirectorySeparator(pathComponents[0]);
    return root + pathComponents.slice(1).join(directorySeparator);
}
function removeTrailingDirectorySeparator(path) {
    if (hasTrailingDirectorySeparator(path)) {
        return path.substr(0, path.length - 1);
    }
    return path;
}
function ensureTrailingDirectorySeparator(path) {
    if (!hasTrailingDirectorySeparator(path)) {
        return path + directorySeparator;
    }
    return path;
}
/**
 * Determines whether a path has a trailing separator (`/` or `\\`).
 */
function hasTrailingDirectorySeparator(path) {
    return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
}
/**
 * Normalize path separators, converting `\` into `/`.
 */
function normalizeSlashes(path) {
    const index = path.indexOf("\\");
    if (index === -1) {
        return path;
    }
    backslashRegExp.lastIndex = index; // prime regex with known position
    return path.replace(backslashRegExp, directorySeparator);
}

var ajv = {exports: {}};

var core$2 = {};

var validate = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	class _CodeOrName {
	}
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	class Name extends _CodeOrName {
	    constructor(s) {
	        super();
	        if (!exports.IDENTIFIER.test(s))
	            throw new Error("CodeGen: name must be a valid identifier");
	        this.str = s;
	    }
	    toString() {
	        return this.str;
	    }
	    emptyStr() {
	        return false;
	    }
	    get names() {
	        return { [this.str]: 1 };
	    }
	}
	exports.Name = Name;
	class _Code extends _CodeOrName {
	    constructor(code) {
	        super();
	        this._items = typeof code === "string" ? [code] : code;
	    }
	    toString() {
	        return this.str;
	    }
	    emptyStr() {
	        if (this._items.length > 1)
	            return false;
	        const item = this._items[0];
	        return item === "" || item === '""';
	    }
	    get str() {
	        var _a;
	        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
	    }
	    get names() {
	        var _a;
	        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
	            if (c instanceof Name)
	                names[c.str] = (names[c.str] || 0) + 1;
	            return names;
	        }, {})));
	    }
	}
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
	    const code = [strs[0]];
	    let i = 0;
	    while (i < args.length) {
	        addCodeArg(code, args[i]);
	        code.push(strs[++i]);
	    }
	    return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
	    const expr = [safeStringify(strs[0])];
	    let i = 0;
	    while (i < args.length) {
	        expr.push(plus);
	        addCodeArg(expr, args[i]);
	        expr.push(plus, safeStringify(strs[++i]));
	    }
	    optimize(expr);
	    return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
	    if (arg instanceof _Code)
	        code.push(...arg._items);
	    else if (arg instanceof Name)
	        code.push(arg);
	    else
	        code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
	    let i = 1;
	    while (i < expr.length - 1) {
	        if (expr[i] === plus) {
	            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
	            if (res !== undefined) {
	                expr.splice(i - 1, 3, res);
	                continue;
	            }
	            expr[i++] = "+";
	        }
	        i++;
	    }
	}
	function mergeExprItems(a, b) {
	    if (b === '""')
	        return a;
	    if (a === '""')
	        return b;
	    if (typeof a == "string") {
	        if (b instanceof Name || a[a.length - 1] !== '"')
	            return;
	        if (typeof b != "string")
	            return `${a.slice(0, -1)}${b}"`;
	        if (b[0] === '"')
	            return a.slice(0, -1) + b.slice(1);
	        return;
	    }
	    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
	        return `"${a}${b.slice(1)}`;
	    return;
	}
	function strConcat(c1, c2) {
	    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	// TODO do not allow arrays here
	function interpolate(x) {
	    return typeof x == "number" || typeof x == "boolean" || x === null
	        ? x
	        : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
	    return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
	    return JSON.stringify(x)
	        .replace(/\u2028/g, "\\u2028")
	        .replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
	    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
	}
	exports.getProperty = getProperty;
	//Does best effort to format the name properly
	function getEsmExportName(key) {
	    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
	        return new _Code(`${key}`);
	    }
	    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
	    return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
	
} (code$1));

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = code$1;
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = code$1;
		const scope_1 = requireScope();
		var code_2 = code$1;
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
} (codegen));
	return codegen;
}

var util$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = code$1;
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	exports.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	exports.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type = exports.Type || (exports.Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
	
} (util$1));

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"),
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"),
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"),
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"),
	    errors: new codegen_1.Name("errors"),
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	const names_1 = requireNames();
	exports.keywordError = {
	    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
	};
	exports.keyword$DataError = {
	    message: ({ keyword, schemaType }) => schemaType
	        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
	        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
	};
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
	    const { it } = cxt;
	    const { gen, compositeRule, allErrors } = it;
	    const errObj = errorObjectCode(cxt, error, errorPaths);
	    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
	        addError(gen, errObj);
	    }
	    else {
	        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
	    }
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
	    const { it } = cxt;
	    const { gen, compositeRule, allErrors } = it;
	    const errObj = errorObjectCode(cxt, error, errorPaths);
	    addError(gen, errObj);
	    if (!(compositeRule || allErrors)) {
	        returnErrors(it, names_1.default.vErrors);
	    }
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
	    gen.assign(names_1.default.errors, errsCount);
	    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
	    /* istanbul ignore if */
	    if (errsCount === undefined)
	        throw new Error("ajv implementation error");
	    const err = gen.name("err");
	    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
	        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
	        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
	        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
	        if (it.opts.verbose) {
	            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
	            gen.assign((0, codegen_1._) `${err}.data`, data);
	        }
	    });
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
	    const err = gen.const("err", errObj);
	    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
	    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
	}
	function returnErrors(it, errs) {
	    const { gen, validateName, schemaEnv } = it;
	    if (schemaEnv.$async) {
	        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
	        gen.return(false);
	    }
	}
	const E = {
	    keyword: new codegen_1.Name("keyword"),
	    schemaPath: new codegen_1.Name("schemaPath"),
	    params: new codegen_1.Name("params"),
	    propertyName: new codegen_1.Name("propertyName"),
	    message: new codegen_1.Name("message"),
	    schema: new codegen_1.Name("schema"),
	    parentSchema: new codegen_1.Name("parentSchema"),
	};
	function errorObjectCode(cxt, error, errorPaths) {
	    const { createErrors } = cxt.it;
	    if (createErrors === false)
	        return (0, codegen_1._) `{}`;
	    return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
	    const { gen, it } = cxt;
	    const keyValues = [
	        errorInstancePath(it, errorPaths),
	        errorSchemaPath(cxt, errorPaths),
	    ];
	    extraErrorProps(cxt, error, keyValues);
	    return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
	    const instPath = instancePath
	        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
	        : errorPath;
	    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
	    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
	    if (schemaPath) {
	        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
	    }
	    return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
	    const { keyword, data, schemaValue, it } = cxt;
	    const { opts, propertyName, topSchemaRef, schemaPath } = it;
	    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
	    if (opts.messages) {
	        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
	    }
	    if (opts.verbose) {
	        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
	    }
	    if (propertyName)
	        keyValues.push([E.propertyName, propertyName]);
	}
	
} (errors));

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = errors;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
rules.getRules = getRules;

var applicability = {};

Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined ||
        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
applicability.shouldUseRule = shouldUseRule;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
	const rules_1 = rules;
	const applicability_1 = applicability;
	const errors_1 = errors;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType = exports.DataType || (exports.DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
	              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
	              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
	              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
} (dataType));

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code;
	hasRequiredCode = 1;
	Object.defineProperty(code, "__esModule", { value: true });
	code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	const names_1 = requireNames();
	const util_2 = util$1;
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code.validateUnion = validateUnion;
	
	return code;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = errors;
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve$1 = {};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var jsonSchemaTraverse = {exports: {}};

var traverse$1 = jsonSchemaTraverse.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || (opts.allKeys && !(key in traverse$1.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

var uri_all = {exports: {}};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

(function (module, exports) {
	(function (global, factory) {
		factory(exports) ;
	}(commonjsGlobal, (function (exports) {
	function merge() {
	    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
	        sets[_key] = arguments[_key];
	    }

	    if (sets.length > 1) {
	        sets[0] = sets[0].slice(0, -1);
	        var xl = sets.length - 1;
	        for (var x = 1; x < xl; ++x) {
	            sets[x] = sets[x].slice(1, -1);
	        }
	        sets[xl] = sets[xl].slice(1);
	        return sets.join('');
	    } else {
	        return sets[0];
	    }
	}
	function subexp(str) {
	    return "(?:" + str + ")";
	}
	function typeOf(o) {
	    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
	}
	function toUpperCase(str) {
	    return str.toUpperCase();
	}
	function toArray(obj) {
	    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
	}
	function assign(target, source) {
	    var obj = target;
	    if (source) {
	        for (var key in source) {
	            obj[key] = source[key];
	        }
	    }
	    return obj;
	}

	function buildExps(isIRI) {
	    var ALPHA$$ = "[A-Za-z]",
	        DIGIT$$ = "[0-9]",
	        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
	        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
	        //expanded
	    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
	        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
	        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
	        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
	        //subset, excludes bidi control characters
	    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
	        //subset
	    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
	        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
	        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
	        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
	        //relaxed parsing rules
	    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
	        H16$ = subexp(HEXDIG$$ + "{1,4}"),
	        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
	        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
	        //                           6( h16 ":" ) ls32
	    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
	        //                      "::" 5( h16 ":" ) ls32
	    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
	        //[               h16 ] "::" 4( h16 ":" ) ls32
	    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
	        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
	    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
	        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
	    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
	        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
	    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
	        //[ *4( h16 ":" ) h16 ] "::"              ls32
	    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
	        //[ *5( h16 ":" ) h16 ] "::"              h16
	    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
	        //[ *6( h16 ":" ) h16 ] "::"
	    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
	        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
	        //RFC 6874, with relaxed parsing rules
	    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
	        //RFC 6874
	    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
	        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
	        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
	        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
	    return {
	        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
	        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
	        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
	        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
	        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
	        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
	        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
	        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
	    };
	}
	var URI_PROTOCOL = buildExps(false);

	var IRI_PROTOCOL = buildExps(true);

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();













	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	/** Highest positive signed 32-bit float value */

	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'

	/** Regular expressions */
	var regexPunycode = /^xn--/;
	var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
	var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

	/** Error messages */
	var errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	};

	/** Convenience shortcuts */
	var baseMinusTMin = base - tMin;
	var floor = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error$1(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var result = [];
		var length = array.length;
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		while (counter < length) {
			var value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// It's a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// Low surrogate.
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// It's an unmatched surrogate; only append this code unit, in case the
					// next code unit is the high surrogate of a surrogate pair.
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	var ucs2encode = function ucs2encode(array) {
		return String.fromCodePoint.apply(String, toConsumableArray(array));
	};

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	var basicToDigit = function basicToDigit(codePoint) {
		if (codePoint - 0x30 < 0x0A) {
			return codePoint - 0x16;
		}
		if (codePoint - 0x41 < 0x1A) {
			return codePoint - 0x41;
		}
		if (codePoint - 0x61 < 0x1A) {
			return codePoint - 0x61;
		}
		return base;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	var digitToBasic = function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	var adapt = function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	var decode = function decode(input) {
		// Don't use UCS-2.
		var output = [];
		var inputLength = input.length;
		var i = 0;
		var n = initialN;
		var bias = initialBias;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		var basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (var j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error$1('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			var oldi = i;
			for (var w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error$1('invalid-input');
				}

				var digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error$1('overflow');
				}

				i += digit * w;
				var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				var baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error$1('overflow');
				}

				w *= baseMinusT;
			}

			var out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error$1('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output.
			output.splice(i++, 0, n);
		}

		return String.fromCodePoint.apply(String, output);
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	var encode = function encode(input) {
		var output = [];

		// Convert the input in UCS-2 to an array of Unicode code points.
		input = ucs2decode(input);

		// Cache the length.
		var inputLength = input.length;

		// Initialize the state.
		var n = initialN;
		var delta = 0;
		var bias = initialBias;

		// Handle the basic code points.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _currentValue2 = _step.value;

				if (_currentValue2 < 0x80) {
					output.push(stringFromCharCode(_currentValue2));
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		var basicLength = output.length;
		var handledCPCount = basicLength;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string with a delimiter unless it's empty.
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			var m = maxInt;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var currentValue = _step2.value;

					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error$1('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _currentValue = _step3.value;

					if (_currentValue < n && ++delta > maxInt) {
						error$1('overflow');
					}
					if (_currentValue == n) {
						// Represent delta as a generalized variable-length integer.
						var q = delta;
						for (var k = base;; /* no condition */k += base) {
							var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							var qMinusT = q - t;
							var baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	};

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	var toUnicode = function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	};

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	var toASCII = function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	};

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	var punycode = {
		/**
	  * A string representing the current Punycode.js version number.
	  * @memberOf punycode
	  * @type String
	  */
		'version': '2.1.0',
		/**
	  * An object of methods to convert from JavaScript's internal character
	  * representation (UCS-2) to Unicode code points, and back.
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode
	  * @type Object
	  */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/**
	 * URI.js
	 *
	 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
	 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	 * @see http://github.com/garycourt/uri-js
	 */
	/**
	 * Copyright 2011 Gary Court. All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification, are
	 * permitted provided that the following conditions are met:
	 *
	 *    1. Redistributions of source code must retain the above copyright notice, this list of
	 *       conditions and the following disclaimer.
	 *
	 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
	 *       of conditions and the following disclaimer in the documentation and/or other materials
	 *       provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
	 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
	 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * The views and conclusions contained in the software and documentation are those of the
	 * authors and should not be interpreted as representing official policies, either expressed
	 * or implied, of Gary Court.
	 */
	var SCHEMES = {};
	function pctEncChar(chr) {
	    var c = chr.charCodeAt(0);
	    var e = void 0;
	    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
	    return e;
	}
	function pctDecChars(str) {
	    var newStr = "";
	    var i = 0;
	    var il = str.length;
	    while (i < il) {
	        var c = parseInt(str.substr(i + 1, 2), 16);
	        if (c < 128) {
	            newStr += String.fromCharCode(c);
	            i += 3;
	        } else if (c >= 194 && c < 224) {
	            if (il - i >= 6) {
	                var c2 = parseInt(str.substr(i + 4, 2), 16);
	                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
	            } else {
	                newStr += str.substr(i, 6);
	            }
	            i += 6;
	        } else if (c >= 224) {
	            if (il - i >= 9) {
	                var _c = parseInt(str.substr(i + 4, 2), 16);
	                var c3 = parseInt(str.substr(i + 7, 2), 16);
	                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
	            } else {
	                newStr += str.substr(i, 9);
	            }
	            i += 9;
	        } else {
	            newStr += str.substr(i, 3);
	            i += 3;
	        }
	    }
	    return newStr;
	}
	function _normalizeComponentEncoding(components, protocol) {
	    function decodeUnreserved(str) {
	        var decStr = pctDecChars(str);
	        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
	    }
	    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
	    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    return components;
	}

	function _stripLeadingZeros(str) {
	    return str.replace(/^0*(.*)/, "$1") || "0";
	}
	function _normalizeIPv4(host, protocol) {
	    var matches = host.match(protocol.IPV4ADDRESS) || [];

	    var _matches = slicedToArray(matches, 2),
	        address = _matches[1];

	    if (address) {
	        return address.split(".").map(_stripLeadingZeros).join(".");
	    } else {
	        return host;
	    }
	}
	function _normalizeIPv6(host, protocol) {
	    var matches = host.match(protocol.IPV6ADDRESS) || [];

	    var _matches2 = slicedToArray(matches, 3),
	        address = _matches2[1],
	        zone = _matches2[2];

	    if (address) {
	        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
	            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
	            last = _address$toLowerCase$2[0],
	            first = _address$toLowerCase$2[1];

	        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
	        var lastFields = last.split(":").map(_stripLeadingZeros);
	        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
	        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
	        var lastFieldsStart = lastFields.length - fieldCount;
	        var fields = Array(fieldCount);
	        for (var x = 0; x < fieldCount; ++x) {
	            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
	        }
	        if (isLastFieldIPv4Address) {
	            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
	        }
	        var allZeroFields = fields.reduce(function (acc, field, index) {
	            if (!field || field === "0") {
	                var lastLongest = acc[acc.length - 1];
	                if (lastLongest && lastLongest.index + lastLongest.length === index) {
	                    lastLongest.length++;
	                } else {
	                    acc.push({ index: index, length: 1 });
	                }
	            }
	            return acc;
	        }, []);
	        var longestZeroFields = allZeroFields.sort(function (a, b) {
	            return b.length - a.length;
	        })[0];
	        var newHost = void 0;
	        if (longestZeroFields && longestZeroFields.length > 1) {
	            var newFirst = fields.slice(0, longestZeroFields.index);
	            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
	            newHost = newFirst.join(":") + "::" + newLast.join(":");
	        } else {
	            newHost = fields.join(":");
	        }
	        if (zone) {
	            newHost += "%" + zone;
	        }
	        return newHost;
	    } else {
	        return host;
	    }
	}
	var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
	var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
	function parse(uriString) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var components = {};
	    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
	    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
	    var matches = uriString.match(URI_PARSE);
	    if (matches) {
	        if (NO_MATCH_IS_UNDEFINED) {
	            //store each component
	            components.scheme = matches[1];
	            components.userinfo = matches[3];
	            components.host = matches[4];
	            components.port = parseInt(matches[5], 10);
	            components.path = matches[6] || "";
	            components.query = matches[7];
	            components.fragment = matches[8];
	            //fix port number
	            if (isNaN(components.port)) {
	                components.port = matches[5];
	            }
	        } else {
	            //IE FIX for improper RegExp matching
	            //store each component
	            components.scheme = matches[1] || undefined;
	            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
	            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
	            components.port = parseInt(matches[5], 10);
	            components.path = matches[6] || "";
	            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
	            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
	            //fix port number
	            if (isNaN(components.port)) {
	                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
	            }
	        }
	        if (components.host) {
	            //normalize IP hosts
	            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
	        }
	        //determine reference type
	        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
	            components.reference = "same-document";
	        } else if (components.scheme === undefined) {
	            components.reference = "relative";
	        } else if (components.fragment === undefined) {
	            components.reference = "absolute";
	        } else {
	            components.reference = "uri";
	        }
	        //check for reference errors
	        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
	            components.error = components.error || "URI is not a " + options.reference + " reference.";
	        }
	        //find scheme handler
	        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
	        //check if scheme can't handle IRIs
	        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	            //if host component is a domain name
	            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
	                //convert Unicode IDN -> ASCII IDN
	                try {
	                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
	                } catch (e) {
	                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
	                }
	            }
	            //convert IRI -> URI
	            _normalizeComponentEncoding(components, URI_PROTOCOL);
	        } else {
	            //normalize encodings
	            _normalizeComponentEncoding(components, protocol);
	        }
	        //perform scheme specific parsing
	        if (schemeHandler && schemeHandler.parse) {
	            schemeHandler.parse(components, options);
	        }
	    } else {
	        components.error = components.error || "URI can not be parsed.";
	    }
	    return components;
	}

	function _recomposeAuthority(components, options) {
	    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
	    var uriTokens = [];
	    if (components.userinfo !== undefined) {
	        uriTokens.push(components.userinfo);
	        uriTokens.push("@");
	    }
	    if (components.host !== undefined) {
	        //normalize IP hosts, add brackets and escape zone separator for IPv6
	        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
	            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
	        }));
	    }
	    if (typeof components.port === "number" || typeof components.port === "string") {
	        uriTokens.push(":");
	        uriTokens.push(String(components.port));
	    }
	    return uriTokens.length ? uriTokens.join("") : undefined;
	}

	var RDS1 = /^\.\.?\//;
	var RDS2 = /^\/\.(\/|$)/;
	var RDS3 = /^\/\.\.(\/|$)/;
	var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
	function removeDotSegments(input) {
	    var output = [];
	    while (input.length) {
	        if (input.match(RDS1)) {
	            input = input.replace(RDS1, "");
	        } else if (input.match(RDS2)) {
	            input = input.replace(RDS2, "/");
	        } else if (input.match(RDS3)) {
	            input = input.replace(RDS3, "/");
	            output.pop();
	        } else if (input === "." || input === "..") {
	            input = "";
	        } else {
	            var im = input.match(RDS5);
	            if (im) {
	                var s = im[0];
	                input = input.slice(s.length);
	                output.push(s);
	            } else {
	                throw new Error("Unexpected dot segment condition");
	            }
	        }
	    }
	    return output.join("");
	}

	function serialize(components) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
	    var uriTokens = [];
	    //find scheme handler
	    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
	    //perform scheme specific serialization
	    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
	    if (components.host) {
	        //if host component is an IPv6 address
	        if (protocol.IPV6ADDRESS.test(components.host)) ;
	        //TODO: normalize IPv6 address as per RFC 5952

	        //if host component is a domain name
	        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
	                //convert IDN via punycode
	                try {
	                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
	                } catch (e) {
	                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
	                }
	            }
	    }
	    //normalize encoding
	    _normalizeComponentEncoding(components, protocol);
	    if (options.reference !== "suffix" && components.scheme) {
	        uriTokens.push(components.scheme);
	        uriTokens.push(":");
	    }
	    var authority = _recomposeAuthority(components, options);
	    if (authority !== undefined) {
	        if (options.reference !== "suffix") {
	            uriTokens.push("//");
	        }
	        uriTokens.push(authority);
	        if (components.path && components.path.charAt(0) !== "/") {
	            uriTokens.push("/");
	        }
	    }
	    if (components.path !== undefined) {
	        var s = components.path;
	        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	            s = removeDotSegments(s);
	        }
	        if (authority === undefined) {
	            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
	        }
	        uriTokens.push(s);
	    }
	    if (components.query !== undefined) {
	        uriTokens.push("?");
	        uriTokens.push(components.query);
	    }
	    if (components.fragment !== undefined) {
	        uriTokens.push("#");
	        uriTokens.push(components.fragment);
	    }
	    return uriTokens.join(""); //merge tokens into a string
	}

	function resolveComponents(base, relative) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var skipNormalization = arguments[3];

	    var target = {};
	    if (!skipNormalization) {
	        base = parse(serialize(base, options), options); //normalize base components
	        relative = parse(serialize(relative, options), options); //normalize relative components
	    }
	    options = options || {};
	    if (!options.tolerant && relative.scheme) {
	        target.scheme = relative.scheme;
	        //target.authority = relative.authority;
	        target.userinfo = relative.userinfo;
	        target.host = relative.host;
	        target.port = relative.port;
	        target.path = removeDotSegments(relative.path || "");
	        target.query = relative.query;
	    } else {
	        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	            //target.authority = relative.authority;
	            target.userinfo = relative.userinfo;
	            target.host = relative.host;
	            target.port = relative.port;
	            target.path = removeDotSegments(relative.path || "");
	            target.query = relative.query;
	        } else {
	            if (!relative.path) {
	                target.path = base.path;
	                if (relative.query !== undefined) {
	                    target.query = relative.query;
	                } else {
	                    target.query = base.query;
	                }
	            } else {
	                if (relative.path.charAt(0) === "/") {
	                    target.path = removeDotSegments(relative.path);
	                } else {
	                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	                        target.path = "/" + relative.path;
	                    } else if (!base.path) {
	                        target.path = relative.path;
	                    } else {
	                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
	                    }
	                    target.path = removeDotSegments(target.path);
	                }
	                target.query = relative.query;
	            }
	            //target.authority = base.authority;
	            target.userinfo = base.userinfo;
	            target.host = base.host;
	            target.port = base.port;
	        }
	        target.scheme = base.scheme;
	    }
	    target.fragment = relative.fragment;
	    return target;
	}

	function resolve(baseURI, relativeURI, options) {
	    var schemelessOptions = assign({ scheme: 'null' }, options);
	    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
	}

	function normalize(uri, options) {
	    if (typeof uri === "string") {
	        uri = serialize(parse(uri, options), options);
	    } else if (typeOf(uri) === "object") {
	        uri = parse(serialize(uri, options), options);
	    }
	    return uri;
	}

	function equal(uriA, uriB, options) {
	    if (typeof uriA === "string") {
	        uriA = serialize(parse(uriA, options), options);
	    } else if (typeOf(uriA) === "object") {
	        uriA = serialize(uriA, options);
	    }
	    if (typeof uriB === "string") {
	        uriB = serialize(parse(uriB, options), options);
	    } else if (typeOf(uriB) === "object") {
	        uriB = serialize(uriB, options);
	    }
	    return uriA === uriB;
	}

	function escapeComponent(str, options) {
	    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
	}

	function unescapeComponent(str, options) {
	    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
	}

	var handler = {
	    scheme: "http",
	    domainHost: true,
	    parse: function parse(components, options) {
	        //report missing host
	        if (!components.host) {
	            components.error = components.error || "HTTP URIs must have a host.";
	        }
	        return components;
	    },
	    serialize: function serialize(components, options) {
	        var secure = String(components.scheme).toLowerCase() === "https";
	        //normalize the default port
	        if (components.port === (secure ? 443 : 80) || components.port === "") {
	            components.port = undefined;
	        }
	        //normalize the empty path
	        if (!components.path) {
	            components.path = "/";
	        }
	        //NOTE: We do not parse query strings for HTTP URIs
	        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	        //and not the HTTP spec.
	        return components;
	    }
	};

	var handler$1 = {
	    scheme: "https",
	    domainHost: handler.domainHost,
	    parse: handler.parse,
	    serialize: handler.serialize
	};

	function isSecure(wsComponents) {
	    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
	}
	//RFC 6455
	var handler$2 = {
	    scheme: "ws",
	    domainHost: true,
	    parse: function parse(components, options) {
	        var wsComponents = components;
	        //indicate if the secure flag is set
	        wsComponents.secure = isSecure(wsComponents);
	        //construct resouce name
	        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	        wsComponents.path = undefined;
	        wsComponents.query = undefined;
	        return wsComponents;
	    },
	    serialize: function serialize(wsComponents, options) {
	        //normalize the default port
	        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
	            wsComponents.port = undefined;
	        }
	        //ensure scheme matches secure flag
	        if (typeof wsComponents.secure === 'boolean') {
	            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
	            wsComponents.secure = undefined;
	        }
	        //reconstruct path from resource name
	        if (wsComponents.resourceName) {
	            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
	                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
	                path = _wsComponents$resourc2[0],
	                query = _wsComponents$resourc2[1];

	            wsComponents.path = path && path !== '/' ? path : undefined;
	            wsComponents.query = query;
	            wsComponents.resourceName = undefined;
	        }
	        //forbid fragment component
	        wsComponents.fragment = undefined;
	        return wsComponents;
	    }
	};

	var handler$3 = {
	    scheme: "wss",
	    domainHost: handler$2.domainHost,
	    parse: handler$2.parse,
	    serialize: handler$2.serialize
	};

	var O = {};
	//RFC 3986
	var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
	var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
	var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
	//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
	//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
	//const WSP$$ = "[\\x20\\x09]";
	//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
	//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
	//const VCHAR$$ = "[\\x21-\\x7E]";
	//const WSP$$ = "[\\x20\\x09]";
	//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
	//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
	//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
	//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
	var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
	var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
	var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
	var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
	var UNRESERVED = new RegExp(UNRESERVED$$, "g");
	var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
	var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
	var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
	var NOT_HFVALUE = NOT_HFNAME;
	function decodeUnreserved(str) {
	    var decStr = pctDecChars(str);
	    return !decStr.match(UNRESERVED) ? str : decStr;
	}
	var handler$4 = {
	    scheme: "mailto",
	    parse: function parse$$1(components, options) {
	        var mailtoComponents = components;
	        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
	        mailtoComponents.path = undefined;
	        if (mailtoComponents.query) {
	            var unknownHeaders = false;
	            var headers = {};
	            var hfields = mailtoComponents.query.split("&");
	            for (var x = 0, xl = hfields.length; x < xl; ++x) {
	                var hfield = hfields[x].split("=");
	                switch (hfield[0]) {
	                    case "to":
	                        var toAddrs = hfield[1].split(",");
	                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
	                            to.push(toAddrs[_x]);
	                        }
	                        break;
	                    case "subject":
	                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
	                        break;
	                    case "body":
	                        mailtoComponents.body = unescapeComponent(hfield[1], options);
	                        break;
	                    default:
	                        unknownHeaders = true;
	                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
	                        break;
	                }
	            }
	            if (unknownHeaders) mailtoComponents.headers = headers;
	        }
	        mailtoComponents.query = undefined;
	        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
	            var addr = to[_x2].split("@");
	            addr[0] = unescapeComponent(addr[0]);
	            if (!options.unicodeSupport) {
	                //convert Unicode IDN -> ASCII IDN
	                try {
	                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
	                } catch (e) {
	                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
	                }
	            } else {
	                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
	            }
	            to[_x2] = addr.join("@");
	        }
	        return mailtoComponents;
	    },
	    serialize: function serialize$$1(mailtoComponents, options) {
	        var components = mailtoComponents;
	        var to = toArray(mailtoComponents.to);
	        if (to) {
	            for (var x = 0, xl = to.length; x < xl; ++x) {
	                var toAddr = String(to[x]);
	                var atIdx = toAddr.lastIndexOf("@");
	                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
	                var domain = toAddr.slice(atIdx + 1);
	                //convert IDN via punycode
	                try {
	                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
	                } catch (e) {
	                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
	                }
	                to[x] = localPart + "@" + domain;
	            }
	            components.path = to.join(",");
	        }
	        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
	        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
	        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
	        var fields = [];
	        for (var name in headers) {
	            if (headers[name] !== O[name]) {
	                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
	            }
	        }
	        if (fields.length) {
	            components.query = fields.join("&");
	        }
	        return components;
	    }
	};

	var URN_PARSE = /^([^\:]+)\:(.*)/;
	//RFC 2141
	var handler$5 = {
	    scheme: "urn",
	    parse: function parse$$1(components, options) {
	        var matches = components.path && components.path.match(URN_PARSE);
	        var urnComponents = components;
	        if (matches) {
	            var scheme = options.scheme || urnComponents.scheme || "urn";
	            var nid = matches[1].toLowerCase();
	            var nss = matches[2];
	            var urnScheme = scheme + ":" + (options.nid || nid);
	            var schemeHandler = SCHEMES[urnScheme];
	            urnComponents.nid = nid;
	            urnComponents.nss = nss;
	            urnComponents.path = undefined;
	            if (schemeHandler) {
	                urnComponents = schemeHandler.parse(urnComponents, options);
	            }
	        } else {
	            urnComponents.error = urnComponents.error || "URN can not be parsed.";
	        }
	        return urnComponents;
	    },
	    serialize: function serialize$$1(urnComponents, options) {
	        var scheme = options.scheme || urnComponents.scheme || "urn";
	        var nid = urnComponents.nid;
	        var urnScheme = scheme + ":" + (options.nid || nid);
	        var schemeHandler = SCHEMES[urnScheme];
	        if (schemeHandler) {
	            urnComponents = schemeHandler.serialize(urnComponents, options);
	        }
	        var uriComponents = urnComponents;
	        var nss = urnComponents.nss;
	        uriComponents.path = (nid || options.nid) + ":" + nss;
	        return uriComponents;
	    }
	};

	var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
	//RFC 4122
	var handler$6 = {
	    scheme: "urn:uuid",
	    parse: function parse(urnComponents, options) {
	        var uuidComponents = urnComponents;
	        uuidComponents.uuid = uuidComponents.nss;
	        uuidComponents.nss = undefined;
	        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
	            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
	        }
	        return uuidComponents;
	    },
	    serialize: function serialize(uuidComponents, options) {
	        var urnComponents = uuidComponents;
	        //normalize UUID
	        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
	        return urnComponents;
	    }
	};

	SCHEMES[handler.scheme] = handler;
	SCHEMES[handler$1.scheme] = handler$1;
	SCHEMES[handler$2.scheme] = handler$2;
	SCHEMES[handler$3.scheme] = handler$3;
	SCHEMES[handler$4.scheme] = handler$4;
	SCHEMES[handler$5.scheme] = handler$5;
	SCHEMES[handler$6.scheme] = handler$6;

	exports.SCHEMES = SCHEMES;
	exports.pctEncChar = pctEncChar;
	exports.pctDecChars = pctDecChars;
	exports.parse = parse;
	exports.removeDotSegments = removeDotSegments;
	exports.serialize = serialize;
	exports.resolveComponents = resolveComponents;
	exports.resolve = resolve;
	exports.normalize = normalize;
	exports.equal = equal;
	exports.escapeComponent = escapeComponent;
	exports.unescapeComponent = unescapeComponent;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));
	
} (uri_all, uri_all.exports));

Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util$1;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverse.exports;
const URI$1 = uri_all.exports;
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            (0, util_1$l.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = URI$1.parse(id);
    return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
    return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI$1.resolve(baseId, id);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
        return {};
    const { schemaId } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(schId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
            baseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId;
        function addRef(ref) {
            ref = normalizeId(baseId ? URI$1.resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal$2(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
resolve$1.getSchemaRefs = getSchemaRefs;

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = dataType;
	const applicability_1 = applicability;
	const dataType_2 = dataType;
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = resolve$1;
	const util_1 = util$1;
	const errors_1 = errors;
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
    constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
    }
}
validation_error.default = ValidationError;

var ref_error = {};

Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
    constructor(baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1$1.resolveUrl)(baseId, ref);
        this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(this.missingRef));
    }
}
ref_error.default = MissingRefError;

var compile$1 = {};

Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
const codegen_1$m = requireCodegen();
const validation_error_1 = validation_error;
const names_1$2 = requireNames();
const resolve_1 = resolve$1;
const util_1$k = util$1;
const validate_1$1 = requireValidate();
const URI = uri_all.exports;
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
compile$1.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = (0, resolve_1.getFullPath)(sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1$m._) `require("ajv/dist/runtime/validation_error").default`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1$2.default.data,
        parentData: names_1$2.default.parentData,
        parentDataProperty: names_1$2.default.parentDataProperty,
        dataNames: [names_1$2.default.data],
        dataPathArr: [codegen_1$m.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1$m.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1$m._) `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        (0, validate_1$1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1$m.Name ? undefined : props,
                items: items instanceof codegen_1$m.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1$m.Name,
                dynamicItems: items instanceof codegen_1$m.Name,
            };
            if (validate.source)
                validate.source.evaluated = (0, codegen_1$m.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
compile$1.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        const { schemaId } = this.opts;
        if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
compile$1.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
compile$1.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = URI.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(p);
    let baseId = (0, resolve_1.getFullPath)(root.baseId);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
            baseId = (0, resolve_1.resolveUrl)(baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
compile$1.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
            return;
        const partSchema = schema[(0, util_1$k.unescapeFragment)(part)];
        if (partSchema === undefined)
            return;
        schema = partSchema;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(baseId, schId);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$1 = "object";
var required$1 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties$1
};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	const validation_error_1 = validation_error;
	const ref_error_1 = ref_error;
	const rules_1 = rules;
	const compile_1 = compile$1;
	const codegen_2 = requireCodegen();
	const resolve_1 = resolve$1;
	const dataType_1 = dataType;
	const util_1 = util$1;
	const $dataRefSchema = require$$9;
	const defaultRegExp = (str, flags) => new RegExp(str, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
	const EXT_SCOPE_NAMES = new Set([
	    "validate",
	    "serialize",
	    "parse",
	    "wrapper",
	    "root",
	    "schema",
	    "keyword",
	    "pattern",
	    "formats",
	    "validate$data",
	    "func",
	    "obj",
	    "Error",
	]);
	const removedOptions = {
	    errorDataPath: "",
	    format: "`validateFormats: false` can be used instead.",
	    nullable: '"nullable" keyword is supported by default.',
	    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
	    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
	    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
	    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
	    sourceCode: "Use option `code: {source: true}`",
	    strictDefaults: "It is default now, see option `strict`.",
	    strictKeywords: "It is default now, see option `strict`.",
	    uniqueItems: '"uniqueItems" keyword is always validated.',
	    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
	    cache: "Map is used as cache, schema object as key.",
	    serialize: "Map is used as cache, schema object as key.",
	    ajvErrors: "It is default now.",
	};
	const deprecatedOptions = {
	    ignoreKeywordsWithRef: "",
	    jsPropertySyntax: "",
	    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
	};
	const MAX_EXPRESSION = 200;
	// eslint-disable-next-line complexity
	function requiredOptions(o) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
	    const s = o.strict;
	    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
	    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
	    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
	    return {
	        strictSchema: (_e = (_d = o.strictSchema) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
	        strictNumbers: (_g = (_f = o.strictNumbers) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : true,
	        strictTypes: (_j = (_h = o.strictTypes) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
	        strictTuples: (_l = (_k = o.strictTuples) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : "log",
	        strictRequired: (_o = (_m = o.strictRequired) !== null && _m !== void 0 ? _m : s) !== null && _o !== void 0 ? _o : false,
	        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
	        loopRequired: (_p = o.loopRequired) !== null && _p !== void 0 ? _p : MAX_EXPRESSION,
	        loopEnum: (_q = o.loopEnum) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
	        meta: (_r = o.meta) !== null && _r !== void 0 ? _r : true,
	        messages: (_s = o.messages) !== null && _s !== void 0 ? _s : true,
	        inlineRefs: (_t = o.inlineRefs) !== null && _t !== void 0 ? _t : true,
	        schemaId: (_u = o.schemaId) !== null && _u !== void 0 ? _u : "$id",
	        addUsedSchema: (_v = o.addUsedSchema) !== null && _v !== void 0 ? _v : true,
	        validateSchema: (_w = o.validateSchema) !== null && _w !== void 0 ? _w : true,
	        validateFormats: (_x = o.validateFormats) !== null && _x !== void 0 ? _x : true,
	        unicodeRegExp: (_y = o.unicodeRegExp) !== null && _y !== void 0 ? _y : true,
	        int32range: (_z = o.int32range) !== null && _z !== void 0 ? _z : true,
	    };
	}
	class Ajv {
	    constructor(opts = {}) {
	        this.schemas = {};
	        this.refs = {};
	        this.formats = {};
	        this._compilations = new Set();
	        this._loading = {};
	        this._cache = new Map();
	        opts = this.opts = { ...opts, ...requiredOptions(opts) };
	        const { es5, lines } = this.opts.code;
	        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
	        this.logger = getLogger(opts.logger);
	        const formatOpt = opts.validateFormats;
	        opts.validateFormats = false;
	        this.RULES = (0, rules_1.getRules)();
	        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
	        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
	        this._metaOpts = getMetaSchemaOptions.call(this);
	        if (opts.formats)
	            addInitialFormats.call(this);
	        this._addVocabularies();
	        this._addDefaultMetaSchema();
	        if (opts.keywords)
	            addInitialKeywords.call(this, opts.keywords);
	        if (typeof opts.meta == "object")
	            this.addMetaSchema(opts.meta);
	        addInitialSchemas.call(this);
	        opts.validateFormats = formatOpt;
	    }
	    _addVocabularies() {
	        this.addKeyword("$async");
	    }
	    _addDefaultMetaSchema() {
	        const { $data, meta, schemaId } = this.opts;
	        let _dataRefSchema = $dataRefSchema;
	        if (schemaId === "id") {
	            _dataRefSchema = { ...$dataRefSchema };
	            _dataRefSchema.id = _dataRefSchema.$id;
	            delete _dataRefSchema.$id;
	        }
	        if (meta && $data)
	            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
	    }
	    defaultMeta() {
	        const { meta, schemaId } = this.opts;
	        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
	    }
	    validate(schemaKeyRef, // key, ref or schema object
	    data // to be validated
	    ) {
	        let v;
	        if (typeof schemaKeyRef == "string") {
	            v = this.getSchema(schemaKeyRef);
	            if (!v)
	                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
	        }
	        else {
	            v = this.compile(schemaKeyRef);
	        }
	        const valid = v(data);
	        if (!("$async" in v))
	            this.errors = v.errors;
	        return valid;
	    }
	    compile(schema, _meta) {
	        const sch = this._addSchema(schema, _meta);
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    compileAsync(schema, meta) {
	        if (typeof this.opts.loadSchema != "function") {
	            throw new Error("options.loadSchema should be a function");
	        }
	        const { loadSchema } = this.opts;
	        return runCompileAsync.call(this, schema, meta);
	        async function runCompileAsync(_schema, _meta) {
	            await loadMetaSchema.call(this, _schema.$schema);
	            const sch = this._addSchema(_schema, _meta);
	            return sch.validate || _compileAsync.call(this, sch);
	        }
	        async function loadMetaSchema($ref) {
	            if ($ref && !this.getSchema($ref)) {
	                await runCompileAsync.call(this, { $ref }, true);
	            }
	        }
	        async function _compileAsync(sch) {
	            try {
	                return this._compileSchemaEnv(sch);
	            }
	            catch (e) {
	                if (!(e instanceof ref_error_1.default))
	                    throw e;
	                checkLoaded.call(this, e);
	                await loadMissingSchema.call(this, e.missingSchema);
	                return _compileAsync.call(this, sch);
	            }
	        }
	        function checkLoaded({ missingSchema: ref, missingRef }) {
	            if (this.refs[ref]) {
	                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
	            }
	        }
	        async function loadMissingSchema(ref) {
	            const _schema = await _loadSchema.call(this, ref);
	            if (!this.refs[ref])
	                await loadMetaSchema.call(this, _schema.$schema);
	            if (!this.refs[ref])
	                this.addSchema(_schema, ref, meta);
	        }
	        async function _loadSchema(ref) {
	            const p = this._loading[ref];
	            if (p)
	                return p;
	            try {
	                return await (this._loading[ref] = loadSchema(ref));
	            }
	            finally {
	                delete this._loading[ref];
	            }
	        }
	    }
	    // Adds schema to the instance
	    addSchema(schema, // If array is passed, `key` will be ignored
	    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
	    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
	    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
	    ) {
	        if (Array.isArray(schema)) {
	            for (const sch of schema)
	                this.addSchema(sch, undefined, _meta, _validateSchema);
	            return this;
	        }
	        let id;
	        if (typeof schema === "object") {
	            const { schemaId } = this.opts;
	            id = schema[schemaId];
	            if (id !== undefined && typeof id != "string") {
	                throw new Error(`schema ${schemaId} must be string`);
	            }
	        }
	        key = (0, resolve_1.normalizeId)(key || id);
	        this._checkUnique(key);
	        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
	        return this;
	    }
	    // Add schema that will be used to validate other schemas
	    // options in META_IGNORE_OPTIONS are alway set to false
	    addMetaSchema(schema, key, // schema key
	    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
	    ) {
	        this.addSchema(schema, key, true, _validateSchema);
	        return this;
	    }
	    //  Validate schema against its meta-schema
	    validateSchema(schema, throwOrLogError) {
	        if (typeof schema == "boolean")
	            return true;
	        let $schema;
	        $schema = schema.$schema;
	        if ($schema !== undefined && typeof $schema != "string") {
	            throw new Error("$schema must be a string");
	        }
	        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
	        if (!$schema) {
	            this.logger.warn("meta-schema not available");
	            this.errors = null;
	            return true;
	        }
	        const valid = this.validate($schema, schema);
	        if (!valid && throwOrLogError) {
	            const message = "schema is invalid: " + this.errorsText();
	            if (this.opts.validateSchema === "log")
	                this.logger.error(message);
	            else
	                throw new Error(message);
	        }
	        return valid;
	    }
	    // Get compiled schema by `key` or `ref`.
	    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
	    getSchema(keyRef) {
	        let sch;
	        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
	            keyRef = sch;
	        if (sch === undefined) {
	            const { schemaId } = this.opts;
	            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
	            sch = compile_1.resolveSchema.call(this, root, keyRef);
	            if (!sch)
	                return;
	            this.refs[keyRef] = sch;
	        }
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    // Remove cached schema(s).
	    // If no parameter is passed all schemas but meta-schemas are removed.
	    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
	    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
	    removeSchema(schemaKeyRef) {
	        if (schemaKeyRef instanceof RegExp) {
	            this._removeAllSchemas(this.schemas, schemaKeyRef);
	            this._removeAllSchemas(this.refs, schemaKeyRef);
	            return this;
	        }
	        switch (typeof schemaKeyRef) {
	            case "undefined":
	                this._removeAllSchemas(this.schemas);
	                this._removeAllSchemas(this.refs);
	                this._cache.clear();
	                return this;
	            case "string": {
	                const sch = getSchEnv.call(this, schemaKeyRef);
	                if (typeof sch == "object")
	                    this._cache.delete(sch.schema);
	                delete this.schemas[schemaKeyRef];
	                delete this.refs[schemaKeyRef];
	                return this;
	            }
	            case "object": {
	                const cacheKey = schemaKeyRef;
	                this._cache.delete(cacheKey);
	                let id = schemaKeyRef[this.opts.schemaId];
	                if (id) {
	                    id = (0, resolve_1.normalizeId)(id);
	                    delete this.schemas[id];
	                    delete this.refs[id];
	                }
	                return this;
	            }
	            default:
	                throw new Error("ajv.removeSchema: invalid parameter");
	        }
	    }
	    // add "vocabulary" - a collection of keywords
	    addVocabulary(definitions) {
	        for (const def of definitions)
	            this.addKeyword(def);
	        return this;
	    }
	    addKeyword(kwdOrDef, def // deprecated
	    ) {
	        let keyword;
	        if (typeof kwdOrDef == "string") {
	            keyword = kwdOrDef;
	            if (typeof def == "object") {
	                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
	                def.keyword = keyword;
	            }
	        }
	        else if (typeof kwdOrDef == "object" && def === undefined) {
	            def = kwdOrDef;
	            keyword = def.keyword;
	            if (Array.isArray(keyword) && !keyword.length) {
	                throw new Error("addKeywords: keyword must be string or non-empty array");
	            }
	        }
	        else {
	            throw new Error("invalid addKeywords parameters");
	        }
	        checkKeyword.call(this, keyword, def);
	        if (!def) {
	            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
	            return this;
	        }
	        keywordMetaschema.call(this, def);
	        const definition = {
	            ...def,
	            type: (0, dataType_1.getJSONTypes)(def.type),
	            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
	        };
	        (0, util_1.eachItem)(keyword, definition.type.length === 0
	            ? (k) => addRule.call(this, k, definition)
	            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
	        return this;
	    }
	    getKeyword(keyword) {
	        const rule = this.RULES.all[keyword];
	        return typeof rule == "object" ? rule.definition : !!rule;
	    }
	    // Remove keyword
	    removeKeyword(keyword) {
	        // TODO return type should be Ajv
	        const { RULES } = this;
	        delete RULES.keywords[keyword];
	        delete RULES.all[keyword];
	        for (const group of RULES.rules) {
	            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
	            if (i >= 0)
	                group.rules.splice(i, 1);
	        }
	        return this;
	    }
	    // Add format
	    addFormat(name, format) {
	        if (typeof format == "string")
	            format = new RegExp(format);
	        this.formats[name] = format;
	        return this;
	    }
	    errorsText(errors = this.errors, // optional array of validation errors
	    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
	    ) {
	        if (!errors || errors.length === 0)
	            return "No errors";
	        return errors
	            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
	            .reduce((text, msg) => text + separator + msg);
	    }
	    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
	        const rules = this.RULES.all;
	        metaSchema = JSON.parse(JSON.stringify(metaSchema));
	        for (const jsonPointer of keywordsJsonPointers) {
	            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
	            let keywords = metaSchema;
	            for (const seg of segments)
	                keywords = keywords[seg];
	            for (const key in rules) {
	                const rule = rules[key];
	                if (typeof rule != "object")
	                    continue;
	                const { $data } = rule.definition;
	                const schema = keywords[key];
	                if ($data && schema)
	                    keywords[key] = schemaOrData(schema);
	            }
	        }
	        return metaSchema;
	    }
	    _removeAllSchemas(schemas, regex) {
	        for (const keyRef in schemas) {
	            const sch = schemas[keyRef];
	            if (!regex || regex.test(keyRef)) {
	                if (typeof sch == "string") {
	                    delete schemas[keyRef];
	                }
	                else if (sch && !sch.meta) {
	                    this._cache.delete(sch.schema);
	                    delete schemas[keyRef];
	                }
	            }
	        }
	    }
	    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
	        let id;
	        const { schemaId } = this.opts;
	        if (typeof schema == "object") {
	            id = schema[schemaId];
	        }
	        else {
	            if (this.opts.jtd)
	                throw new Error("schema must be object");
	            else if (typeof schema != "boolean")
	                throw new Error("schema must be object or boolean");
	        }
	        let sch = this._cache.get(schema);
	        if (sch !== undefined)
	            return sch;
	        baseId = (0, resolve_1.normalizeId)(id || baseId);
	        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
	        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
	        this._cache.set(sch.schema, sch);
	        if (addSchema && !baseId.startsWith("#")) {
	            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
	            if (baseId)
	                this._checkUnique(baseId);
	            this.refs[baseId] = sch;
	        }
	        if (validateSchema)
	            this.validateSchema(schema, true);
	        return sch;
	    }
	    _checkUnique(id) {
	        if (this.schemas[id] || this.refs[id]) {
	            throw new Error(`schema with key or id "${id}" already exists`);
	        }
	    }
	    _compileSchemaEnv(sch) {
	        if (sch.meta)
	            this._compileMetaSchema(sch);
	        else
	            compile_1.compileSchema.call(this, sch);
	        /* istanbul ignore if */
	        if (!sch.validate)
	            throw new Error("ajv implementation error");
	        return sch.validate;
	    }
	    _compileMetaSchema(sch) {
	        const currentOpts = this.opts;
	        this.opts = this._metaOpts;
	        try {
	            compile_1.compileSchema.call(this, sch);
	        }
	        finally {
	            this.opts = currentOpts;
	        }
	    }
	}
	exports.default = Ajv;
	Ajv.ValidationError = validation_error_1.default;
	Ajv.MissingRefError = ref_error_1.default;
	function checkOptions(checkOpts, options, msg, log = "error") {
	    for (const key in checkOpts) {
	        const opt = key;
	        if (opt in options)
	            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
	    }
	}
	function getSchEnv(keyRef) {
	    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
	    return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
	    const optsSchemas = this.opts.schemas;
	    if (!optsSchemas)
	        return;
	    if (Array.isArray(optsSchemas))
	        this.addSchema(optsSchemas);
	    else
	        for (const key in optsSchemas)
	            this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
	    for (const name in this.opts.formats) {
	        const format = this.opts.formats[name];
	        if (format)
	            this.addFormat(name, format);
	    }
	}
	function addInitialKeywords(defs) {
	    if (Array.isArray(defs)) {
	        this.addVocabulary(defs);
	        return;
	    }
	    this.logger.warn("keywords option as map is deprecated, pass array");
	    for (const keyword in defs) {
	        const def = defs[keyword];
	        if (!def.keyword)
	            def.keyword = keyword;
	        this.addKeyword(def);
	    }
	}
	function getMetaSchemaOptions() {
	    const metaOpts = { ...this.opts };
	    for (const opt of META_IGNORE_OPTIONS)
	        delete metaOpts[opt];
	    return metaOpts;
	}
	const noLogs = { log() { }, warn() { }, error() { } };
	function getLogger(logger) {
	    if (logger === false)
	        return noLogs;
	    if (logger === undefined)
	        return console;
	    if (logger.log && logger.warn && logger.error)
	        return logger;
	    throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def) {
	    const { RULES } = this;
	    (0, util_1.eachItem)(keyword, (kwd) => {
	        if (RULES.keywords[kwd])
	            throw new Error(`Keyword ${kwd} is already defined`);
	        if (!KEYWORD_NAME.test(kwd))
	            throw new Error(`Keyword ${kwd} has invalid name`);
	    });
	    if (!def)
	        return;
	    if (def.$data && !("code" in def || "validate" in def)) {
	        throw new Error('$data keyword must have "code" or "validate" function');
	    }
	}
	function addRule(keyword, definition, dataType) {
	    var _a;
	    const post = definition === null || definition === void 0 ? void 0 : definition.post;
	    if (dataType && post)
	        throw new Error('keyword with "post" flag cannot have "type"');
	    const { RULES } = this;
	    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
	    if (!ruleGroup) {
	        ruleGroup = { type: dataType, rules: [] };
	        RULES.rules.push(ruleGroup);
	    }
	    RULES.keywords[keyword] = true;
	    if (!definition)
	        return;
	    const rule = {
	        keyword,
	        definition: {
	            ...definition,
	            type: (0, dataType_1.getJSONTypes)(definition.type),
	            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
	        },
	    };
	    if (definition.before)
	        addBeforeRule.call(this, ruleGroup, rule, definition.before);
	    else
	        ruleGroup.rules.push(rule);
	    RULES.all[keyword] = rule;
	    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
	    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
	    if (i >= 0) {
	        ruleGroup.rules.splice(i, 0, rule);
	    }
	    else {
	        ruleGroup.rules.push(rule);
	        this.logger.warn(`rule ${before} is not defined`);
	    }
	}
	function keywordMetaschema(def) {
	    let { metaSchema } = def;
	    if (metaSchema === undefined)
	        return;
	    if (def.$data && this.opts.$data)
	        metaSchema = schemaOrData(metaSchema);
	    def.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = {
	    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
	};
	function schemaOrData(schema) {
	    return { anyOf: [schema, $dataRef] };
	}
	
} (core$2));

var draft7 = {};

var core$1 = {};

var id = {};

Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
id.default = def$s;

var ref = {};

Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = requireCode();
const codegen_1$l = requireCodegen();
const names_1$1 = requireNames();
const compile_1$1 = compile$1;
const util_1$j = util$1;
const def$r = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1.default(baseId, $ref);
        if (schOrEnv instanceof compile_1$1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1$l._) `${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1$l.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1$l._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code((0, codegen_1$l._) `await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if((0, codegen_1$l._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = (0, codegen_1$l._) `${source}.errors`;
        gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._) `${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1$1.default.errors, (0, codegen_1$l._) `${names_1$1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", (0, codegen_1$l._) `${source}.evaluated.props`);
                it.props = util_1$j.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", (0, codegen_1$l._) `${source}.evaluated.items`);
                it.items = util_1$j.mergeEvaluated.items(gen, items, it.items, codegen_1$l.Name);
            }
        }
    }
}
ref.callRef = callRef;
ref.default = def$r;

Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default,
];
core$1.default = core;

var validation$1 = {};

var limitNumber = {};

Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = requireCodegen();
const ops = codegen_1$k.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error$i = {
    message: ({ keyword, schemaCode }) => (0, codegen_1$k.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1$k._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def$q = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$i,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1$k._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
limitNumber.default = def$q;

var multipleOf = {};

Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = requireCodegen();
const error$h = {
    message: ({ schemaCode }) => (0, codegen_1$j.str) `must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1$j._) `{multipleOf: ${schemaCode}}`,
};
const def$p = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$h,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? (0, codegen_1$j._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1$j._) `${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1$j._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
multipleOf.default = def$p;

var limitLength = {};

var ucs2length$1 = {};

Object.defineProperty(ucs2length$1, "__esModule", { value: true });
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';

Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = requireCodegen();
const util_1$i = util$1;
const ucs2length_1 = ucs2length$1;
const error$g = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1$i.str) `must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1$i._) `{limit: ${schemaCode}}`,
};
const def$o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error$g,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1$i._) `${data}.length` : (0, codegen_1$i._) `${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1$i._) `${len} ${op} ${schemaCode}`);
    },
};
limitLength.default = def$o;

var pattern = {};

Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = requireCode();
const codegen_1$h = requireCodegen();
const error$f = {
    message: ({ schemaCode }) => (0, codegen_1$h.str) `must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$h._) `{pattern: ${schemaCode}}`,
};
const def$n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error$f,
    code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        // TODO regexp should be wrapped in try/catchs
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1$h._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1$h._) `!${regExp}.test(${data})`);
    },
};
pattern.default = def$n;

var limitProperties = {};

Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = requireCodegen();
const error$e = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1$g.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1$g._) `{limit: ${schemaCode}}`,
};
const def$m = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error$e,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
        cxt.fail$data((0, codegen_1$g._) `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
limitProperties.default = def$m;

var required = {};

Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = requireCode();
const codegen_1$f = requireCodegen();
const util_1$h = util$1;
const error$d = {
    message: ({ params: { missingProperty } }) => (0, codegen_1$f.str) `must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1$f._) `{missingProperty: ${missingProperty}}`,
};
const def$l = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error$d,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    (0, util_1$h.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1$f.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    (0, code_1$6.checkReportMissingProp)(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
                (0, code_1$6.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
                gen.if((0, codegen_1$f.not)(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1$f.nil);
        }
    },
};
required.default = def$l;

var limitItems = {};

Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = requireCodegen();
const error$c = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1$e.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1$e._) `{limit: ${schemaCode}}`,
};
const def$k = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error$c,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
        cxt.fail$data((0, codegen_1$e._) `${data}.length ${op} ${schemaCode}`);
    },
};
limitItems.default = def$k;

var uniqueItems = {};

var equal$1 = {};

Object.defineProperty(equal$1, "__esModule", { value: true });
// https://github.com/ajv-validator/ajv/issues/889
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;

Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = requireCodegen();
const util_1$g = util$1;
const equal_1$2 = equal$1;
const error$b = {
    message: ({ params: { i, j } }) => (0, codegen_1$d.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1$d._) `{i: ${i}, j: ${j}}`,
};
const def$j = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error$b,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1$d._) `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1$d._) `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1$d._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1$d._) `{}`);
            gen.for((0, codegen_1$d._) `;${i}--;`, () => {
                gen.let(item, (0, codegen_1$d._) `${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1$d._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1$d._) `typeof ${item} == "string"`, (0, codegen_1$d._) `${item} += "_"`);
                gen
                    .if((0, codegen_1$d._) `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1$d._) `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code((0, codegen_1$d._) `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1$d._) `;${i}--;`, () => gen.for((0, codegen_1$d._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$d._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
uniqueItems.default = def$j;

var _const = {};

Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = requireCodegen();
const util_1$f = util$1;
const equal_1$1 = equal$1;
const error$a = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1$c._) `{allowedValue: ${schemaCode}}`,
};
const def$i = {
    keyword: "const",
    $data: true,
    error: error$a,
    code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
            cxt.fail$data((0, codegen_1$c._) `!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
        }
        else {
            cxt.fail((0, codegen_1$c._) `${schema} !== ${data}`);
        }
    },
};
_const.default = def$i;

var _enum = {};

Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = requireCodegen();
const util_1$e = util$1;
const equal_1 = equal$1;
const error$9 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1$b._) `{allowedValues: ${schemaCode}}`,
};
const def$h = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error$9,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        const eql = (0, util_1$e.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1$b.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$b._) `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null
                ? (0, codegen_1$b._) `${eql}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1$b._) `${data} === ${sch}`;
        }
    },
};
_enum.default = def$h;

Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default,
];
validation$1.default = validation;

var applicator = {};

var additionalItems = {};

Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = requireCodegen();
const util_1$d = util$1;
const error$8 = {
    message: ({ params: { len } }) => (0, codegen_1$a.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$a._) `{limit: ${len}}`,
};
const def$g = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error$8,
    code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            (0, util_1$d.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        validateAdditionalItems(cxt, items);
    },
};
function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1$a._) `${data}.length`);
    if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1$a._) `${len} <= ${items.length}`);
    }
    else if (typeof schema == "object" && !(0, util_1$d.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1$a._) `${len} <= ${items.length}`); // TODO var
        gen.if((0, codegen_1$a.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
    }
    function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1$d.Type.Num }, valid);
            if (!it.allErrors)
                gen.if((0, codegen_1$a.not)(valid), () => gen.break());
        });
    }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;

var prefixItems = {};

var items = {};

Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = requireCodegen();
const util_1$c = util$1;
const code_1$5 = requireCode();
const def$f = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1$c.alwaysValidSchema)(it, schema))
            return;
        cxt.ok((0, code_1$5.validateArray)(cxt));
    },
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1$9._) `${data}.length`);
    schArr.forEach((sch, i) => {
        if ((0, util_1$c.alwaysValidSchema)(it, sch))
            return;
        gen.if((0, codegen_1$9._) `${len} > ${i}`, () => cxt.subschema({
            keyword,
            schemaProp: i,
            dataProp: i,
        }, valid));
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1$c.checkStrictMode)(it, msg, opts.strictTuples);
        }
    }
}
items.validateTuple = validateTuple;
items.default = def$f;

Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items"),
};
prefixItems.default = def$e;

var items2020 = {};

Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = requireCodegen();
const util_1$b = util$1;
const code_1$4 = requireCode();
const additionalItems_1$1 = additionalItems;
const error$7 = {
    message: ({ params: { len } }) => (0, codegen_1$8.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$8._) `{limit: ${len}}`,
};
const def$d = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error$7,
    code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1$b.alwaysValidSchema)(it, schema))
            return;
        if (prefixItems)
            (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
        else
            cxt.ok((0, code_1$4.validateArray)(cxt));
    },
};
items2020.default = def$d;

var contains = {};

Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = requireCodegen();
const util_1$a = util$1;
const error$6 = {
    message: ({ params: { min, max } }) => max === undefined
        ? (0, codegen_1$7.str) `must contain at least ${min} valid item(s)`
        : (0, codegen_1$7.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1$7._) `{minContains: ${min}}` : (0, codegen_1$7._) `{minContains: ${min}, maxContains: ${max}}`,
};
const def$c = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error$6,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", (0, codegen_1$7._) `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            (0, util_1$a.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            (0, util_1$a.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if ((0, util_1$a.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1$7._) `${len} >= ${min}`;
            if (max !== undefined)
                cond = (0, codegen_1$7._) `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else if (min === 0) {
            gen.let(valid, true);
            if (max !== undefined)
                gen.if((0, codegen_1$7._) `${data}.length > 0`, validateItemsWithCount);
        }
        else {
            gen.let(valid, false);
            validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1$a.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code((0, codegen_1$7._) `${count}++`);
            if (max === undefined) {
                gen.if((0, codegen_1$7._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if((0, codegen_1$7._) `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if((0, codegen_1$7._) `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
contains.default = def$c;

var dependencies = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util$1;
	const code_1 = requireCode();
	exports.error = {
	    message: ({ params: { property, depsCount, deps } }) => {
	        const property_ies = depsCount === 1 ? "property" : "properties";
	        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
	    },
	    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
	    missingProperty: ${missingProperty},
	    depsCount: ${depsCount},
	    deps: ${deps}}`, // TODO change to reference
	};
	const def = {
	    keyword: "dependencies",
	    type: "object",
	    schemaType: "object",
	    error: exports.error,
	    code(cxt) {
	        const [propDeps, schDeps] = splitDependencies(cxt);
	        validatePropertyDeps(cxt, propDeps);
	        validateSchemaDeps(cxt, schDeps);
	    },
	};
	function splitDependencies({ schema }) {
	    const propertyDeps = {};
	    const schemaDeps = {};
	    for (const key in schema) {
	        if (key === "__proto__")
	            continue;
	        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
	        deps[key] = schema[key];
	    }
	    return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
	    const { gen, data, it } = cxt;
	    if (Object.keys(propertyDeps).length === 0)
	        return;
	    const missing = gen.let("missing");
	    for (const prop in propertyDeps) {
	        const deps = propertyDeps[prop];
	        if (deps.length === 0)
	            continue;
	        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
	        cxt.setParams({
	            property: prop,
	            depsCount: deps.length,
	            deps: deps.join(", "),
	        });
	        if (it.allErrors) {
	            gen.if(hasProperty, () => {
	                for (const depProp of deps) {
	                    (0, code_1.checkReportMissingProp)(cxt, depProp);
	                }
	            });
	        }
	        else {
	            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
	            (0, code_1.reportMissingProp)(cxt, missing);
	            gen.else();
	        }
	    }
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    for (const prop in schemaDeps) {
	        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
	            continue;
	        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
	            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
	            cxt.mergeValidEvaluated(schCxt, valid);
	        }, () => gen.var(valid, true) // TODO var
	        );
	        cxt.ok(valid);
	    }
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def;
	
} (dependencies));

var propertyNames = {};

Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = requireCodegen();
const util_1$9 = util$1;
const error$5 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1$6._) `{propertyName: ${params.propertyName}}`,
};
const def$b = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error$5,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1$9.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if((0, codegen_1$6.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
propertyNames.default = def$b;

var additionalProperties = {};

Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = requireCode();
const codegen_1$5 = requireCodegen();
const names_1 = requireNames();
const util_1$8 = util$1;
const error$4 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1$5._) `{additionalProperty: ${params.additionalProperty}}`,
};
const def$a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error$4,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema))
            return;
        const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1$5._) `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = (0, codegen_1$5.or)(...props.map((p) => (0, codegen_1$5._) `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1$5.nil;
            }
            if (patProps.length) {
                definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p) => (0, codegen_1$5._) `${(0, code_1$3.usePattern)(cxt, p)}.test(${key})`));
            }
            return (0, codegen_1$5.not)(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((0, codegen_1$5._) `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if((0, codegen_1$5.not)(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if((0, codegen_1$5.not)(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1$8.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
additionalProperties.default = def$a;

var properties$1 = {};

Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = requireValidate();
const code_1$2 = requireCode();
const util_1$7 = util$1;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
        }
        const allProps = (0, code_1$2.allSchemaProperties)(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if((0, code_1$2.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
properties$1.default = def$9;

var patternProperties = {};

Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = requireCode();
const codegen_1$4 = requireCodegen();
const util_1$6 = util$1;
const util_2 = util$1;
const def$8 = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1$1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
                (!it.opts.unevaluated || it.props === true))) {
            return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1$4._) `${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
                    const alwaysValid = alwaysValidPatterns.includes(pat);
                    if (!alwaysValid) {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                    }
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign((0, codegen_1$4._) `${props}[${key}]`, true);
                    }
                    else if (!alwaysValid && !it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if((0, codegen_1$4.not)(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
patternProperties.default = def$8;

var not = {};

Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util$1;
const def$7 = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1$5.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" },
};
not.default = def$7;

var anyOf = {};

Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = requireCode();
const def$6 = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" },
};
anyOf.default = def$6;

var oneOf = {};

Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = requireCodegen();
const util_1$4 = util$1;
const error$3 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1$3._) `{passingSchemas: ${params.passing}}`,
};
const def$5 = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error$3,
    code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
            return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1$4.alwaysValidSchema)(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if((0, codegen_1$3._) `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, (0, codegen_1$3._) `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
                });
            });
        }
    },
};
oneOf.default = def$5;

var allOf = {};

Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util$1;
const def$4 = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if ((0, util_1$3.alwaysValidSchema)(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
allOf.default = def$4;

var _if = {};

Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = requireCodegen();
const util_1$2 = util$1;
const error$2 = {
    message: ({ params }) => (0, codegen_1$2.str) `must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1$2._) `{failingKeyword: ${params.ifClause}}`,
};
const def$3 = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error$2,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1$2.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1$2._) `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1$2.alwaysValidSchema)(it, schema);
}
_if.default = def$3;

var thenElse = {};

Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util$1;
const def$2 = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    },
};
thenElse.default = def$2;

Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
    const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
    ];
    // array
    if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
    else
        applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
}
applicator.default = getApplicator;

var format$2 = {};

var format$1 = {};

Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = requireCodegen();
const error$1 = {
    message: ({ schemaCode }) => (0, codegen_1$1.str) `must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$1._) `{format: ${schemaCode}}`,
};
const def$1 = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error$1,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", (0, codegen_1$1._) `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1$1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1$1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1$1.nil;
                return (0, codegen_1$1._) `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1$1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : (0, codegen_1$1._) `${format}(${data})`;
                const validData = (0, codegen_1$1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1$1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1$1.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1$1._) `${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._) `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1$1._) `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? (0, codegen_1$1._) `${fmtRef}(${data})` : (0, codegen_1$1._) `${fmtRef}.test(${data})`;
            }
        }
    },
};
format$1.default = def$1;

Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;

var metadata = {};

Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
metadata.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];

Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
];
draft7.default = draft7Vocabularies;

var discriminator = {};

var types = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DiscrError = void 0;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(exports.DiscrError || (exports.DiscrError = {}));
	
} (types));

Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = requireCodegen();
const types_1 = types;
const compile_1 = compile$1;
const util_1 = util$1;
const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
                    if (sch instanceof compile_1.SchemaEnv)
                        sch = sch.schema;
                }
                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
            }
        }
    },
};
discriminator.default = def;

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	const core_1 = core$2;
	const draft7_1 = draft7;
	const discriminator_1 = discriminator;
	const draft7MetaSchema = require$$3;
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	class Ajv extends core_1.default {
	    _addVocabularies() {
	        super._addVocabularies();
	        draft7_1.default.forEach((v) => this.addVocabulary(v));
	        if (this.opts.discriminator)
	            this.addKeyword(discriminator_1.default);
	    }
	    _addDefaultMetaSchema() {
	        super._addDefaultMetaSchema();
	        if (!this.opts.meta)
	            return;
	        const metaSchema = this.opts.$data
	            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
	            : draft7MetaSchema;
	        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
	        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
	    }
	    defaultMeta() {
	        return (this.opts.defaultMeta =
	            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
	    }
	}
	module.exports = exports = Ajv;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	
} (ajv, ajv.exports));

var Ajv = /*@__PURE__*/getDefaultExportFromCjs(ajv.exports);

class SchemaValidator {
    constructor(schema, options = {}) {
        this.schema = schema;
        this.ajv = new Ajv({
            strict: true,
            coerceTypes: options.coerceTypes,
        });
    }
    /**
     * Validate the config is valid
     * @param config Configuration
     * @param target @optional file for errors tracing.
     * @returns Validation
     */
    validate(config, target) {
        var _a;
        const validate = this.ajv.compile(this.schema);
        const valid = validate(config);
        compilerAssert(!valid || !validate.errors, "There should be errors reported if the schema is not valid.");
        const diagnostics = [];
        for (const error of (_a = validate.errors) !== null && _a !== void 0 ? _a : []) {
            const diagnostic = ajvErrorToDiagnostic(error, target);
            diagnostics.push(diagnostic);
        }
        return diagnostics;
    }
}
const IGNORED_AJV_PARAMS = new Set(["type", "errors"]);
function ajvErrorToDiagnostic(error, target) {
    const messageLines = [`Schema violation: ${error.message} (${error.instancePath || "/"})`];
    for (const [name, value] of Object.entries(error.params).filter(([name]) => !IGNORED_AJV_PARAMS.has(name))) {
        const formattedValue = Array.isArray(value) ? [...new Set(value)].join(", ") : value;
        messageLines.push(`  ${name}: ${formattedValue}`);
    }
    const message = messageLines.join("\n");
    return {
        code: "invalid-schema",
        message,
        severity: "error",
        target: target === NoTarget ? target : { file: target, pos: 0, end: 0 },
    };
}

var manifest = {
  "version": "0.34.0",
  "commit": "ab6904a286adc2ecc532e6b453ea59d843241a23"
};

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
const cadlVersion = manifest.version;
const MANIFEST = manifest;

const NodeHost = undefined;

function deepFreeze(value) {
    if (Array.isArray(value)) {
        value.map(deepFreeze);
    }
    else if (typeof value === "object") {
        for (const prop in value) {
            deepFreeze(value[prop]);
        }
    }
    return Object.freeze(value);
}
function deepClone(value) {
    if (Array.isArray(value)) {
        return value.map(deepClone);
    }
    if (typeof value === "object") {
        const obj = {};
        for (const prop in value) {
            obj[prop] = deepClone(value[prop]);
        }
        return obj;
    }
    return value;
}
async function getNormalizedRealPath(host, path) {
    return normalizePath(await host.realpath(path));
}
async function doIO(action, path, reportDiagnostic, options) {
    var _a;
    let result;
    try {
        result = await action(path);
    }
    catch (e) {
        let diagnostic;
        let target = (_a = options === null || options === void 0 ? void 0 : options.diagnosticTarget) !== null && _a !== void 0 ? _a : NoTarget;
        // blame the JS file, not the Cadl import statement for JS syntax errors.
        if (e instanceof SyntaxError && (options === null || options === void 0 ? void 0 : options.jsDiagnosticTarget)) {
            target = options.jsDiagnosticTarget;
        }
        switch (e.code) {
            case "ENOENT":
                if (options === null || options === void 0 ? void 0 : options.allowFileNotFound) {
                    return undefined;
                }
                diagnostic = createDiagnostic({ code: "file-not-found", target, format: { path } });
                break;
            default:
                diagnostic = createDiagnostic({
                    code: "file-load",
                    target,
                    format: { message: e.message },
                });
                break;
        }
        reportDiagnostic(diagnostic);
        return undefined;
    }
    return result;
}
async function loadFile(host, path, load, reportDiagnostic, options) {
    const file = await doIO(host.readFile, path, reportDiagnostic, options);
    if (!file) {
        return [undefined, createSourceFile("", path)];
    }
    let data;
    try {
        data = load(file.text);
    }
    catch (e) {
        reportDiagnostic({
            code: "file-load",
            message: e.message,
            severity: "error",
            target: { file, pos: 1, end: 1 },
        });
        return [undefined, file];
    }
    return [data, file];
}
/**
 * A specially typed version of `Array.isArray` to work around [this issue](https://github.com/microsoft/TypeScript/issues/17002).
 */
function isArray(
// eslint-disable-next-line @typescript-eslint/ban-types
arg) {
    return Array.isArray(arg);
}
/**
 * Look for the project root by looking up until a `package.json` is found.
 * @param path Path to start looking
 * @param lookIn
 */
async function findProjectRoot(host, path) {
    let current = path;
    while (true) {
        const pkgPath = joinPaths(current, "package.json");
        const stat = await doIO(() => host.stat(pkgPath), pkgPath, () => { });
        if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
            return current;
        }
        const parent = getDirectoryPath(current);
        if (parent === current) {
            return undefined;
        }
        current = parent;
    }
}
function getSourceFileKindFromExt(path) {
    const ext = getAnyExtensionFromPath(path);
    if (ext === ".js" || ext === ".mjs") {
        return "js";
    }
    else if (ext === ".cadl") {
        return "cadl";
    }
    else {
        return undefined;
    }
}

const CadlConfigJsonSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        extends: {
            type: "string",
            nullable: true,
        },
        emitters: {
            type: "object",
            nullable: true,
            required: [],
            additionalProperties: {
                oneOf: [{ type: "boolean" }, { type: "object" }],
            },
        },
    },
};

const CadlConfigFilename = "cadl-project.yaml";
const defaultConfig = deepFreeze({
    diagnostics: [],
    emitters: {},
});
/**
 * Look for the project root by looking up until a `cadl-project.yaml` is found.
 * @param path Path to start looking
 * @param lookIn
 */
async function findCadlConfigPath(host, path) {
    let current = path;
    while (true) {
        const pkgPath = joinPaths(current, CadlConfigFilename);
        const stat = await doIO(() => host.stat(pkgPath), pkgPath, () => { });
        if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
            return pkgPath;
        }
        const parent = getDirectoryPath(current);
        if (parent === current) {
            return undefined;
        }
        current = parent;
    }
}
/**
 * Load the cadl configuration for the provided directory
 * @param host
 * @param directoryPath
 */
async function loadCadlConfigForPath(host, directoryPath) {
    const cadlConfigPath = await findCadlConfigPath(host, directoryPath);
    if (cadlConfigPath === undefined) {
        return deepClone(defaultConfig);
    }
    return loadCadlConfigFile(host, cadlConfigPath);
}
/**
 * Load given file as a Cadl configuration
 */
async function loadCadlConfigFile(host, filePath) {
    const config = await loadConfigFile(host, filePath, jsYaml.load);
    if (config.diagnostics.length === 0 && config.extends) {
        const extendPath = resolvePath(getDirectoryPath(filePath), config.extends);
        const parent = await loadCadlConfigFile(host, extendPath);
        if (parent.diagnostics.length > 0) {
            return {
                ...config,
                diagnostics: parent.diagnostics,
            };
        }
        return {
            ...parent,
            ...config,
        };
    }
    return {
        ...deepClone(defaultConfig),
        ...config,
    };
}
const configValidator = new SchemaValidator(CadlConfigJsonSchema);
async function loadConfigFile(host, filePath, loadData) {
    let diagnostics = [];
    const reportDiagnostic = (d) => diagnostics.push(d);
    let [data, file] = await loadFile(host, filePath, loadData, reportDiagnostic);
    if (data) {
        diagnostics = diagnostics.concat(configValidator.validate(data, file));
    }
    if (!data || diagnostics.length > 0) {
        // NOTE: Don't trust the data if there are errors and use default
        // config. Otherwise, we may return an object that does not conform to
        // CadlConfig's typing.
        data = deepClone(defaultConfig);
    }
    data.filename = filePath;
    data.diagnostics = diagnostics;
    return data;
}

// Use a regular expression to define the prefix for Cadl-exposed functions
// defined in JavaScript modules
const DecoratorFunctionPattern = /^\$/;
const SymbolTable = class extends Map {
    constructor() {
        super(...arguments);
        this.duplicates = new Map();
    }
    // First set for a given key wins, but record all duplicates for diagnostics.
    set(key, value) {
        const existing = super.get(key);
        if (existing === undefined) {
            super.set(key, value);
        }
        else {
            if (existing.flags & 262144 /* SymbolFlags.Using */) {
                existing.flags |= 524288 /* SymbolFlags.DuplicateUsing */;
            }
            const duplicateArray = this.duplicates.get(existing);
            if (duplicateArray) {
                duplicateArray.add(value);
            }
            else {
                this.duplicates.set(existing, new Set([existing, value]));
            }
        }
        return this;
    }
};
function createSymbolTable() {
    return new SymbolTable();
}
function createBinder(program, options = {}) {
    let currentFile;
    let parentNode = options === null || options === void 0 ? void 0 : options.initialParentNode;
    let fileNamespace;
    let scope;
    // tracks which selectors were used with which projection symbols
    // for reporting duplicates
    const projectionSymbolSelectors = new Map();
    return {
        bindSourceFile,
        bindNode,
        bindJsSourceFile,
    };
    function isFunctionName(name) {
        return DecoratorFunctionPattern.test(name);
    }
    function getFunctionName(name) {
        return name.replace(DecoratorFunctionPattern, "");
    }
    function bindJsSourceFile(sourceFile) {
        fileNamespace = undefined;
        sourceFile.symbol = createSymbol(sourceFile, sourceFile.file.path, 1048576 /* SymbolFlags.SourceFile */);
        const rootNs = sourceFile.esmExports["namespace"];
        for (const [key, member] of Object.entries(sourceFile.esmExports)) {
            let name;
            let kind;
            let containerSymbol = sourceFile.symbol;
            if (typeof member === "function") {
                // lots of 'any' casts here because control flow narrowing `member` to Function
                // isn't particularly useful it turns out.
                if (isFunctionName(key)) {
                    name = getFunctionName(key);
                    kind = "decorator";
                    if (name === "onValidate") {
                        program.onValidate(member);
                        continue;
                    }
                    else if (name === "onEmit") {
                        // nothing to do here this is loaded as emitter.
                        continue;
                    }
                }
                else {
                    name = key;
                    kind = "function";
                }
                const memberNs = member.namespace;
                const nsParts = [];
                if (rootNs) {
                    nsParts.push(...rootNs.split("."));
                }
                if (memberNs) {
                    nsParts.push(...memberNs.split("."));
                }
                for (const part of nsParts) {
                    const existingBinding = containerSymbol.exports.get(part);
                    if (existingBinding) {
                        if (existingBinding.flags & 2048 /* SymbolFlags.Namespace */) {
                            // since the namespace was "declared" as part of this source file,
                            // we can simply re-use it.
                            containerSymbol = existingBinding;
                        }
                        else {
                            // we have some conflict, lets report a duplicate binding error.
                            containerSymbol.exports.set(part, createSymbol(sourceFile, part, 2048 /* SymbolFlags.Namespace */, containerSymbol));
                        }
                    }
                    else {
                        const sym = createSymbol(sourceFile, part, 2048 /* SymbolFlags.Namespace */, containerSymbol);
                        sym.exports = createSymbolTable();
                        containerSymbol.exports.set(part, sym);
                        containerSymbol = sym;
                    }
                }
                let sym;
                if (kind === "decorator") {
                    sym = createSymbol(sourceFile, "@" + name, 8192 /* SymbolFlags.Decorator */, containerSymbol);
                }
                else {
                    sym = createSymbol(sourceFile, name, 65536 /* SymbolFlags.Function */, containerSymbol);
                }
                sym.value = member;
                containerSymbol.exports.set(sym.name, sym);
            }
        }
    }
    function bindSourceFile(sourceFile) {
        sourceFile.symbol = createSymbol(sourceFile, sourceFile.file.path, 1048576 /* SymbolFlags.SourceFile */);
        sourceFile.symbol.exports = createSymbolTable();
        fileNamespace = undefined;
        currentFile = sourceFile;
        scope = sourceFile;
        bindNode(sourceFile);
    }
    function bindNode(node) {
        if (!node)
            return;
        // set the node's parent since we're going for a walk anyway
        node.parent = parentNode;
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
                bindModelStatement(node);
                break;
            case SyntaxKind.InterfaceStatement:
                bindInterfaceStatement(node);
                break;
            case SyntaxKind.UnionStatement:
                bindUnionStatement(node);
                break;
            case SyntaxKind.AliasStatement:
                bindAliasStatement(node);
                break;
            case SyntaxKind.EnumStatement:
                bindEnumStatement(node);
                break;
            case SyntaxKind.NamespaceStatement:
                bindNamespaceStatement(node);
                break;
            case SyntaxKind.OperationStatement:
                bindOperationStatement(node);
                break;
            case SyntaxKind.TemplateParameterDeclaration:
                bindTemplateParameterDeclaration(node);
                break;
            case SyntaxKind.UsingStatement:
                bindUsingStatement(node);
                break;
            case SyntaxKind.Projection:
                bindProjection(node);
                break;
            case SyntaxKind.ProjectionStatement:
                bindProjectionStatement(node);
                break;
            case SyntaxKind.ProjectionParameterDeclaration:
                bindProjectionParameterDeclaration(node);
                break;
            case SyntaxKind.ProjectionLambdaParameterDeclaration:
                bindProjectionLambdaParameterDeclaration(node);
                break;
            case SyntaxKind.ProjectionLambdaExpression:
                bindProjectionLambdaExpression(node);
        }
        const prevParent = parentNode;
        // set parent node when we walk into children
        parentNode = node;
        if (hasScope(node)) {
            const prevScope = scope;
            scope = node;
            visitChildren(node, bindNode);
            if ("locals" in node) {
                program.reportDuplicateSymbols(node.locals);
            }
            scope = prevScope;
        }
        else {
            visitChildren(node, bindNode);
        }
        // restore parent node
        parentNode = prevParent;
    }
    function bindProjection(node) {
        node.locals = new SymbolTable();
    }
    /**
     * Binding projection statements is interesting because there may be
     * multiple declarations spread across various source files that all
     * contribute to the same symbol because they declare the same
     * projection on different selectors.
     *
     * There is presently an issue where we do not check for duplicate
     * projections when they're applied to a specific type. This could
     * be done with ease in the checker during evaluation, but could
     * probably instead be done in a post-bind phase - we just need
     * all the symbols in place so we know if a projection was declared
     * multiple times for the same symbol.
     *
     */
    function bindProjectionStatement(node) {
        const name = node.id.sv;
        const table = scope.symbol.exports;
        let sym;
        if (table.has(name)) {
            sym = table.get(name);
            if (!(sym.flags & 4096 /* SymbolFlags.Projection */)) {
                // clashing with some other decl, report duplicate symbol
                declareSymbol(node, 4096 /* SymbolFlags.Projection */);
                return;
            }
            sym.declarations.push(node);
        }
        else {
            sym = createSymbol(node, name, 4096 /* SymbolFlags.Projection */, scope.symbol);
            table.set(name, sym);
        }
        node.symbol = sym;
        if (node.selector.kind !== SyntaxKind.Identifier &&
            node.selector.kind !== SyntaxKind.MemberExpression) {
            const selectorString = node.selector.kind === SyntaxKind.ProjectionModelSelector
                ? "model"
                : node.selector.kind === SyntaxKind.ProjectionOperationSelector
                    ? "op"
                    : node.selector.kind === SyntaxKind.ProjectionUnionSelector
                        ? "union"
                        : node.selector.kind === SyntaxKind.ProjectionEnumSelector
                            ? "enum"
                            : "interface";
            let existingSelectors = projectionSymbolSelectors.get(sym);
            if (!existingSelectors) {
                existingSelectors = new Set();
                projectionSymbolSelectors.set(sym, existingSelectors);
            }
            if (existingSelectors.has(selectorString)) {
                // clashing with a like-named decl with this selector, so throw.
                declareSymbol(node, 4096 /* SymbolFlags.Projection */);
                return;
            }
            existingSelectors.add(selectorString);
        }
    }
    function bindProjectionParameterDeclaration(node) {
        declareSymbol(node, 32768 /* SymbolFlags.ProjectionParameter */);
    }
    function bindProjectionLambdaParameterDeclaration(node) {
        declareSymbol(node, 131072 /* SymbolFlags.FunctionParameter */);
    }
    function bindProjectionLambdaExpression(node) {
        node.locals = new SymbolTable();
    }
    function bindTemplateParameterDeclaration(node) {
        declareSymbol(node, 16384 /* SymbolFlags.TemplateParameter */);
    }
    function bindModelStatement(node) {
        declareSymbol(node, 2 /* SymbolFlags.Model */);
        // Initialize locals for type parameters
        node.locals = new SymbolTable();
    }
    function bindInterfaceStatement(node) {
        declareSymbol(node, 64 /* SymbolFlags.Interface */);
        node.locals = new SymbolTable();
    }
    function bindUnionStatement(node) {
        declareSymbol(node, 256 /* SymbolFlags.Union */);
        node.locals = new SymbolTable();
    }
    function bindAliasStatement(node) {
        declareSymbol(node, 1024 /* SymbolFlags.Alias */);
        // Initialize locals for type parameters
        node.locals = new SymbolTable();
    }
    function bindEnumStatement(node) {
        declareSymbol(node, 16 /* SymbolFlags.Enum */);
    }
    function bindNamespaceStatement(statement) {
        // check if there's an existing symbol for this namespace
        const existingBinding = scope.symbol.exports.get(statement.id.sv);
        if (existingBinding && existingBinding.flags & 2048 /* SymbolFlags.Namespace */) {
            statement.symbol = existingBinding;
            // locals are never shared.
            statement.locals = createSymbolTable();
            existingBinding.declarations.push(statement);
        }
        else {
            // Initialize locals for non-exported symbols
            statement.locals = createSymbolTable();
            declareSymbol(statement, 2048 /* SymbolFlags.Namespace */);
        }
        currentFile.namespaces.push(statement);
        if (statement.statements === undefined) {
            fileNamespace = statement;
            let current = statement;
            while (current.kind !== SyntaxKind.CadlScript) {
                currentFile.inScopeNamespaces.push(current);
                current = current.parent;
            }
        }
    }
    function bindUsingStatement(statement) {
        currentFile.usings.push(statement);
    }
    function bindOperationStatement(statement) {
        if (scope.kind !== SyntaxKind.InterfaceStatement) {
            declareSymbol(statement, 8 /* SymbolFlags.Operation */);
            statement.locals = new SymbolTable();
        }
    }
    function declareSymbol(node, flags) {
        switch (scope.kind) {
            case SyntaxKind.NamespaceStatement:
                return declareNamespaceMember(node, flags);
            case SyntaxKind.CadlScript:
            case SyntaxKind.JsSourceFile:
                return declareScriptMember(node, flags);
            default:
                const symbol = createSymbol(node, node.id.sv, flags, scope.symbol);
                node.symbol = symbol;
                scope.locals.set(node.id.sv, symbol);
                return symbol;
        }
    }
    function declareNamespaceMember(node, flags) {
        if (flags & 2048 /* SymbolFlags.Namespace */ &&
            mergeNamespaceDeclarations(node, scope)) {
            return;
        }
        const symbol = createSymbol(node, node.id.sv, flags, scope.symbol);
        node.symbol = symbol;
        scope.symbol.exports.set(node.id.sv, symbol);
        return symbol;
    }
    function declareScriptMember(node, flags) {
        const effectiveScope = fileNamespace !== null && fileNamespace !== void 0 ? fileNamespace : scope;
        if (flags & 2048 /* SymbolFlags.Namespace */ &&
            mergeNamespaceDeclarations(node, effectiveScope)) {
            return;
        }
        const symbol = createSymbol(node, node.id.sv, flags, fileNamespace === null || fileNamespace === void 0 ? void 0 : fileNamespace.symbol);
        node.symbol = symbol;
        effectiveScope.symbol.exports.set(node.id.sv, symbol);
        return symbol;
    }
    function mergeNamespaceDeclarations(node, scope) {
        // we are declaring a namespace in either global scope, or a blockless namespace.
        const existingBinding = scope.symbol.exports.get(node.id.sv);
        if (existingBinding) {
            // we have an existing binding, so just push this node to its declarations
            existingBinding.declarations.push(node);
            node.symbol = existingBinding;
            return true;
        }
        return false;
    }
}
function hasScope(node) {
    switch (node.kind) {
        case SyntaxKind.ModelStatement:
        case SyntaxKind.AliasStatement:
        case SyntaxKind.CadlScript:
        case SyntaxKind.InterfaceStatement:
        case SyntaxKind.OperationStatement:
        case SyntaxKind.UnionStatement:
        case SyntaxKind.Projection:
        case SyntaxKind.ProjectionLambdaExpression:
            return true;
        case SyntaxKind.NamespaceStatement:
            return node.statements !== undefined;
        default:
            return false;
    }
}
function createSymbol(node, name, flags, parent, value) {
    let exports;
    if (flags & 1050624 /* SymbolFlags.ExportContainer */) {
        exports = createSymbolTable();
    }
    let members;
    if (flags & 338 /* SymbolFlags.MemberContainer */) {
        members = createSymbolTable();
    }
    return {
        declarations: node ? [node] : [],
        name,
        exports,
        members,
        flags,
        value,
        parent,
    };
}

//
// Generated by scripts/regen-nonascii-map.js
// on node v16.15.0 with unicode 14.0.
//
/**
 * @internal
 *
 * Map of non-ascii characters that are valid in an identifier. Each pair of
 * numbers represents an inclusive range of code points.
 */
//prettier-ignore
const nonAsciiIdentifierMap = [
    0xa0, 0x377,
    0x37a, 0x37f,
    0x384, 0x38a,
    0x38c, 0x38c,
    0x38e, 0x3a1,
    0x3a3, 0x52f,
    0x531, 0x556,
    0x559, 0x58a,
    0x58d, 0x58f,
    0x591, 0x5c7,
    0x5d0, 0x5ea,
    0x5ef, 0x5f4,
    0x600, 0x70d,
    0x70f, 0x74a,
    0x74d, 0x7b1,
    0x7c0, 0x7fa,
    0x7fd, 0x82d,
    0x830, 0x83e,
    0x840, 0x85b,
    0x85e, 0x85e,
    0x860, 0x86a,
    0x870, 0x88e,
    0x890, 0x891,
    0x898, 0x983,
    0x985, 0x98c,
    0x98f, 0x990,
    0x993, 0x9a8,
    0x9aa, 0x9b0,
    0x9b2, 0x9b2,
    0x9b6, 0x9b9,
    0x9bc, 0x9c4,
    0x9c7, 0x9c8,
    0x9cb, 0x9ce,
    0x9d7, 0x9d7,
    0x9dc, 0x9dd,
    0x9df, 0x9e3,
    0x9e6, 0x9fe,
    0xa01, 0xa03,
    0xa05, 0xa0a,
    0xa0f, 0xa10,
    0xa13, 0xa28,
    0xa2a, 0xa30,
    0xa32, 0xa33,
    0xa35, 0xa36,
    0xa38, 0xa39,
    0xa3c, 0xa3c,
    0xa3e, 0xa42,
    0xa47, 0xa48,
    0xa4b, 0xa4d,
    0xa51, 0xa51,
    0xa59, 0xa5c,
    0xa5e, 0xa5e,
    0xa66, 0xa76,
    0xa81, 0xa83,
    0xa85, 0xa8d,
    0xa8f, 0xa91,
    0xa93, 0xaa8,
    0xaaa, 0xab0,
    0xab2, 0xab3,
    0xab5, 0xab9,
    0xabc, 0xac5,
    0xac7, 0xac9,
    0xacb, 0xacd,
    0xad0, 0xad0,
    0xae0, 0xae3,
    0xae6, 0xaf1,
    0xaf9, 0xaff,
    0xb01, 0xb03,
    0xb05, 0xb0c,
    0xb0f, 0xb10,
    0xb13, 0xb28,
    0xb2a, 0xb30,
    0xb32, 0xb33,
    0xb35, 0xb39,
    0xb3c, 0xb44,
    0xb47, 0xb48,
    0xb4b, 0xb4d,
    0xb55, 0xb57,
    0xb5c, 0xb5d,
    0xb5f, 0xb63,
    0xb66, 0xb77,
    0xb82, 0xb83,
    0xb85, 0xb8a,
    0xb8e, 0xb90,
    0xb92, 0xb95,
    0xb99, 0xb9a,
    0xb9c, 0xb9c,
    0xb9e, 0xb9f,
    0xba3, 0xba4,
    0xba8, 0xbaa,
    0xbae, 0xbb9,
    0xbbe, 0xbc2,
    0xbc6, 0xbc8,
    0xbca, 0xbcd,
    0xbd0, 0xbd0,
    0xbd7, 0xbd7,
    0xbe6, 0xbfa,
    0xc00, 0xc0c,
    0xc0e, 0xc10,
    0xc12, 0xc28,
    0xc2a, 0xc39,
    0xc3c, 0xc44,
    0xc46, 0xc48,
    0xc4a, 0xc4d,
    0xc55, 0xc56,
    0xc58, 0xc5a,
    0xc5d, 0xc5d,
    0xc60, 0xc63,
    0xc66, 0xc6f,
    0xc77, 0xc8c,
    0xc8e, 0xc90,
    0xc92, 0xca8,
    0xcaa, 0xcb3,
    0xcb5, 0xcb9,
    0xcbc, 0xcc4,
    0xcc6, 0xcc8,
    0xcca, 0xccd,
    0xcd5, 0xcd6,
    0xcdd, 0xcde,
    0xce0, 0xce3,
    0xce6, 0xcef,
    0xcf1, 0xcf2,
    0xd00, 0xd0c,
    0xd0e, 0xd10,
    0xd12, 0xd44,
    0xd46, 0xd48,
    0xd4a, 0xd4f,
    0xd54, 0xd63,
    0xd66, 0xd7f,
    0xd81, 0xd83,
    0xd85, 0xd96,
    0xd9a, 0xdb1,
    0xdb3, 0xdbb,
    0xdbd, 0xdbd,
    0xdc0, 0xdc6,
    0xdca, 0xdca,
    0xdcf, 0xdd4,
    0xdd6, 0xdd6,
    0xdd8, 0xddf,
    0xde6, 0xdef,
    0xdf2, 0xdf4,
    0xe01, 0xe3a,
    0xe3f, 0xe5b,
    0xe81, 0xe82,
    0xe84, 0xe84,
    0xe86, 0xe8a,
    0xe8c, 0xea3,
    0xea5, 0xea5,
    0xea7, 0xebd,
    0xec0, 0xec4,
    0xec6, 0xec6,
    0xec8, 0xecd,
    0xed0, 0xed9,
    0xedc, 0xedf,
    0xf00, 0xf47,
    0xf49, 0xf6c,
    0xf71, 0xf97,
    0xf99, 0xfbc,
    0xfbe, 0xfcc,
    0xfce, 0xfda,
    0x1000, 0x10c5,
    0x10c7, 0x10c7,
    0x10cd, 0x10cd,
    0x10d0, 0x1248,
    0x124a, 0x124d,
    0x1250, 0x1256,
    0x1258, 0x1258,
    0x125a, 0x125d,
    0x1260, 0x1288,
    0x128a, 0x128d,
    0x1290, 0x12b0,
    0x12b2, 0x12b5,
    0x12b8, 0x12be,
    0x12c0, 0x12c0,
    0x12c2, 0x12c5,
    0x12c8, 0x12d6,
    0x12d8, 0x1310,
    0x1312, 0x1315,
    0x1318, 0x135a,
    0x135d, 0x137c,
    0x1380, 0x1399,
    0x13a0, 0x13f5,
    0x13f8, 0x13fd,
    0x1400, 0x169c,
    0x16a0, 0x16f8,
    0x1700, 0x1715,
    0x171f, 0x1736,
    0x1740, 0x1753,
    0x1760, 0x176c,
    0x176e, 0x1770,
    0x1772, 0x1773,
    0x1780, 0x17dd,
    0x17e0, 0x17e9,
    0x17f0, 0x17f9,
    0x1800, 0x1819,
    0x1820, 0x1878,
    0x1880, 0x18aa,
    0x18b0, 0x18f5,
    0x1900, 0x191e,
    0x1920, 0x192b,
    0x1930, 0x193b,
    0x1940, 0x1940,
    0x1944, 0x196d,
    0x1970, 0x1974,
    0x1980, 0x19ab,
    0x19b0, 0x19c9,
    0x19d0, 0x19da,
    0x19de, 0x1a1b,
    0x1a1e, 0x1a5e,
    0x1a60, 0x1a7c,
    0x1a7f, 0x1a89,
    0x1a90, 0x1a99,
    0x1aa0, 0x1aad,
    0x1ab0, 0x1ace,
    0x1b00, 0x1b4c,
    0x1b50, 0x1b7e,
    0x1b80, 0x1bf3,
    0x1bfc, 0x1c37,
    0x1c3b, 0x1c49,
    0x1c4d, 0x1c88,
    0x1c90, 0x1cba,
    0x1cbd, 0x1cc7,
    0x1cd0, 0x1cfa,
    0x1d00, 0x1f15,
    0x1f18, 0x1f1d,
    0x1f20, 0x1f45,
    0x1f48, 0x1f4d,
    0x1f50, 0x1f57,
    0x1f59, 0x1f59,
    0x1f5b, 0x1f5b,
    0x1f5d, 0x1f5d,
    0x1f5f, 0x1f7d,
    0x1f80, 0x1fb4,
    0x1fb6, 0x1fc4,
    0x1fc6, 0x1fd3,
    0x1fd6, 0x1fdb,
    0x1fdd, 0x1fef,
    0x1ff2, 0x1ff4,
    0x1ff6, 0x1ffe,
    0x2000, 0x200d,
    0x2010, 0x2027,
    0x202a, 0x2064,
    0x2066, 0x2071,
    0x2074, 0x208e,
    0x2090, 0x209c,
    0x20a0, 0x20c0,
    0x20d0, 0x20f0,
    0x2100, 0x218b,
    0x2190, 0x2426,
    0x2440, 0x244a,
    0x2460, 0x2b73,
    0x2b76, 0x2b95,
    0x2b97, 0x2cf3,
    0x2cf9, 0x2d25,
    0x2d27, 0x2d27,
    0x2d2d, 0x2d2d,
    0x2d30, 0x2d67,
    0x2d6f, 0x2d70,
    0x2d7f, 0x2d96,
    0x2da0, 0x2da6,
    0x2da8, 0x2dae,
    0x2db0, 0x2db6,
    0x2db8, 0x2dbe,
    0x2dc0, 0x2dc6,
    0x2dc8, 0x2dce,
    0x2dd0, 0x2dd6,
    0x2dd8, 0x2dde,
    0x2de0, 0x2e5d,
    0x2e80, 0x2e99,
    0x2e9b, 0x2ef3,
    0x2f00, 0x2fd5,
    0x2ff0, 0x2ffb,
    0x3000, 0x303f,
    0x3041, 0x3096,
    0x3099, 0x30ff,
    0x3105, 0x312f,
    0x3131, 0x318e,
    0x3190, 0x31e3,
    0x31f0, 0x321e,
    0x3220, 0xa48c,
    0xa490, 0xa4c6,
    0xa4d0, 0xa62b,
    0xa640, 0xa6f7,
    0xa700, 0xa7ca,
    0xa7d0, 0xa7d1,
    0xa7d3, 0xa7d3,
    0xa7d5, 0xa7d9,
    0xa7f2, 0xa82c,
    0xa830, 0xa839,
    0xa840, 0xa877,
    0xa880, 0xa8c5,
    0xa8ce, 0xa8d9,
    0xa8e0, 0xa953,
    0xa95f, 0xa97c,
    0xa980, 0xa9cd,
    0xa9cf, 0xa9d9,
    0xa9de, 0xa9fe,
    0xaa00, 0xaa36,
    0xaa40, 0xaa4d,
    0xaa50, 0xaa59,
    0xaa5c, 0xaac2,
    0xaadb, 0xaaf6,
    0xab01, 0xab06,
    0xab09, 0xab0e,
    0xab11, 0xab16,
    0xab20, 0xab26,
    0xab28, 0xab2e,
    0xab30, 0xab6b,
    0xab70, 0xabed,
    0xabf0, 0xabf9,
    0xac00, 0xd7a3,
    0xd7b0, 0xd7c6,
    0xd7cb, 0xd7fb,
    0xf900, 0xfa6d,
    0xfa70, 0xfad9,
    0xfb00, 0xfb06,
    0xfb13, 0xfb17,
    0xfb1d, 0xfb36,
    0xfb38, 0xfb3c,
    0xfb3e, 0xfb3e,
    0xfb40, 0xfb41,
    0xfb43, 0xfb44,
    0xfb46, 0xfbc2,
    0xfbd3, 0xfd8f,
    0xfd92, 0xfdc7,
    0xfdcf, 0xfdcf,
    0xfdf0, 0xfe19,
    0xfe20, 0xfe52,
    0xfe54, 0xfe66,
    0xfe68, 0xfe6b,
    0xfe70, 0xfe74,
    0xfe76, 0xfefc,
    0xfeff, 0xfeff,
    0xff01, 0xffbe,
    0xffc2, 0xffc7,
    0xffca, 0xffcf,
    0xffd2, 0xffd7,
    0xffda, 0xffdc,
    0xffe0, 0xffe6,
    0xffe8, 0xffee,
    0xfff9, 0xfffc,
    0x10000, 0x1000b,
    0x1000d, 0x10026,
    0x10028, 0x1003a,
    0x1003c, 0x1003d,
    0x1003f, 0x1004d,
    0x10050, 0x1005d,
    0x10080, 0x100fa,
    0x10100, 0x10102,
    0x10107, 0x10133,
    0x10137, 0x1018e,
    0x10190, 0x1019c,
    0x101a0, 0x101a0,
    0x101d0, 0x101fd,
    0x10280, 0x1029c,
    0x102a0, 0x102d0,
    0x102e0, 0x102fb,
    0x10300, 0x10323,
    0x1032d, 0x1034a,
    0x10350, 0x1037a,
    0x10380, 0x1039d,
    0x1039f, 0x103c3,
    0x103c8, 0x103d5,
    0x10400, 0x1049d,
    0x104a0, 0x104a9,
    0x104b0, 0x104d3,
    0x104d8, 0x104fb,
    0x10500, 0x10527,
    0x10530, 0x10563,
    0x1056f, 0x1057a,
    0x1057c, 0x1058a,
    0x1058c, 0x10592,
    0x10594, 0x10595,
    0x10597, 0x105a1,
    0x105a3, 0x105b1,
    0x105b3, 0x105b9,
    0x105bb, 0x105bc,
    0x10600, 0x10736,
    0x10740, 0x10755,
    0x10760, 0x10767,
    0x10780, 0x10785,
    0x10787, 0x107b0,
    0x107b2, 0x107ba,
    0x10800, 0x10805,
    0x10808, 0x10808,
    0x1080a, 0x10835,
    0x10837, 0x10838,
    0x1083c, 0x1083c,
    0x1083f, 0x10855,
    0x10857, 0x1089e,
    0x108a7, 0x108af,
    0x108e0, 0x108f2,
    0x108f4, 0x108f5,
    0x108fb, 0x1091b,
    0x1091f, 0x10939,
    0x1093f, 0x1093f,
    0x10980, 0x109b7,
    0x109bc, 0x109cf,
    0x109d2, 0x10a03,
    0x10a05, 0x10a06,
    0x10a0c, 0x10a13,
    0x10a15, 0x10a17,
    0x10a19, 0x10a35,
    0x10a38, 0x10a3a,
    0x10a3f, 0x10a48,
    0x10a50, 0x10a58,
    0x10a60, 0x10a9f,
    0x10ac0, 0x10ae6,
    0x10aeb, 0x10af6,
    0x10b00, 0x10b35,
    0x10b39, 0x10b55,
    0x10b58, 0x10b72,
    0x10b78, 0x10b91,
    0x10b99, 0x10b9c,
    0x10ba9, 0x10baf,
    0x10c00, 0x10c48,
    0x10c80, 0x10cb2,
    0x10cc0, 0x10cf2,
    0x10cfa, 0x10d27,
    0x10d30, 0x10d39,
    0x10e60, 0x10e7e,
    0x10e80, 0x10ea9,
    0x10eab, 0x10ead,
    0x10eb0, 0x10eb1,
    0x10f00, 0x10f27,
    0x10f30, 0x10f59,
    0x10f70, 0x10f89,
    0x10fb0, 0x10fcb,
    0x10fe0, 0x10ff6,
    0x11000, 0x1104d,
    0x11052, 0x11075,
    0x1107f, 0x110c2,
    0x110cd, 0x110cd,
    0x110d0, 0x110e8,
    0x110f0, 0x110f9,
    0x11100, 0x11134,
    0x11136, 0x11147,
    0x11150, 0x11176,
    0x11180, 0x111df,
    0x111e1, 0x111f4,
    0x11200, 0x11211,
    0x11213, 0x1123e,
    0x11280, 0x11286,
    0x11288, 0x11288,
    0x1128a, 0x1128d,
    0x1128f, 0x1129d,
    0x1129f, 0x112a9,
    0x112b0, 0x112ea,
    0x112f0, 0x112f9,
    0x11300, 0x11303,
    0x11305, 0x1130c,
    0x1130f, 0x11310,
    0x11313, 0x11328,
    0x1132a, 0x11330,
    0x11332, 0x11333,
    0x11335, 0x11339,
    0x1133b, 0x11344,
    0x11347, 0x11348,
    0x1134b, 0x1134d,
    0x11350, 0x11350,
    0x11357, 0x11357,
    0x1135d, 0x11363,
    0x11366, 0x1136c,
    0x11370, 0x11374,
    0x11400, 0x1145b,
    0x1145d, 0x11461,
    0x11480, 0x114c7,
    0x114d0, 0x114d9,
    0x11580, 0x115b5,
    0x115b8, 0x115dd,
    0x11600, 0x11644,
    0x11650, 0x11659,
    0x11660, 0x1166c,
    0x11680, 0x116b9,
    0x116c0, 0x116c9,
    0x11700, 0x1171a,
    0x1171d, 0x1172b,
    0x11730, 0x11746,
    0x11800, 0x1183b,
    0x118a0, 0x118f2,
    0x118ff, 0x11906,
    0x11909, 0x11909,
    0x1190c, 0x11913,
    0x11915, 0x11916,
    0x11918, 0x11935,
    0x11937, 0x11938,
    0x1193b, 0x11946,
    0x11950, 0x11959,
    0x119a0, 0x119a7,
    0x119aa, 0x119d7,
    0x119da, 0x119e4,
    0x11a00, 0x11a47,
    0x11a50, 0x11aa2,
    0x11ab0, 0x11af8,
    0x11c00, 0x11c08,
    0x11c0a, 0x11c36,
    0x11c38, 0x11c45,
    0x11c50, 0x11c6c,
    0x11c70, 0x11c8f,
    0x11c92, 0x11ca7,
    0x11ca9, 0x11cb6,
    0x11d00, 0x11d06,
    0x11d08, 0x11d09,
    0x11d0b, 0x11d36,
    0x11d3a, 0x11d3a,
    0x11d3c, 0x11d3d,
    0x11d3f, 0x11d47,
    0x11d50, 0x11d59,
    0x11d60, 0x11d65,
    0x11d67, 0x11d68,
    0x11d6a, 0x11d8e,
    0x11d90, 0x11d91,
    0x11d93, 0x11d98,
    0x11da0, 0x11da9,
    0x11ee0, 0x11ef8,
    0x11fb0, 0x11fb0,
    0x11fc0, 0x11ff1,
    0x11fff, 0x12399,
    0x12400, 0x1246e,
    0x12470, 0x12474,
    0x12480, 0x12543,
    0x12f90, 0x12ff2,
    0x13000, 0x1342e,
    0x13430, 0x13438,
    0x14400, 0x14646,
    0x16800, 0x16a38,
    0x16a40, 0x16a5e,
    0x16a60, 0x16a69,
    0x16a6e, 0x16abe,
    0x16ac0, 0x16ac9,
    0x16ad0, 0x16aed,
    0x16af0, 0x16af5,
    0x16b00, 0x16b45,
    0x16b50, 0x16b59,
    0x16b5b, 0x16b61,
    0x16b63, 0x16b77,
    0x16b7d, 0x16b8f,
    0x16e40, 0x16e9a,
    0x16f00, 0x16f4a,
    0x16f4f, 0x16f87,
    0x16f8f, 0x16f9f,
    0x16fe0, 0x16fe4,
    0x16ff0, 0x16ff1,
    0x17000, 0x187f7,
    0x18800, 0x18cd5,
    0x18d00, 0x18d08,
    0x1aff0, 0x1aff3,
    0x1aff5, 0x1affb,
    0x1affd, 0x1affe,
    0x1b000, 0x1b122,
    0x1b150, 0x1b152,
    0x1b164, 0x1b167,
    0x1b170, 0x1b2fb,
    0x1bc00, 0x1bc6a,
    0x1bc70, 0x1bc7c,
    0x1bc80, 0x1bc88,
    0x1bc90, 0x1bc99,
    0x1bc9c, 0x1bca3,
    0x1cf00, 0x1cf2d,
    0x1cf30, 0x1cf46,
    0x1cf50, 0x1cfc3,
    0x1d000, 0x1d0f5,
    0x1d100, 0x1d126,
    0x1d129, 0x1d1ea,
    0x1d200, 0x1d245,
    0x1d2e0, 0x1d2f3,
    0x1d300, 0x1d356,
    0x1d360, 0x1d378,
    0x1d400, 0x1d454,
    0x1d456, 0x1d49c,
    0x1d49e, 0x1d49f,
    0x1d4a2, 0x1d4a2,
    0x1d4a5, 0x1d4a6,
    0x1d4a9, 0x1d4ac,
    0x1d4ae, 0x1d4b9,
    0x1d4bb, 0x1d4bb,
    0x1d4bd, 0x1d4c3,
    0x1d4c5, 0x1d505,
    0x1d507, 0x1d50a,
    0x1d50d, 0x1d514,
    0x1d516, 0x1d51c,
    0x1d51e, 0x1d539,
    0x1d53b, 0x1d53e,
    0x1d540, 0x1d544,
    0x1d546, 0x1d546,
    0x1d54a, 0x1d550,
    0x1d552, 0x1d6a5,
    0x1d6a8, 0x1d7cb,
    0x1d7ce, 0x1da8b,
    0x1da9b, 0x1da9f,
    0x1daa1, 0x1daaf,
    0x1df00, 0x1df1e,
    0x1e000, 0x1e006,
    0x1e008, 0x1e018,
    0x1e01b, 0x1e021,
    0x1e023, 0x1e024,
    0x1e026, 0x1e02a,
    0x1e100, 0x1e12c,
    0x1e130, 0x1e13d,
    0x1e140, 0x1e149,
    0x1e14e, 0x1e14f,
    0x1e290, 0x1e2ae,
    0x1e2c0, 0x1e2f9,
    0x1e2ff, 0x1e2ff,
    0x1e7e0, 0x1e7e6,
    0x1e7e8, 0x1e7eb,
    0x1e7ed, 0x1e7ee,
    0x1e7f0, 0x1e7fe,
    0x1e800, 0x1e8c4,
    0x1e8c7, 0x1e8d6,
    0x1e900, 0x1e94b,
    0x1e950, 0x1e959,
    0x1e95e, 0x1e95f,
    0x1ec71, 0x1ecb4,
    0x1ed01, 0x1ed3d,
    0x1ee00, 0x1ee03,
    0x1ee05, 0x1ee1f,
    0x1ee21, 0x1ee22,
    0x1ee24, 0x1ee24,
    0x1ee27, 0x1ee27,
    0x1ee29, 0x1ee32,
    0x1ee34, 0x1ee37,
    0x1ee39, 0x1ee39,
    0x1ee3b, 0x1ee3b,
    0x1ee42, 0x1ee42,
    0x1ee47, 0x1ee47,
    0x1ee49, 0x1ee49,
    0x1ee4b, 0x1ee4b,
    0x1ee4d, 0x1ee4f,
    0x1ee51, 0x1ee52,
    0x1ee54, 0x1ee54,
    0x1ee57, 0x1ee57,
    0x1ee59, 0x1ee59,
    0x1ee5b, 0x1ee5b,
    0x1ee5d, 0x1ee5d,
    0x1ee5f, 0x1ee5f,
    0x1ee61, 0x1ee62,
    0x1ee64, 0x1ee64,
    0x1ee67, 0x1ee6a,
    0x1ee6c, 0x1ee72,
    0x1ee74, 0x1ee77,
    0x1ee79, 0x1ee7c,
    0x1ee7e, 0x1ee7e,
    0x1ee80, 0x1ee89,
    0x1ee8b, 0x1ee9b,
    0x1eea1, 0x1eea3,
    0x1eea5, 0x1eea9,
    0x1eeab, 0x1eebb,
    0x1eef0, 0x1eef1,
    0x1f000, 0x1f02b,
    0x1f030, 0x1f093,
    0x1f0a0, 0x1f0ae,
    0x1f0b1, 0x1f0bf,
    0x1f0c1, 0x1f0cf,
    0x1f0d1, 0x1f0f5,
    0x1f100, 0x1f1ad,
    0x1f1e6, 0x1f202,
    0x1f210, 0x1f23b,
    0x1f240, 0x1f248,
    0x1f250, 0x1f251,
    0x1f260, 0x1f265,
    0x1f300, 0x1f6d7,
    0x1f6dd, 0x1f6ec,
    0x1f6f0, 0x1f6fc,
    0x1f700, 0x1f773,
    0x1f780, 0x1f7d8,
    0x1f7e0, 0x1f7eb,
    0x1f7f0, 0x1f7f0,
    0x1f800, 0x1f80b,
    0x1f810, 0x1f847,
    0x1f850, 0x1f859,
    0x1f860, 0x1f887,
    0x1f890, 0x1f8ad,
    0x1f8b0, 0x1f8b1,
    0x1f900, 0x1fa53,
    0x1fa60, 0x1fa6d,
    0x1fa70, 0x1fa74,
    0x1fa78, 0x1fa7c,
    0x1fa80, 0x1fa86,
    0x1fa90, 0x1faac,
    0x1fab0, 0x1faba,
    0x1fac0, 0x1fac5,
    0x1fad0, 0x1fad9,
    0x1fae0, 0x1fae7,
    0x1faf0, 0x1faf6,
    0x1fb00, 0x1fb92,
    0x1fb94, 0x1fbca,
    0x1fbf0, 0x1fbf9,
    0x20000, 0x2a6df,
    0x2a700, 0x2b738,
    0x2b740, 0x2b81d,
    0x2b820, 0x2cea1,
    0x2ceb0, 0x2ebe0,
    0x2f800, 0x2fa1d,
    0x30000, 0x3134a,
    0xe0001, 0xe0001,
    0xe0020, 0xe007f,
    0xe0100, 0xe01ef,
];

function utf16CodeUnits(codePoint) {
    return codePoint >= 0x10000 ? 2 : 1;
}
function isHighSurrogate(ch) {
    return ch >= 0xd800 && ch <= 0xdbff;
}
function isLowSurrogate(ch) {
    return ch >= 0xdc00 && ch <= 0xdfff;
}
function isLineBreak(ch) {
    return ch === 10 /* CharCode.LineFeed */ || ch == 13 /* CharCode.CarriageReturn */;
}
function isAsciiWhiteSpaceSingleLine(ch) {
    return (ch === 32 /* CharCode.Space */ ||
        ch === 9 /* CharCode.Tab */ ||
        ch === 11 /* CharCode.VerticalTab */ ||
        ch === 12 /* CharCode.FormFeed */);
}
function isNonAsciiWhiteSpaceSingleLine(ch) {
    return (ch === 133 /* CharCode.NextLine */ || // not considered a line break
        ch === 8206 /* CharCode.LeftToRightMark */ ||
        ch === 8207 /* CharCode.RightToLeftMark */ ||
        ch === 8232 /* CharCode.LineSeparator */ ||
        ch === 8233 /* CharCode.ParagraphSeparator */);
}
function isWhiteSpace(ch) {
    return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
}
function isWhiteSpaceSingleLine(ch) {
    return (isAsciiWhiteSpaceSingleLine(ch) ||
        (ch > 127 /* CharCode.MaxAscii */ && isNonAsciiWhiteSpaceSingleLine(ch)));
}
function isDigit(ch) {
    return ch >= 48 /* CharCode._0 */ && ch <= 57 /* CharCode._9 */;
}
function isHexDigit(ch) {
    return (isDigit(ch) || (ch >= 65 /* CharCode.A */ && ch <= 70 /* CharCode.F */) || (ch >= 97 /* CharCode.a */ && ch <= 102 /* CharCode.f */));
}
function isBinaryDigit(ch) {
    return ch === 48 /* CharCode._0 */ || ch === 49 /* CharCode._1 */;
}
function isLowercaseAsciiLetter(ch) {
    return ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */;
}
function isAsciiIdentifierStart(ch) {
    return ((ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */) ||
        (ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */) ||
        ch === 36 /* CharCode.$ */ ||
        ch === 95 /* CharCode._ */);
}
function isAsciiIdentifierContinue(ch) {
    return ((ch >= 65 /* CharCode.A */ && ch <= 90 /* CharCode.Z */) ||
        (ch >= 97 /* CharCode.a */ && ch <= 122 /* CharCode.z */) ||
        (ch >= 48 /* CharCode._0 */ && ch <= 57 /* CharCode._9 */) ||
        ch === 36 /* CharCode.$ */ ||
        ch === 95 /* CharCode._ */);
}
function isIdentifierContinue(codePoint) {
    return (isAsciiIdentifierContinue(codePoint) ||
        (codePoint > 127 /* CharCode.MaxAscii */ && isNonAsciiIdentifierCharacter(codePoint)));
}
function isNonAsciiIdentifierCharacter(codePoint) {
    return lookupInNonAsciiMap(codePoint, nonAsciiIdentifierMap);
}
function codePointBefore(text, pos) {
    if (pos <= 0 || pos >= text.length) {
        return undefined;
    }
    const ch = text.charCodeAt(pos - 1);
    if (!isLowSurrogate(ch) || !isHighSurrogate(text.charCodeAt(pos - 2))) {
        return ch;
    }
    return text.codePointAt(pos - 2);
}
function lookupInNonAsciiMap(codePoint, map) {
    // Perform binary search in one of the Unicode range maps
    let lo = 0;
    let hi = map.length;
    let mid;
    while (lo + 1 < hi) {
        mid = lo + (hi - lo) / 2;
        // mid has to be even to catch a range's beginning
        mid -= mid % 2;
        if (map[mid] <= codePoint && codePoint <= map[mid + 1]) {
            return true;
        }
        if (codePoint < map[mid]) {
            hi = mid;
        }
        else {
            lo = mid + 2;
        }
    }
    return false;
}

// All conflict markers consist of the same character repeated seven times.  If it is
// a <<<<<<< or >>>>>>> marker then it is also followed by a space.
const mergeConflictMarkerLength = 7;
var Token;
(function (Token) {
    Token[Token["None"] = 0] = "None";
    Token[Token["Invalid"] = 1] = "Invalid";
    Token[Token["EndOfFile"] = 2] = "EndOfFile";
    // Trivia
    Token[Token["SingleLineComment"] = 3] = "SingleLineComment";
    Token[Token["MultiLineComment"] = 4] = "MultiLineComment";
    Token[Token["NewLine"] = 5] = "NewLine";
    Token[Token["Whitespace"] = 6] = "Whitespace";
    // We detect and provide better error recovery when we encounter a git merge marker.  This
    // allows us to edit files with git-conflict markers in them in a much more pleasant manner.
    Token[Token["ConflictMarker"] = 7] = "ConflictMarker";
    // Literals
    Token[Token["NumericLiteral"] = 8] = "NumericLiteral";
    Token[Token["StringLiteral"] = 9] = "StringLiteral";
    // Punctuation
    Token[Token["OpenBrace"] = 10] = "OpenBrace";
    Token[Token["CloseBrace"] = 11] = "CloseBrace";
    Token[Token["OpenParen"] = 12] = "OpenParen";
    Token[Token["CloseParen"] = 13] = "CloseParen";
    Token[Token["OpenBracket"] = 14] = "OpenBracket";
    Token[Token["CloseBracket"] = 15] = "CloseBracket";
    Token[Token["Dot"] = 16] = "Dot";
    Token[Token["Ellipsis"] = 17] = "Ellipsis";
    Token[Token["Semicolon"] = 18] = "Semicolon";
    Token[Token["Comma"] = 19] = "Comma";
    Token[Token["LessThan"] = 20] = "LessThan";
    Token[Token["GreaterThan"] = 21] = "GreaterThan";
    Token[Token["Equals"] = 22] = "Equals";
    Token[Token["Ampersand"] = 23] = "Ampersand";
    Token[Token["Bar"] = 24] = "Bar";
    Token[Token["Question"] = 25] = "Question";
    Token[Token["Colon"] = 26] = "Colon";
    Token[Token["ColonColon"] = 27] = "ColonColon";
    Token[Token["At"] = 28] = "At";
    Token[Token["Hash"] = 29] = "Hash";
    Token[Token["Star"] = 30] = "Star";
    Token[Token["ForwardSlash"] = 31] = "ForwardSlash";
    Token[Token["Plus"] = 32] = "Plus";
    Token[Token["Hyphen"] = 33] = "Hyphen";
    Token[Token["Exclamation"] = 34] = "Exclamation";
    Token[Token["LessThanEquals"] = 35] = "LessThanEquals";
    Token[Token["GreaterThanEquals"] = 36] = "GreaterThanEquals";
    Token[Token["AmpsersandAmpersand"] = 37] = "AmpsersandAmpersand";
    Token[Token["BarBar"] = 38] = "BarBar";
    Token[Token["EqualsEquals"] = 39] = "EqualsEquals";
    Token[Token["ExclamationEquals"] = 40] = "ExclamationEquals";
    Token[Token["EqualsGreaterThan"] = 41] = "EqualsGreaterThan";
    // Update MaxPunctuation if anything is added right above here
    // Identifiers
    Token[Token["Identifier"] = 42] = "Identifier";
    // Statement Keywords
    Token[Token["ImportKeyword"] = 43] = "ImportKeyword";
    Token[Token["ModelKeyword"] = 44] = "ModelKeyword";
    Token[Token["NamespaceKeyword"] = 45] = "NamespaceKeyword";
    Token[Token["UsingKeyword"] = 46] = "UsingKeyword";
    Token[Token["OpKeyword"] = 47] = "OpKeyword";
    Token[Token["EnumKeyword"] = 48] = "EnumKeyword";
    Token[Token["AliasKeyword"] = 49] = "AliasKeyword";
    Token[Token["IsKeyword"] = 50] = "IsKeyword";
    Token[Token["InterfaceKeyword"] = 51] = "InterfaceKeyword";
    Token[Token["UnionKeyword"] = 52] = "UnionKeyword";
    Token[Token["ProjectionKeyword"] = 53] = "ProjectionKeyword";
    Token[Token["ElseKeyword"] = 54] = "ElseKeyword";
    Token[Token["IfKeyword"] = 55] = "IfKeyword";
    // Update MaxStatementKeyword if anything is added right above here
    // Other keywords
    Token[Token["ExtendsKeyword"] = 56] = "ExtendsKeyword";
    Token[Token["TrueKeyword"] = 57] = "TrueKeyword";
    Token[Token["FalseKeyword"] = 58] = "FalseKeyword";
    Token[Token["ReturnKeyword"] = 59] = "ReturnKeyword";
    Token[Token["VoidKeyword"] = 60] = "VoidKeyword";
    Token[Token["NeverKeyword"] = 61] = "NeverKeyword";
    Token[Token["UnknownKeyword"] = 62] = "UnknownKeyword";
    // Update MaxKeyword if anything is added right above here
})(Token || (Token = {}));
const MinKeyword = Token.ImportKeyword;
const MaxKeyword = Token.UnknownKeyword;
const MinPunctuation = Token.OpenBrace;
const MaxPunctuation = Token.EqualsGreaterThan;
const MinStatementKeyword = Token.ImportKeyword;
const MaxStatementKeyword = Token.IfKeyword;
/** @internal */
const TokenDisplay = [
    "none",
    "invalid",
    "end of file",
    "single-line comment",
    "multi-line comment",
    "newline",
    "whitespace",
    "conflict marker",
    "numeric literal",
    "string literal",
    "'{'",
    "'}'",
    "'('",
    "')'",
    "'['",
    "']'",
    "'.'",
    "'...'",
    "';'",
    "','",
    "'<'",
    "'>'",
    "'='",
    "'&'",
    "'|'",
    "'?'",
    "':'",
    "'::'",
    "'@'",
    "'#'",
    "'*'",
    "'/'",
    "'+'",
    "'-'",
    "'!'",
    "'<='",
    "'>='",
    "'&&'",
    "'||'",
    "'=='",
    "'!='",
    "'=>'",
    "identifier",
    "'import'",
    "'model'",
    "'namespace'",
    "'using'",
    "'op'",
    "'enum'",
    "'alias'",
    "'is'",
    "'interface'",
    "'union'",
    "'projection'",
    "'else'",
    "'if'",
    "'extends'",
    "'true'",
    "'false'",
    "'return'",
    "'void'",
    "'never'",
    "'unknown'",
];
/** @internal */
const Keywords = [
    ["import", Token.ImportKeyword],
    ["model", Token.ModelKeyword],
    ["namespace", Token.NamespaceKeyword],
    ["interface", Token.InterfaceKeyword],
    ["union", Token.UnionKeyword],
    ["if", Token.IfKeyword],
    ["else", Token.ElseKeyword],
    ["projection", Token.ProjectionKeyword],
    ["using", Token.UsingKeyword],
    ["op", Token.OpKeyword],
    ["extends", Token.ExtendsKeyword],
    ["is", Token.IsKeyword],
    ["enum", Token.EnumKeyword],
    ["alias", Token.AliasKeyword],
    ["true", Token.TrueKeyword],
    ["false", Token.FalseKeyword],
    ["return", Token.ReturnKeyword],
    ["void", Token.VoidKeyword],
    ["never", Token.NeverKeyword],
    ["unknown", Token.UnknownKeyword],
];
const KeywordMap = new Map(Keywords.map((e) => [keywordKey(e[0]), e[1]]));
// Since keywords are short and all lowercase, we can pack the whole string into
// a single number by using 5 bits for each letter, and use that as the map key.
// This lets us lookup keywords without making temporary substrings.
function keywordKey(keyword) {
    let key = 0;
    for (let i = 0; i < keyword.length; i++) {
        key = updateKeywordKey(key, keyword.charCodeAt(i));
    }
    return key;
}
function updateKeywordKey(key, ch) {
    // Do not simplify this to (key << 5) | (ch - CharCode.a) as JavaScript
    // bitwise operations truncate to 32-bits, and that will create
    // collisions.
    return key * 32 + (ch - 97 /* CharCode.a */);
}
function isLiteral(token) {
    return (token === Token.NumericLiteral ||
        token === Token.StringLiteral ||
        token === Token.TrueKeyword ||
        token === Token.FalseKeyword);
}
function isTrivia(token) {
    return (token === Token.Whitespace ||
        token === Token.NewLine ||
        token === Token.SingleLineComment ||
        token === Token.MultiLineComment);
}
function isComment(token) {
    return token === Token.SingleLineComment || token === Token.MultiLineComment;
}
function isKeyword(token) {
    return token >= MinKeyword && token <= MaxKeyword;
}
function isPunctuation(token) {
    return token >= MinPunctuation && token <= MaxPunctuation;
}
function isStatementKeyword(token) {
    return token >= MinStatementKeyword && token <= MaxStatementKeyword;
}
function createScanner(source, diagnosticHandler) {
    const file = typeof source === "string" ? createSourceFile(source, "<anonymous file>") : source;
    const input = file.text;
    let position = 0;
    let token = Token.None;
    let tokenPosition = -1;
    let tokenFlags = 0 /* TokenFlags.None */;
    // Skip BOM
    if (input.charCodeAt(position) === 65279 /* CharCode.ByteOrderMark */) {
        position++;
    }
    return {
        get position() {
            return position;
        },
        get token() {
            return token;
        },
        get tokenPosition() {
            return tokenPosition;
        },
        file,
        scan,
        eof,
        getTokenText,
        getTokenValue,
    };
    function eof() {
        return position >= input.length;
    }
    function getTokenText() {
        return input.substring(tokenPosition, position);
    }
    function getTokenValue() {
        switch (token) {
            case Token.StringLiteral:
                return getStringTokenValue();
            case Token.Identifier:
                return getIdentifierTokenValue();
            default:
                return getTokenText();
        }
    }
    function lookAhead(offset) {
        return input.charCodeAt(position + offset);
    }
    function scan() {
        tokenPosition = position;
        tokenFlags = 0 /* TokenFlags.None */;
        if (!eof()) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 13 /* CharCode.CarriageReturn */:
                    if (lookAhead(1) === 10 /* CharCode.LineFeed */) {
                        position++;
                    }
                // fallthrough
                case 10 /* CharCode.LineFeed */:
                    return next(Token.NewLine);
                case 32 /* CharCode.Space */:
                case 9 /* CharCode.Tab */:
                case 11 /* CharCode.VerticalTab */:
                case 12 /* CharCode.FormFeed */:
                    return scanWhitespace();
                case 40 /* CharCode.OpenParen */:
                    return next(Token.OpenParen);
                case 41 /* CharCode.CloseParen */:
                    return next(Token.CloseParen);
                case 44 /* CharCode.Comma */:
                    return next(Token.Comma);
                case 58 /* CharCode.Colon */:
                    return lookAhead(1) === 58 /* CharCode.Colon */ ? next(Token.ColonColon, 2) : next(Token.Colon);
                case 59 /* CharCode.Semicolon */:
                    return next(Token.Semicolon);
                case 91 /* CharCode.OpenBracket */:
                    return next(Token.OpenBracket);
                case 93 /* CharCode.CloseBracket */:
                    return next(Token.CloseBracket);
                case 123 /* CharCode.OpenBrace */:
                    return next(Token.OpenBrace);
                case 125 /* CharCode.CloseBrace */:
                    return next(Token.CloseBrace);
                case 64 /* CharCode.At */:
                    return next(Token.At);
                case 35 /* CharCode.Hash */:
                    return next(Token.Hash);
                case 43 /* CharCode.Plus */:
                    return isDigit(lookAhead(1)) ? scanSignedNumber() : next(Token.Plus);
                case 45 /* CharCode.Minus */:
                    return isDigit(lookAhead(1)) ? scanSignedNumber() : next(Token.Hyphen);
                case 42 /* CharCode.Asterisk */:
                    return next(Token.Star);
                case 63 /* CharCode.Question */:
                    return next(Token.Question);
                case 38 /* CharCode.Ampersand */:
                    return lookAhead(1) === 38 /* CharCode.Ampersand */
                        ? next(Token.AmpsersandAmpersand, 2)
                        : next(Token.Ampersand);
                case 46 /* CharCode.Dot */:
                    return lookAhead(1) === 46 /* CharCode.Dot */ && lookAhead(2) === 46 /* CharCode.Dot */
                        ? next(Token.Ellipsis, 3)
                        : next(Token.Dot);
                case 47 /* CharCode.Slash */:
                    switch (lookAhead(1)) {
                        case 47 /* CharCode.Slash */:
                            return scanSingleLineComment();
                        case 42 /* CharCode.Asterisk */:
                            return scanMultiLineComment();
                    }
                    return next(Token.ForwardSlash);
                case 48 /* CharCode._0 */:
                    switch (lookAhead(1)) {
                        case 120 /* CharCode.x */:
                            return scanHexNumber();
                        case 98 /* CharCode.b */:
                            return scanBinaryNumber();
                    }
                // fallthrough
                case 49 /* CharCode._1 */:
                case 50 /* CharCode._2 */:
                case 51 /* CharCode._3 */:
                case 52 /* CharCode._4 */:
                case 53 /* CharCode._5 */:
                case 54 /* CharCode._6 */:
                case 55 /* CharCode._7 */:
                case 56 /* CharCode._8 */:
                case 57 /* CharCode._9 */:
                    return scanNumber();
                case 60 /* CharCode.LessThan */:
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.LessThanEquals, 2)
                        : isConflictMarker()
                            ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                            : next(Token.LessThan);
                case 62 /* CharCode.GreaterThan */:
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.GreaterThanEquals, 2)
                        : isConflictMarker()
                            ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                            : next(Token.GreaterThan);
                case 61 /* CharCode.Equals */:
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.EqualsEquals, 2)
                        : lookAhead(1) === 62 /* CharCode.GreaterThan */
                            ? next(Token.EqualsGreaterThan, 2)
                            : isConflictMarker()
                                ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                                : next(Token.Equals);
                case 124 /* CharCode.Bar */:
                    return lookAhead(1) === 124 /* CharCode.Bar */
                        ? next(Token.BarBar, 2)
                        : isConflictMarker()
                            ? next(Token.ConflictMarker, mergeConflictMarkerLength)
                            : next(Token.Bar);
                case 34 /* CharCode.DoubleQuote */:
                    return lookAhead(1) === 34 /* CharCode.DoubleQuote */ && lookAhead(2) === 34 /* CharCode.DoubleQuote */
                        ? scanTripleQuotedString()
                        : scanString();
                case 33 /* CharCode.Exclamation */:
                    return lookAhead(1) === 61 /* CharCode.Equals */
                        ? next(Token.ExclamationEquals, 2)
                        : next(Token.Exclamation);
                default:
                    if (isLowercaseAsciiLetter(ch)) {
                        return scanIdentifierOrKeyword();
                    }
                    if (isAsciiIdentifierStart(ch)) {
                        return scanIdentifier();
                    }
                    if (ch <= 127 /* CharCode.MaxAscii */) {
                        return scanInvalidCharacter();
                    }
                    return scanNonAsciiToken();
            }
        }
        return (token = Token.EndOfFile);
    }
    function next(t, count = 1) {
        position += count;
        return (token = t);
    }
    function unterminated(t) {
        tokenFlags |= 4 /* TokenFlags.Unterminated */;
        error({ code: "unterminated", format: { token: TokenDisplay[t] } });
        return (token = t);
    }
    function scanNonAsciiToken() {
        tokenFlags |= 8 /* TokenFlags.NonAscii */;
        const ch = input.charCodeAt(position);
        if (isNonAsciiWhiteSpaceSingleLine(ch)) {
            return scanWhitespace();
        }
        const cp = input.codePointAt(position);
        if (isNonAsciiIdentifierCharacter(cp)) {
            return scanNonAsciiIdentifier(cp);
        }
        return scanInvalidCharacter();
    }
    function scanInvalidCharacter() {
        const codePoint = input.codePointAt(position);
        token = next(Token.Invalid, utf16CodeUnits(codePoint));
        error({ code: "invalid-character" });
        return token;
    }
    function isConflictMarker() {
        // Conflict markers must be at the start of a line.
        const ch = input.charCodeAt(position);
        if (position === 0 || isLineBreak(input.charCodeAt(position - 1))) {
            if (position + mergeConflictMarkerLength < input.length) {
                for (let i = 0; i < mergeConflictMarkerLength; i++) {
                    if (lookAhead(i) !== ch) {
                        return false;
                    }
                }
                return ch === 61 /* CharCode.Equals */ || lookAhead(mergeConflictMarkerLength) === 32 /* CharCode.Space */;
            }
        }
        return false;
    }
    function error(report) {
        const diagnostic = createDiagnostic({
            ...report,
            target: { file, pos: tokenPosition, end: position },
        });
        diagnosticHandler(diagnostic);
    }
    function scanWhitespace() {
        do {
            position++;
        } while (!eof() && isWhiteSpaceSingleLine(input.charCodeAt(position)));
        return (token = Token.Whitespace);
    }
    function scanSignedNumber() {
        position++; // consume '+/-'
        return scanNumber();
    }
    function scanNumber() {
        scanKnownDigits();
        if (!eof() && input.charCodeAt(position) === 46 /* CharCode.Dot */) {
            position++;
            scanRequiredDigits();
        }
        if (!eof() && input.charCodeAt(position) === 101 /* CharCode.e */) {
            position++;
            const ch = input.charCodeAt(position);
            if (ch === 43 /* CharCode.Plus */ || ch === 45 /* CharCode.Minus */) {
                position++;
            }
            scanRequiredDigits();
        }
        return (token = Token.NumericLiteral);
    }
    function scanKnownDigits() {
        do {
            position++;
        } while (!eof() && isDigit(input.charCodeAt(position)));
    }
    function scanRequiredDigits() {
        if (eof() || !isDigit(input.charCodeAt(position))) {
            error({ code: "digit-expected" });
            return;
        }
        scanKnownDigits();
    }
    function scanHexNumber() {
        position += 2; // consume '0x'
        if (eof() || !isHexDigit(input.charCodeAt(position))) {
            error({ code: "hex-digit-expected" });
            return (token = Token.NumericLiteral);
        }
        do {
            position++;
        } while (!eof() && isHexDigit(input.charCodeAt(position)));
        return (token = Token.NumericLiteral);
    }
    function scanBinaryNumber() {
        position += 2; // consume '0b'
        if (eof() || !isBinaryDigit(input.charCodeAt(position))) {
            error({ code: "binary-digit-expected" });
            return (token = Token.NumericLiteral);
        }
        do {
            position++;
        } while (!eof() && isBinaryDigit(input.charCodeAt(position)));
        return (token = Token.NumericLiteral);
    }
    function scanSingleLineComment() {
        position = skipSingleLineComment(input, position);
        return (token = Token.SingleLineComment);
    }
    function scanMultiLineComment() {
        const [newPosition, terminated] = skipMultiLineComment(input, position);
        position = newPosition;
        token = Token.MultiLineComment;
        return terminated ? token : unterminated(token);
    }
    function scanString() {
        position++; // consume '"'
        loop: for (; !eof(); position++) {
            const ch = input.charCodeAt(position);
            switch (ch) {
                case 92 /* CharCode.Backslash */:
                    tokenFlags |= 1 /* TokenFlags.Escaped */;
                    position++;
                    if (eof()) {
                        break loop;
                    }
                    continue;
                case 34 /* CharCode.DoubleQuote */:
                    position++;
                    return (token = Token.StringLiteral);
                case 13 /* CharCode.CarriageReturn */:
                case 10 /* CharCode.LineFeed */:
                    break loop;
            }
        }
        return unterminated(Token.StringLiteral);
    }
    function scanTripleQuotedString() {
        tokenFlags |= 2 /* TokenFlags.TripleQuoted */;
        position += 3; // consume '"""'
        for (; !eof(); position++) {
            if (input.charCodeAt(position) === 34 /* CharCode.DoubleQuote */ &&
                lookAhead(1) === 34 /* CharCode.DoubleQuote */ &&
                lookAhead(2) === 34 /* CharCode.DoubleQuote */) {
                position += 3;
                return (token = Token.StringLiteral);
            }
        }
        return unterminated(Token.StringLiteral);
    }
    function getStringTokenValue() {
        const quoteLength = tokenFlags & 2 /* TokenFlags.TripleQuoted */ ? 3 : 1;
        const start = tokenPosition + quoteLength;
        const end = tokenFlags & 4 /* TokenFlags.Unterminated */ ? position : position - quoteLength;
        if (tokenFlags & 2 /* TokenFlags.TripleQuoted */) {
            return unindentAndUnescapeTripleQuotedString(start, end);
        }
        if (tokenFlags & 1 /* TokenFlags.Escaped */) {
            return unescapeString(start, end);
        }
        return input.substring(start, end);
    }
    function getIdentifierTokenValue() {
        const text = getTokenText();
        return tokenFlags & 8 /* TokenFlags.NonAscii */ ? text.normalize("NFC") : text;
    }
    function unindentAndUnescapeTripleQuotedString(start, end) {
        // ignore leading whitespace before required initial line break
        while (start < end && isWhiteSpaceSingleLine(input.charCodeAt(start))) {
            start++;
        }
        // remove required initial line break
        if (isLineBreak(input.charCodeAt(start))) {
            if (isCrlf(start, start, end)) {
                start++;
            }
            start++;
        }
        else {
            error({ code: "no-new-line-start-triple-quote" });
        }
        // remove whitespace before closing delimiter and record it as required
        // indentation for all lines
        const indentationEnd = end;
        while (end > start && isWhiteSpaceSingleLine(input.charCodeAt(end - 1))) {
            end--;
        }
        const indentationStart = end;
        // remove required final line break
        if (isLineBreak(input.charCodeAt(end - 1))) {
            if (isCrlf(end - 2, start, end)) {
                end--;
            }
            end--;
        }
        else {
            error({ code: "no-new-line-end-triple-quote" });
        }
        // remove required matching indentation from each line and unescape in the
        // process of doing so
        let result = "";
        let pos = start;
        while (pos < end) {
            // skip indentation at start of line
            start = skipMatchingIndentation(pos, end, indentationStart, indentationEnd);
            let ch;
            while (pos < end && !isLineBreak((ch = input.charCodeAt(pos)))) {
                if (ch !== 92 /* CharCode.Backslash */) {
                    pos++;
                    continue;
                }
                result += input.substring(start, pos);
                if (pos === end - 1) {
                    error({ code: "invalid-escape-sequence" });
                    pos++;
                }
                else {
                    result += unescapeOne(pos);
                    pos += 2;
                }
                start = pos;
            }
            if (pos < end) {
                if (isCrlf(pos, start, end)) {
                    // CRLF in multi-line string is normalized to LF in string value.
                    // This keeps program behavior unchanged by line-eding conversion.
                    result += input.substring(start, pos);
                    result += "\n";
                    pos += 2;
                }
                else {
                    pos++; // include non-CRLF newline
                    result += input.substring(start, pos);
                }
                start = pos;
            }
        }
        result += input.substring(start, pos);
        return result;
    }
    function isCrlf(pos, start, end) {
        return (pos >= start &&
            pos < end - 1 &&
            input.charCodeAt(pos) === 13 /* CharCode.CarriageReturn */ &&
            input.charCodeAt(pos + 1) === 10 /* CharCode.LineFeed */);
    }
    function skipMatchingIndentation(pos, end, indentationStart, indentationEnd) {
        let indentationPos = indentationStart;
        end = Math.min(end, pos + (indentationEnd - indentationStart));
        while (pos < end) {
            const ch = input.charCodeAt(pos);
            if (isLineBreak(ch)) {
                // allow subset of indentation if line has only whitespace
                break;
            }
            if (ch !== input.charCodeAt(indentationPos)) {
                error({ code: "triple-quote-indent" });
                break;
            }
            indentationPos++;
            pos++;
        }
        return pos;
    }
    function unescapeString(start, end) {
        let result = "";
        let pos = start;
        while (pos < end) {
            const ch = input.charCodeAt(pos);
            if (ch !== 92 /* CharCode.Backslash */) {
                pos++;
                continue;
            }
            if (pos === end - 1) {
                error({ code: "invalid-escape-sequence" });
                break;
            }
            result += input.substring(start, pos);
            result += unescapeOne(pos);
            pos += 2;
            start = pos;
        }
        result += input.substring(start, pos);
        return result;
    }
    function unescapeOne(pos) {
        const ch = input.charCodeAt(pos + 1);
        switch (ch) {
            case 114 /* CharCode.r */:
                return "\r";
            case 110 /* CharCode.n */:
                return "\n";
            case 116 /* CharCode.t */:
                return "\t";
            case 34 /* CharCode.DoubleQuote */:
                return '"';
            case 92 /* CharCode.Backslash */:
                return "\\";
            default:
                error({ code: "invalid-escape-sequence" });
                return String.fromCharCode(ch);
        }
    }
    function scanIdentifierOrKeyword() {
        let key = 0;
        let count = 0;
        let ch = input.charCodeAt(position);
        while (true) {
            position++;
            count++;
            key = updateKeywordKey(key, ch);
            if (eof()) {
                break;
            }
            ch = input.charCodeAt(position);
            if (count < 10 /* KeywordLimit.MaxLength */ && isLowercaseAsciiLetter(ch)) {
                continue;
            }
            if (isAsciiIdentifierContinue(ch)) {
                return scanIdentifier();
            }
            if (ch > 127 /* CharCode.MaxAscii */) {
                const cp = input.codePointAt(position);
                if (isNonAsciiIdentifierCharacter(cp)) {
                    return scanNonAsciiIdentifier(cp);
                }
            }
            break;
        }
        if (count >= 2 /* KeywordLimit.MinLength */ && count <= 10 /* KeywordLimit.MaxLength */) {
            const keyword = KeywordMap.get(key);
            if (keyword) {
                return (token = keyword);
            }
        }
        return (token = Token.Identifier);
    }
    function scanIdentifier() {
        let ch;
        do {
            position++;
            if (eof()) {
                return (token = Token.Identifier);
            }
        } while (isAsciiIdentifierContinue((ch = input.charCodeAt(position))));
        if (ch > 127 /* CharCode.MaxAscii */) {
            const cp = input.codePointAt(position);
            if (isNonAsciiIdentifierCharacter(cp)) {
                return scanNonAsciiIdentifier(cp);
            }
        }
        return (token = Token.Identifier);
    }
    function scanNonAsciiIdentifier(startCodePoint) {
        tokenFlags |= 8 /* TokenFlags.NonAscii */;
        let cp = startCodePoint;
        do {
            position += utf16CodeUnits(cp);
        } while (!eof() && isIdentifierContinue((cp = input.codePointAt(position))));
        return (token = Token.Identifier);
    }
}
function skipTrivia(input, position) {
    while (position < input.length) {
        const ch = input.charCodeAt(position);
        if (isWhiteSpace(ch)) {
            position++;
            continue;
        }
        if (ch === 47 /* CharCode.Slash */) {
            switch (input.charCodeAt(position + 1)) {
                case 47 /* CharCode.Slash */:
                    position = skipSingleLineComment(input, position);
                    continue;
                case 42 /* CharCode.Asterisk */:
                    position = skipMultiLineComment(input, position)[0];
                    continue;
            }
        }
        break;
    }
    return position;
}
function skipWhiteSpace(input, position) {
    while (position < input.length) {
        const ch = input.charCodeAt(position);
        if (!isWhiteSpace(ch)) {
            break;
        }
        position++;
    }
    return position;
}
function skipSingleLineComment(input, position) {
    position += 2; // consume '//'
    for (; position < input.length; position++) {
        if (isLineBreak(input.charCodeAt(position))) {
            break;
        }
    }
    return position;
}
function skipMultiLineComment(input, position) {
    position += 2; // consume '/*'
    for (; position < input.length; position++) {
        if (input.charCodeAt(position) === 42 /* CharCode.Asterisk */ &&
            input.charCodeAt(position + 1) === 47 /* CharCode.Slash */) {
            return [position + 2, true];
        }
    }
    return [position, false];
}

/**
 * The fixed set of options for each of the kinds of delimited lists in Cadl.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var ListKind;
(function (ListKind) {
    const PropertiesBase = {
        allowEmpty: true,
        toleratedDelimiterIsValid: true,
        trailingDelimiterIsValid: true,
        allowedStatementKeyword: Token.None,
    };
    ListKind.OperationParameters = {
        ...PropertiesBase,
        open: Token.OpenParen,
        close: Token.CloseParen,
        delimiter: Token.Comma,
        toleratedDelimiter: Token.Semicolon,
    };
    ListKind.DecoratorArguments = {
        ...ListKind.OperationParameters,
        invalidDecoratorTarget: "expression",
    };
    ListKind.ModelProperties = {
        ...PropertiesBase,
        open: Token.OpenBrace,
        close: Token.CloseBrace,
        delimiter: Token.Semicolon,
        toleratedDelimiter: Token.Comma,
    };
    ListKind.InterfaceMembers = {
        ...PropertiesBase,
        open: Token.OpenBrace,
        close: Token.CloseBrace,
        delimiter: Token.Semicolon,
        toleratedDelimiter: Token.Comma,
        toleratedDelimiterIsValid: false,
        allowedStatementKeyword: Token.OpKeyword,
    };
    ListKind.UnionVariants = {
        ...PropertiesBase,
        open: Token.OpenBrace,
        close: Token.CloseBrace,
        delimiter: Token.Semicolon,
        toleratedDelimiter: Token.Comma,
        toleratedDelimiterIsValid: true,
    };
    ListKind.EnumMembers = {
        ...ListKind.ModelProperties,
    };
    const ExpresionsBase = {
        allowEmpty: true,
        delimiter: Token.Comma,
        toleratedDelimiter: Token.Semicolon,
        toleratedDelimiterIsValid: false,
        trailingDelimiterIsValid: false,
        invalidDecoratorTarget: "expression",
        allowedStatementKeyword: Token.None,
    };
    ListKind.TemplateParameters = {
        ...ExpresionsBase,
        allowEmpty: false,
        open: Token.LessThan,
        close: Token.GreaterThan,
        invalidDecoratorTarget: "template parameter",
    };
    ListKind.TemplateArguments = {
        ...ListKind.TemplateParameters,
    };
    ListKind.CallArguments = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
    };
    ListKind.Heritage = {
        ...ExpresionsBase,
        allowEmpty: false,
        open: Token.None,
        close: Token.None,
    };
    ListKind.Tuple = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenBracket,
        close: Token.CloseBracket,
    };
    ListKind.ProjectionExpression = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
    };
    ListKind.ProjectionParameter = {
        ...ExpresionsBase,
        allowEmpty: true,
        open: Token.OpenParen,
        close: Token.CloseParen,
    };
})(ListKind || (ListKind = {}));
function parse$1(code, options = {}) {
    let parseErrorInNextFinishedNode = false;
    let previousTokenEnd = -1;
    let realPositionOfLastError = -1;
    let missingIdentifierCounter = 0;
    let treePrintable = true;
    let newLineIsTrivia = true;
    const parseDiagnostics = [];
    const scanner = createScanner(code, reportDiagnostic);
    const comments = [];
    nextToken();
    return parseCadlScript();
    function parseCadlScript() {
        const statements = parseCadlScriptItemList();
        return {
            kind: SyntaxKind.CadlScript,
            statements,
            file: scanner.file,
            id: {
                kind: SyntaxKind.Identifier,
                sv: scanner.file.path,
                pos: 0,
                end: 0,
                flags: 8 /* NodeFlags.Synthetic */,
            },
            namespaces: [],
            usings: [],
            locals: createSymbolTable(),
            inScopeNamespaces: [],
            parseDiagnostics,
            comments,
            printable: treePrintable,
            ...finishNode(0),
        };
    }
    function parseCadlScriptItemList() {
        const stmts = [];
        let seenBlocklessNs = false;
        let seenDecl = false;
        let seenUsing = false;
        while (token() !== Token.EndOfFile) {
            const pos = tokenPos();
            const directives = parseDirectiveList();
            const decorators = parseDecoratorList();
            const tok = token();
            let item;
            switch (tok) {
                case Token.ImportKeyword:
                    reportInvalidDecorators(decorators, "import statement");
                    item = parseImportStatement();
                    break;
                case Token.ModelKeyword:
                    item = parseModelStatement(pos, decorators);
                    break;
                case Token.NamespaceKeyword:
                    item = parseNamespaceStatement(pos, decorators);
                    break;
                case Token.InterfaceKeyword:
                    item = parseInterfaceStatement(pos, decorators);
                    break;
                case Token.UnionKeyword:
                    item = parseUnionStatement(pos, decorators);
                    break;
                case Token.OpKeyword:
                    item = parseOperationStatement(pos, decorators);
                    break;
                case Token.EnumKeyword:
                    item = parseEnumStatement(pos, decorators);
                    break;
                case Token.AliasKeyword:
                    reportInvalidDecorators(decorators, "alias statement");
                    item = parseAliasStatement();
                    break;
                case Token.UsingKeyword:
                    reportInvalidDecorators(decorators, "using statement");
                    item = parseUsingStatement();
                    break;
                case Token.ProjectionKeyword:
                    reportInvalidDecorators(decorators, "projection statement");
                    item = parseProjectionStatement();
                    break;
                case Token.Semicolon:
                    reportInvalidDecorators(decorators, "empty statement");
                    item = parseEmptyStatement();
                    break;
                default:
                    item = parseInvalidStatement(pos, decorators);
                    break;
            }
            item.directives = directives;
            if (isBlocklessNamespace(item)) {
                if (seenBlocklessNs) {
                    error({ code: "multiple-blockless-namespace", target: item });
                }
                if (seenDecl) {
                    error({ code: "blockless-namespace-first", target: item });
                }
                seenBlocklessNs = true;
            }
            else if (item.kind === SyntaxKind.ImportStatement) {
                if (seenDecl || seenBlocklessNs || seenUsing) {
                    error({ code: "import-first", target: item });
                }
            }
            else if (item.kind === SyntaxKind.UsingStatement) {
                seenUsing = true;
            }
            else {
                seenDecl = true;
            }
            stmts.push(item);
        }
        return stmts;
    }
    function parseStatementList() {
        const stmts = [];
        while (token() !== Token.CloseBrace) {
            const pos = tokenPos();
            const directives = parseDirectiveList();
            const decorators = parseDecoratorList();
            const tok = token();
            let item;
            switch (tok) {
                case Token.ImportKeyword:
                    reportInvalidDecorators(decorators, "import statement");
                    item = parseImportStatement();
                    error({ code: "import-first", messageId: "topLevel", target: item });
                    break;
                case Token.ModelKeyword:
                    item = parseModelStatement(pos, decorators);
                    break;
                case Token.NamespaceKeyword:
                    const ns = parseNamespaceStatement(pos, decorators);
                    if (!Array.isArray(ns.statements)) {
                        error({ code: "blockless-namespace-first", messageId: "topLevel", target: ns });
                    }
                    item = ns;
                    break;
                case Token.InterfaceKeyword:
                    item = parseInterfaceStatement(pos, decorators);
                    break;
                case Token.UnionKeyword:
                    item = parseUnionStatement(pos, decorators);
                    break;
                case Token.OpKeyword:
                    item = parseOperationStatement(pos, decorators);
                    break;
                case Token.EnumKeyword:
                    item = parseEnumStatement(pos, decorators);
                    break;
                case Token.AliasKeyword:
                    reportInvalidDecorators(decorators, "alias statement");
                    item = parseAliasStatement();
                    break;
                case Token.UsingKeyword:
                    reportInvalidDecorators(decorators, "using statement");
                    item = parseUsingStatement();
                    break;
                case Token.ProjectionKeyword:
                    reportInvalidDecorators(decorators, "project statement");
                    item = parseProjectionStatement();
                    break;
                case Token.EndOfFile:
                    parseExpected(Token.CloseBrace);
                    return stmts;
                case Token.Semicolon:
                    reportInvalidDecorators(decorators, "empty statement");
                    item = parseEmptyStatement();
                    break;
                default:
                    item = parseInvalidStatement(pos, decorators);
                    break;
            }
            item.directives = directives;
            stmts.push(item);
        }
        return stmts;
    }
    function parseDecoratorList() {
        const decorators = [];
        while (token() === Token.At) {
            decorators.push(parseDecoratorExpression());
        }
        return decorators;
    }
    function parseDirectiveList() {
        const directives = [];
        while (token() === Token.Hash) {
            directives.push(parseDirectiveExpression());
        }
        return directives;
    }
    function parseNamespaceStatement(pos, decorators) {
        parseExpected(Token.NamespaceKeyword);
        let currentName = parseIdentifierOrMemberExpression();
        const nsSegments = [];
        while (currentName.kind !== SyntaxKind.Identifier) {
            nsSegments.push(currentName.id);
            currentName = currentName.base;
        }
        nsSegments.push(currentName);
        const nextTok = parseExpectedOneOf(Token.Semicolon, Token.OpenBrace);
        let statements;
        if (nextTok === Token.OpenBrace) {
            statements = parseStatementList();
            parseExpected(Token.CloseBrace);
        }
        let outerNs = {
            kind: SyntaxKind.NamespaceStatement,
            decorators,
            id: nsSegments[0],
            statements,
            ...finishNode(pos),
        };
        for (let i = 1; i < nsSegments.length; i++) {
            outerNs = {
                kind: SyntaxKind.NamespaceStatement,
                decorators: [],
                id: nsSegments[i],
                statements: outerNs,
                ...finishNode(pos),
            };
        }
        return outerNs;
    }
    function parseInterfaceStatement(pos, decorators) {
        parseExpected(Token.InterfaceKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        let extendList = [];
        if (token() === Token.ExtendsKeyword) {
            nextToken();
            extendList = parseList(ListKind.Heritage, parseReferenceExpression);
        }
        else if (token() === Token.Identifier) {
            error({ code: "token-expected", format: { token: "'extends' or '{'" } });
            nextToken();
        }
        const operations = parseList(ListKind.InterfaceMembers, (pos, decorators) => parseOperationStatement(pos, decorators, true));
        return {
            kind: SyntaxKind.InterfaceStatement,
            id,
            templateParameters,
            operations,
            extends: extendList,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseTemplateParameterList() {
        const list = parseOptionalList(ListKind.TemplateParameters, parseTemplateParameter);
        let setDefault = false;
        for (const item of list) {
            if (!item.default && setDefault) {
                error({ code: "default-required", target: item });
                continue;
            }
            if (item.default) {
                setDefault = true;
            }
        }
        return list;
    }
    function parseUnionStatement(pos, decorators) {
        parseExpected(Token.UnionKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        const options = parseList(ListKind.UnionVariants, parseUnionVariant);
        return {
            kind: SyntaxKind.UnionStatement,
            id,
            templateParameters,
            decorators,
            options,
            ...finishNode(pos),
        };
    }
    function parseUnionVariant(pos, decorators) {
        const id = token() === Token.StringLiteral ? parseStringLiteral() : parseIdentifier("property");
        parseExpected(Token.Colon);
        const value = parseExpression();
        return {
            kind: SyntaxKind.UnionVariant,
            id,
            value,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseUsingStatement() {
        const pos = tokenPos();
        parseExpected(Token.UsingKeyword);
        const name = parseIdentifierOrMemberExpression(undefined, true);
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.UsingStatement,
            name,
            ...finishNode(pos),
        };
    }
    function parseOperationStatement(pos, decorators, inInterface) {
        if (inInterface) {
            parseOptional(Token.OpKeyword);
        }
        else {
            parseExpected(Token.OpKeyword);
        }
        const id = parseIdentifier();
        const templateParameters = inInterface ? [] : parseTemplateParameterList();
        // Make sure the next token is one that is expected
        const token = expectTokenIsOneOf(Token.OpenParen, Token.IsKeyword);
        // Check if we're parsing a declaration or reuse of another operation
        let signature;
        const signaturePos = tokenPos();
        if (token === Token.OpenParen) {
            const parameters = parseOperationParameters();
            parseExpected(Token.Colon);
            const returnType = parseExpression();
            signature = {
                kind: SyntaxKind.OperationSignatureDeclaration,
                parameters,
                returnType,
                ...finishNode(signaturePos),
            };
        }
        else {
            parseExpected(Token.IsKeyword);
            const opReference = parseReferenceExpression();
            signature = {
                kind: SyntaxKind.OperationSignatureReference,
                baseOperation: opReference,
                ...finishNode(signaturePos),
            };
        }
        // The interface parser handles semicolon parsing between statements
        if (!inInterface) {
            parseExpected(Token.Semicolon);
        }
        return {
            kind: SyntaxKind.OperationStatement,
            id,
            templateParameters,
            signature,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseOperationParameters() {
        const pos = tokenPos();
        const properties = parseList(ListKind.OperationParameters, parseModelPropertyOrSpread);
        const parameters = {
            kind: SyntaxKind.ModelExpression,
            properties,
            ...finishNode(pos),
        };
        return parameters;
    }
    function parseModelStatement(pos, decorators) {
        parseExpected(Token.ModelKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        expectTokenIsOneOf(Token.OpenBrace, Token.Equals, Token.ExtendsKeyword, Token.IsKeyword);
        const optionalExtends = parseOptionalModelExtends();
        const optionalIs = optionalExtends ? undefined : parseOptionalModelIs();
        let properties = [];
        if (optionalIs) {
            const tok = expectTokenIsOneOf(Token.Semicolon, Token.OpenBrace);
            if (tok === Token.Semicolon) {
                nextToken();
            }
            else {
                properties = parseList(ListKind.ModelProperties, parseModelPropertyOrSpread);
            }
        }
        else {
            properties = parseList(ListKind.ModelProperties, parseModelPropertyOrSpread);
        }
        return {
            kind: SyntaxKind.ModelStatement,
            id,
            extends: optionalExtends,
            is: optionalIs,
            templateParameters,
            decorators,
            properties,
            ...finishNode(pos),
        };
    }
    function parseOptionalModelExtends() {
        if (parseOptional(Token.ExtendsKeyword)) {
            return parseExpression();
        }
        return undefined;
    }
    function parseOptionalModelIs() {
        if (parseOptional(Token.IsKeyword)) {
            return parseExpression();
        }
        return;
    }
    function parseTemplateParameter() {
        const pos = tokenPos();
        const id = parseIdentifier();
        let constraint;
        if (parseOptional(Token.ExtendsKeyword)) {
            constraint = parseExpression();
        }
        let def;
        if (parseOptional(Token.Equals)) {
            def = parseExpression();
        }
        return {
            kind: SyntaxKind.TemplateParameterDeclaration,
            id,
            constraint,
            default: def,
            ...finishNode(pos),
        };
    }
    function parseModelPropertyOrSpread(pos, decorators) {
        return token() === Token.Ellipsis
            ? parseModelSpreadProperty(pos, decorators)
            : parseModelProperty(pos, decorators);
    }
    function parseModelSpreadProperty(pos, decorators) {
        parseExpected(Token.Ellipsis);
        reportInvalidDecorators(decorators, "spread property");
        // This could be broadened to allow any type expression
        const target = parseReferenceExpression();
        return {
            kind: SyntaxKind.ModelSpreadProperty,
            target,
            ...finishNode(pos),
        };
    }
    function parseModelProperty(pos, decorators) {
        const id = token() === Token.StringLiteral ? parseStringLiteral() : parseIdentifier("property");
        const optional = parseOptional(Token.Question);
        parseExpected(Token.Colon);
        const value = parseExpression();
        const hasDefault = parseOptional(Token.Equals);
        if (hasDefault && !optional) {
            error({ code: "default-optional" });
        }
        const defaultValue = hasDefault ? parseExpression() : undefined;
        return {
            kind: SyntaxKind.ModelProperty,
            id,
            decorators,
            value,
            optional,
            default: defaultValue,
            ...finishNode(pos),
        };
    }
    function parseEnumStatement(pos, decorators) {
        parseExpected(Token.EnumKeyword);
        const id = parseIdentifier();
        const members = parseList(ListKind.EnumMembers, parseEnumMemberOrSpread);
        return {
            kind: SyntaxKind.EnumStatement,
            id,
            decorators,
            members,
            ...finishNode(pos),
        };
    }
    function parseEnumMemberOrSpread(pos, decorators) {
        return token() === Token.Ellipsis
            ? parseEnumSpreadMember(pos, decorators)
            : parseEnumMember(pos, decorators);
    }
    function parseEnumSpreadMember(pos, decorators) {
        parseExpected(Token.Ellipsis);
        reportInvalidDecorators(decorators, "spread enum");
        const target = parseReferenceExpression();
        return {
            kind: SyntaxKind.EnumSpreadMember,
            target,
            ...finishNode(pos),
        };
    }
    function parseEnumMember(pos, decorators) {
        const id = token() === Token.StringLiteral ? parseStringLiteral() : parseIdentifier("enumMember");
        let value;
        if (parseOptional(Token.Colon)) {
            const expr = parseExpression();
            if (expr.kind === SyntaxKind.StringLiteral || expr.kind === SyntaxKind.NumericLiteral) {
                value = expr;
            }
            else if (expr.kind === SyntaxKind.TypeReference &&
                expr.target.flags & 2 /* NodeFlags.ThisNodeHasError */) {
                parseErrorInNextFinishedNode = true;
            }
            else {
                error({ code: "token-expected", messageId: "numericOrStringLiteral", target: expr });
            }
        }
        return {
            kind: SyntaxKind.EnumMember,
            id,
            value,
            decorators,
            ...finishNode(pos),
        };
    }
    function parseAliasStatement() {
        const pos = tokenPos();
        parseExpected(Token.AliasKeyword);
        const id = parseIdentifier();
        const templateParameters = parseTemplateParameterList();
        parseExpected(Token.Equals);
        const value = parseExpression();
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.AliasStatement,
            id,
            templateParameters,
            value,
            ...finishNode(pos),
        };
    }
    function parseExpression() {
        return parseUnionExpressionOrHigher();
    }
    function parseUnionExpressionOrHigher() {
        const pos = tokenPos();
        parseOptional(Token.Bar);
        const node = parseIntersectionExpressionOrHigher();
        if (token() !== Token.Bar) {
            return node;
        }
        const options = [node];
        while (parseOptional(Token.Bar)) {
            const expr = parseIntersectionExpressionOrHigher();
            options.push(expr);
        }
        return {
            kind: SyntaxKind.UnionExpression,
            options,
            ...finishNode(pos),
        };
    }
    function parseIntersectionExpressionOrHigher() {
        const pos = tokenPos();
        parseOptional(Token.Ampersand);
        const node = parseArrayExpressionOrHigher();
        if (token() !== Token.Ampersand) {
            return node;
        }
        const options = [node];
        while (parseOptional(Token.Ampersand)) {
            const expr = parseArrayExpressionOrHigher();
            options.push(expr);
        }
        return {
            kind: SyntaxKind.IntersectionExpression,
            options,
            ...finishNode(pos),
        };
    }
    function parseArrayExpressionOrHigher() {
        const pos = tokenPos();
        let expr = parsePrimaryExpression();
        while (parseOptional(Token.OpenBracket)) {
            parseExpected(Token.CloseBracket);
            expr = {
                kind: SyntaxKind.ArrayExpression,
                elementType: expr,
                ...finishNode(pos),
            };
        }
        return expr;
    }
    function parseReferenceExpression(message) {
        const pos = tokenPos();
        const target = parseIdentifierOrMemberExpression(message);
        const args = parseOptionalList(ListKind.TemplateArguments, parseExpression);
        return {
            kind: SyntaxKind.TypeReference,
            target,
            arguments: args,
            ...finishNode(pos),
        };
    }
    function parseImportStatement() {
        const pos = tokenPos();
        parseExpected(Token.ImportKeyword);
        const path = parseStringLiteral();
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.ImportStatement,
            path,
            ...finishNode(pos),
        };
    }
    function parseDecoratorExpression() {
        const pos = tokenPos();
        parseExpected(Token.At);
        // Error recovery: false arg here means don't treat a keyword as an
        // identifier. We want to parse `@ model Foo` as invalid decorator
        // `@<missing identifier>` applied to `model Foo`, and not as `@model`
        // applied to invalid statement `Foo`.
        const target = parseIdentifierOrMemberExpression(undefined, false);
        const args = parseOptionalList(ListKind.DecoratorArguments, parseExpression);
        return {
            kind: SyntaxKind.DecoratorExpression,
            arguments: args,
            target,
            ...finishNode(pos),
        };
    }
    function parseDirectiveExpression() {
        const pos = tokenPos();
        parseExpected(Token.Hash);
        const target = parseIdentifier();
        if (target.sv !== "suppress") {
            error({
                code: "unknown-directive",
                format: { id: target.sv },
                target: { pos, end: pos + target.sv.length },
                printable: true,
            });
        }
        // The newline will mark the end of the directive.
        newLineIsTrivia = false;
        const args = [];
        while (token() !== Token.NewLine && token() !== Token.EndOfFile) {
            const param = parseDirectiveParameter();
            if (param) {
                args.push(param);
            }
        }
        newLineIsTrivia = true;
        nextToken();
        return {
            kind: SyntaxKind.DirectiveExpression,
            arguments: args,
            target,
            ...finishNode(pos),
        };
    }
    function parseDirectiveParameter() {
        switch (token()) {
            case Token.Identifier:
                return parseIdentifier();
            case Token.StringLiteral:
                return parseStringLiteral();
            default:
                error({
                    code: "token-expected",
                    messageId: "unexpected",
                    format: { token: Token[token()] },
                });
                do {
                    nextToken();
                } while (!isStatementKeyword(token()) &&
                    token() != Token.NewLine &&
                    token() != Token.At &&
                    token() != Token.Semicolon &&
                    token() != Token.EndOfFile);
                return undefined;
        }
    }
    function parseIdentifierOrMemberExpression(message, recoverFromKeyword = true) {
        const pos = tokenPos();
        let base = parseIdentifier(message, recoverFromKeyword);
        while (parseOptional(Token.Dot)) {
            base = {
                kind: SyntaxKind.MemberExpression,
                base,
                // Error recovery: false arg here means don't treat a keyword as an
                // identifier after `.` in member expression. Otherwise we will
                // parse `@Outer.<missing identifier> model M{}` as having decorator
                // `@Outer.model` applied to invalid statement `M {}` instead of
                // having incomplete decorator `@Outer.` applied to `model M {}`.
                id: parseIdentifier(undefined, false),
                ...finishNode(pos),
            };
        }
        return base;
    }
    function parsePrimaryExpression() {
        while (true) {
            switch (token()) {
                case Token.Identifier:
                    return parseReferenceExpression();
                case Token.StringLiteral:
                    return parseStringLiteral();
                case Token.TrueKeyword:
                case Token.FalseKeyword:
                    return parseBooleanLiteral();
                case Token.NumericLiteral:
                    return parseNumericLiteral();
                case Token.OpenBrace:
                    return parseModelExpression();
                case Token.OpenBracket:
                    return parseTupleExpression();
                case Token.OpenParen:
                    return parseParenthesizedExpression();
                case Token.At:
                    const decorators = parseDecoratorList();
                    reportInvalidDecorators(decorators, "expression");
                    continue;
                case Token.Hash:
                    const directives = parseDirectiveList();
                    reportInvalidDirective(directives, "expression");
                    continue;
                case Token.VoidKeyword:
                    return parseVoidKeyword();
                case Token.NeverKeyword:
                    return parseNeverKeyword();
                case Token.UnknownKeyword:
                    return parseUnknownKeyword();
                default:
                    return parseReferenceExpression("expression");
            }
        }
    }
    function parseVoidKeyword() {
        const pos = tokenPos();
        parseExpected(Token.VoidKeyword);
        return {
            kind: SyntaxKind.VoidKeyword,
            ...finishNode(pos),
        };
    }
    function parseNeverKeyword() {
        const pos = tokenPos();
        parseExpected(Token.NeverKeyword);
        return {
            kind: SyntaxKind.NeverKeyword,
            ...finishNode(pos),
        };
    }
    function parseUnknownKeyword() {
        const pos = tokenPos();
        parseExpected(Token.UnknownKeyword);
        return {
            kind: SyntaxKind.UnknownKeyword,
            ...finishNode(pos),
        };
    }
    function parseParenthesizedExpression() {
        const pos = tokenPos();
        parseExpected(Token.OpenParen);
        const expr = parseExpression();
        parseExpected(Token.CloseParen);
        return { ...expr, ...finishNode(pos) };
    }
    function parseTupleExpression() {
        const pos = tokenPos();
        const values = parseList(ListKind.Tuple, parseExpression);
        return {
            kind: SyntaxKind.TupleExpression,
            values,
            ...finishNode(pos),
        };
    }
    function parseModelExpression() {
        const pos = tokenPos();
        const properties = parseList(ListKind.ModelProperties, parseModelPropertyOrSpread);
        return {
            kind: SyntaxKind.ModelExpression,
            properties,
            ...finishNode(pos),
        };
    }
    function parseStringLiteral() {
        const pos = tokenPos();
        const value = tokenValue();
        parseExpected(Token.StringLiteral);
        return {
            kind: SyntaxKind.StringLiteral,
            value,
            ...finishNode(pos),
        };
    }
    function parseNumericLiteral() {
        const pos = tokenPos();
        const text = tokenValue();
        const value = Number(text);
        parseExpected(Token.NumericLiteral);
        return {
            kind: SyntaxKind.NumericLiteral,
            value,
            ...finishNode(pos),
        };
    }
    function parseBooleanLiteral() {
        const pos = tokenPos();
        const token = parseExpectedOneOf(Token.TrueKeyword, Token.FalseKeyword);
        const value = token === Token.TrueKeyword;
        return {
            kind: SyntaxKind.BooleanLiteral,
            value,
            ...finishNode(pos),
        };
    }
    function parseIdentifier(message, recoverFromKeyword = true) {
        if (recoverFromKeyword && isKeyword(token())) {
            error({ code: "reserved-identifier" });
        }
        else if (token() !== Token.Identifier) {
            // Error recovery: when we fail to parse an identifier or expression,
            // we insert a synthesized identifier with a unique name.
            error({ code: "token-expected", messageId: message !== null && message !== void 0 ? message : "identifier" });
            return createMissingIdentifier();
        }
        const pos = tokenPos();
        const sv = tokenValue();
        nextToken();
        return {
            kind: SyntaxKind.Identifier,
            sv,
            ...finishNode(pos),
        };
    }
    function parseProjectionStatement() {
        const pos = tokenPos();
        parseExpected(Token.ProjectionKeyword);
        const selector = parseProjectionSelector();
        parseExpected(Token.Hash);
        const id = parseIdentifier();
        parseExpected(Token.OpenBrace);
        let from, to;
        let proj1, proj2;
        if (token() === Token.Identifier) {
            proj1 = parseProjection();
            if (token() === Token.Identifier) {
                proj2 = parseProjection();
            }
        }
        if (proj1 && proj2 && proj1.direction === proj2.direction) {
            error({ code: "duplicate-symbol", target: proj2, format: { name: "projection" } });
        }
        else if (proj1) {
            [to, from] = proj1.direction === "to" ? [proj1, proj2] : [proj2, proj1];
        }
        parseExpected(Token.CloseBrace);
        return {
            kind: SyntaxKind.ProjectionStatement,
            selector,
            from,
            to,
            id,
            ...finishNode(pos),
        };
    }
    function parseProjection() {
        const pos = tokenPos();
        const directionId = parseIdentifier("projectionDirection");
        let direction;
        if (directionId.sv !== "from" && directionId.sv !== "to") {
            error({ code: "token-expected", messageId: "projectionDirection" });
            direction = "from";
        }
        else {
            direction = directionId.sv;
        }
        let parameters;
        if (token() === Token.OpenParen) {
            parameters = parseList(ListKind.ProjectionParameter, parseProjectionParameter);
        }
        else {
            parameters = [];
        }
        parseExpected(Token.OpenBrace);
        const body = parseProjectionStatementList();
        parseExpected(Token.CloseBrace);
        return {
            kind: SyntaxKind.Projection,
            body,
            direction,
            parameters,
            ...finishNode(pos),
        };
    }
    function parseProjectionParameter() {
        const pos = tokenPos();
        const id = parseIdentifier();
        return {
            kind: SyntaxKind.ProjectionParameterDeclaration,
            id,
            ...finishNode(pos),
        };
    }
    function parseProjectionStatementList() {
        const stmts = [];
        while (token() !== Token.CloseBrace) {
            const startPos = tokenPos();
            if (token() === Token.EndOfFile) {
                error({ code: "token-expected", messageId: "default", format: { token: "}" } });
                break;
            }
            const expr = parseProjectionExpressionStatement();
            stmts.push(expr);
            if (tokenPos() === startPos) {
                // we didn't manage to parse anything, so break out
                // and we'll report errors elsewhere.
                break;
            }
        }
        return stmts;
    }
    function parseProjectionExpressionStatement() {
        const pos = tokenPos();
        const expr = parseProjectionExpression();
        parseExpected(Token.Semicolon);
        return {
            kind: SyntaxKind.ProjectionExpressionStatement,
            expr,
            ...finishNode(pos),
        };
    }
    function parseProjectionExpression() {
        return parseProjectionReturnExpressionOrHigher();
    }
    function parseProjectionReturnExpressionOrHigher() {
        if (token() === Token.ReturnKeyword) {
            const pos = tokenPos();
            parseExpected(Token.ReturnKeyword);
            return {
                kind: SyntaxKind.Return,
                value: parseProjectionExpression(),
                ...finishNode(pos),
            };
        }
        return parseProjectionLogicalOrExpressionOrHigher();
    }
    function parseProjectionLogicalOrExpressionOrHigher() {
        let expr = parseProjectionLogicalAndExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            if (parseOptional(Token.BarBar)) {
                expr = {
                    kind: SyntaxKind.ProjectionLogicalExpression,
                    op: "||",
                    left: expr,
                    right: parseProjectionLogicalAndExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionLogicalAndExpressionOrHigher() {
        let expr = parseProjectionEqualityExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            if (parseOptional(Token.AmpsersandAmpersand)) {
                expr = {
                    kind: SyntaxKind.ProjectionLogicalExpression,
                    op: "&&",
                    left: expr,
                    right: parseIdentifier(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionEqualityExpressionOrHigher() {
        let expr = parseProjectionRelationalExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.EqualsEquals || tok === Token.ExclamationEquals) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionEqualityExpression,
                    op,
                    left: expr,
                    right: parseProjectionRelationalExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionRelationalExpressionOrHigher() {
        let expr = parseProjectionAdditiveExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.LessThan ||
                tok === Token.LessThanEquals ||
                tok === Token.GreaterThan ||
                tok === Token.GreaterThanEquals) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionRelationalExpression,
                    op,
                    left: expr,
                    right: parseProjectionAdditiveExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionAdditiveExpressionOrHigher() {
        let expr = parseProjectionMultiplicativeExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.Plus || tok === Token.Hyphen) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionArithmeticExpression,
                    op,
                    left: expr,
                    right: parseProjectionMultiplicativeExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionMultiplicativeExpressionOrHigher() {
        let expr = parseProjectionUnaryExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            const tok = token();
            if (tok === Token.ForwardSlash || tok === Token.Star) {
                const op = tokenValue();
                nextToken();
                expr = {
                    kind: SyntaxKind.ProjectionArithmeticExpression,
                    op,
                    left: expr,
                    right: parseProjectionUnaryExpressionOrHigher(),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionUnaryExpressionOrHigher() {
        if (token() === Token.Exclamation) {
            const pos = tokenPos();
            nextToken();
            return {
                kind: SyntaxKind.ProjectionUnaryExpression,
                op: "!",
                target: parseProjectionUnaryExpressionOrHigher(),
                ...finishNode(pos),
            };
        }
        return parseProjectionCallExpressionOrHigher();
    }
    function parseProjectionCallExpressionOrHigher() {
        let expr = parseProjectionDecoratorReferenceExpressionOrHigher();
        while (token() !== Token.EndOfFile) {
            const pos = expr.pos;
            expr = parseProjectionMemberExpressionRest(expr, pos);
            if (token() == Token.OpenParen) {
                expr = {
                    kind: SyntaxKind.ProjectionCallExpression,
                    callKind: "method",
                    target: expr,
                    arguments: parseList(ListKind.CallArguments, parseProjectionExpression),
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionDecoratorReferenceExpressionOrHigher() {
        if (token() === Token.At) {
            const pos = tokenPos();
            nextToken();
            return {
                kind: SyntaxKind.ProjectionDecoratorReferenceExpression,
                target: parseIdentifierOrMemberExpression(undefined, true),
                ...finishNode(pos),
            };
        }
        return parseProjectionMemberExpressionOrHigher();
    }
    function parseProjectionMemberExpressionOrHigher() {
        const pos = tokenPos();
        let expr = parseProjectionPrimaryExpression();
        expr = parseProjectionMemberExpressionRest(expr, pos);
        return expr;
    }
    function parseProjectionMemberExpressionRest(expr, pos) {
        while (token() !== Token.EndOfFile) {
            if (parseOptional(Token.Dot)) {
                expr = {
                    kind: SyntaxKind.ProjectionMemberExpression,
                    base: expr,
                    id: parseIdentifier(),
                    selector: ".",
                    ...finishNode(pos),
                };
            }
            else if (parseOptional(Token.ColonColon)) {
                expr = {
                    kind: SyntaxKind.ProjectionMemberExpression,
                    base: expr,
                    id: parseIdentifier(),
                    selector: "::",
                    ...finishNode(pos),
                };
            }
            else {
                break;
            }
        }
        return expr;
    }
    function parseProjectionPrimaryExpression() {
        switch (token()) {
            case Token.IfKeyword:
                return parseProjectionIfExpression();
            case Token.NumericLiteral:
                return parseNumericLiteral();
            case Token.StringLiteral:
                return parseStringLiteral();
            case Token.TrueKeyword:
            case Token.FalseKeyword:
                return parseBooleanLiteral();
            case Token.OpenBracket:
                return parseProjectionTupleExpression();
            case Token.OpenBrace:
                return parseProjectionModelExpression();
            case Token.OpenParen:
                return parseProjectionLambdaOrParenthesizedExpression();
            case Token.VoidKeyword:
                return parseVoidKeyword();
            case Token.NeverKeyword:
                return parseNeverKeyword();
            case Token.UnknownKeyword:
                return parseUnknownKeyword();
            default:
                return parseIdentifier("expression");
        }
    }
    function parseProjectionLambdaOrParenthesizedExpression() {
        const pos = tokenPos();
        const exprs = parseList(ListKind.ProjectionExpression, parseProjectionExpression);
        if (token() === Token.EqualsGreaterThan) {
            // unpack the exprs (which should be just identifiers) into a param list
            const params = [];
            for (const expr of exprs) {
                if (expr.kind === SyntaxKind.Identifier) {
                    params.push(withSymbol({
                        kind: SyntaxKind.ProjectionLambdaParameterDeclaration,
                        id: expr,
                        pos: expr.pos,
                        end: expr.end,
                        flags: 0 /* NodeFlags.None */,
                    }));
                }
                else {
                    error({ code: "token-expected", messageId: "identifier", target: expr });
                }
            }
            return parseProjectionLambdaExpressionRest(pos, params);
        }
        else {
            if (exprs.length === 0) {
                error({
                    code: "token-expected",
                    messageId: "expression",
                });
            }
            // verify we only have one entry
            for (let i = 1; i < exprs.length; i++) {
                error({
                    code: "token-expected",
                    messageId: "unexpected",
                    format: { token: "expression" },
                    target: exprs[i],
                });
            }
            return exprs[0];
        }
    }
    function parseProjectionLambdaExpressionRest(pos, parameters) {
        parseExpected(Token.EqualsGreaterThan);
        const body = parseProjectionBlockExpression();
        return {
            kind: SyntaxKind.ProjectionLambdaExpression,
            parameters,
            body,
            ...finishNode(pos),
        };
    }
    function parseProjectionModelExpression() {
        const pos = tokenPos();
        const properties = parseList(ListKind.ModelProperties, parseProjectionModelPropertyOrSpread);
        return {
            kind: SyntaxKind.ProjectionModelExpression,
            properties,
            ...finishNode(pos),
        };
    }
    function parseProjectionModelPropertyOrSpread(pos, decorators) {
        return token() === Token.Ellipsis
            ? parseProjectionModelSpreadProperty(pos, decorators)
            : parseProjectionModelProperty(pos, decorators);
    }
    function parseProjectionModelSpreadProperty(pos, decorators) {
        parseExpected(Token.Ellipsis);
        reportInvalidDecorators(decorators, "spread property");
        const target = parseProjectionExpression();
        return {
            kind: SyntaxKind.ProjectionModelSpreadProperty,
            target,
            ...finishNode(pos),
        };
    }
    function parseProjectionModelProperty(pos, decorators) {
        const id = token() === Token.StringLiteral ? parseStringLiteral() : parseIdentifier("property");
        const optional = parseOptional(Token.Question);
        parseExpected(Token.Colon);
        const value = parseProjectionExpression();
        const hasDefault = parseOptional(Token.Equals);
        if (hasDefault && !optional) {
            error({ code: "default-optional" });
        }
        const defaultValue = hasDefault ? parseProjectionExpression() : undefined;
        return {
            kind: SyntaxKind.ProjectionModelProperty,
            id,
            decorators,
            value,
            optional,
            default: defaultValue,
            ...finishNode(pos),
        };
    }
    function parseProjectionIfExpression() {
        const pos = tokenPos();
        parseExpected(Token.IfKeyword);
        const test = parseProjectionExpression();
        const consequent = parseProjectionBlockExpression();
        let alternate = undefined;
        if (parseOptional(Token.ElseKeyword)) {
            if (token() === Token.IfKeyword) {
                alternate = parseProjectionIfExpression();
            }
            else {
                alternate = parseProjectionBlockExpression();
            }
        }
        return {
            kind: SyntaxKind.ProjectionIfExpression,
            test,
            consequent,
            alternate,
            ...finishNode(pos),
        };
    }
    function parseProjectionBlockExpression() {
        const pos = tokenPos();
        parseExpected(Token.OpenBrace);
        const statements = parseProjectionStatementList();
        parseExpected(Token.CloseBrace);
        return {
            kind: SyntaxKind.ProjectionBlockExpression,
            statements,
            ...finishNode(pos),
        };
    }
    function parseProjectionTupleExpression() {
        const pos = tokenPos();
        const values = parseList(ListKind.Tuple, parseProjectionExpression);
        return {
            kind: SyntaxKind.ProjectionTupleExpression,
            values,
            ...finishNode(pos),
        };
    }
    function parseProjectionSelector() {
        const pos = tokenPos();
        const selectorTok = expectTokenIsOneOf(Token.Identifier, Token.ModelKeyword, Token.OpKeyword, Token.InterfaceKeyword, Token.UnionKeyword, Token.EnumKeyword);
        switch (selectorTok) {
            case Token.Identifier:
                return parseIdentifierOrMemberExpression(undefined, true);
            case Token.ModelKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionModelSelector,
                    ...finishNode(pos),
                };
            case Token.OpKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionOperationSelector,
                    ...finishNode(pos),
                };
            case Token.InterfaceKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionInterfaceSelector,
                    ...finishNode(pos),
                };
            case Token.UnionKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionUnionSelector,
                    ...finishNode(pos),
                };
            case Token.EnumKeyword:
                nextToken();
                return {
                    kind: SyntaxKind.ProjectionEnumSelector,
                    ...finishNode(pos),
                };
            default:
                // recovery: return a missing identifier to use as the selector
                // we don't need to emit a diagnostic here as the `expectTokenOneOf` above
                // will have done so.
                return createMissingIdentifier();
        }
    }
    // utility functions
    function token() {
        return scanner.token;
    }
    function tokenValue() {
        return scanner.getTokenValue();
    }
    function tokenPos() {
        return scanner.tokenPosition;
    }
    function tokenEnd() {
        return scanner.position;
    }
    function nextToken() {
        // keep track of the previous token end separately from the current scanner
        // position as these will differ when the previous token had trailing
        // trivia, and we don't want to squiggle the trivia.
        previousTokenEnd = scanner.position;
        for (;;) {
            scanner.scan();
            if (isTrivia(token())) {
                if (!newLineIsTrivia && token() === Token.NewLine) {
                    break;
                }
                if (options.comments && isComment(token())) {
                    comments.push({
                        kind: token() === Token.SingleLineComment
                            ? SyntaxKind.LineComment
                            : SyntaxKind.BlockComment,
                        pos: tokenPos(),
                        end: tokenEnd(),
                    });
                }
            }
            else {
                break;
            }
        }
    }
    function createMissingIdentifier() {
        const pos = tokenPos();
        previousTokenEnd = pos;
        missingIdentifierCounter++;
        return {
            kind: SyntaxKind.Identifier,
            sv: "<missing identifier>" + missingIdentifierCounter,
            ...finishNode(pos),
        };
    }
    function finishNode(pos) {
        const flags = parseErrorInNextFinishedNode ? 2 /* NodeFlags.ThisNodeHasError */ : 0 /* NodeFlags.None */;
        parseErrorInNextFinishedNode = false;
        return withSymbol({ pos, end: previousTokenEnd, flags });
    }
    // pretend to add as symbol property, likely to a node that is being created.
    function withSymbol(obj) {
        return obj;
    }
    /**
     * Parse a delimited list of elements, including the surrounding open and
     * close punctuation
     *
     * This shared driver function is used to share sensitive error recovery code.
     * In particular, error recovery by inserting tokens deemed missing is
     * susceptible to getting stalled in a loop iteration without making any
     * progress, and we guard against this in a shared place here.
     *
     * Note that statement and decorator lists do not have this issue. We always
     * consume at least a real '@' for a decorator and if the leading token of a
     * statement is not one of our statement keywords, ';', or '@', it is consumed
     * as part of a bad statement. As such, parsing of decorators and statements
     * do not go through here.
     */
    function parseList(kind, parseItem) {
        if (kind.open !== Token.None) {
            parseExpected(kind.open);
        }
        if (kind.allowEmpty && parseOptional(kind.close)) {
            return [];
        }
        const items = [];
        while (true) {
            const pos = tokenPos();
            const directives = parseDirectiveList();
            const decorators = parseDecoratorList();
            if (kind.invalidDecoratorTarget) {
                reportInvalidDecorators(decorators, kind.invalidDecoratorTarget);
            }
            if (directives.length === 0 && decorators.length === 0 && atEndOfListWithError(kind)) {
                // Error recovery: end surrounded list at statement keyword or end
                // of file. Note, however, that we must parse a missing element if
                // there were directives or decorators as we cannot drop those from
                // the tree.
                parseExpected(kind.close);
                break;
            }
            let item;
            if (kind.invalidDecoratorTarget) {
                item = parseItem();
            }
            else {
                item = parseItem(pos, decorators);
            }
            items.push(item);
            item.directives = directives;
            const delimiter = token();
            const delimiterPos = tokenPos();
            if (parseOptionalDelimiter(kind)) {
                // Delimiter found: check if it's trailing.
                if (parseOptional(kind.close)) {
                    if (!kind.trailingDelimiterIsValid) {
                        error({
                            code: "trailing-token",
                            format: { token: TokenDisplay[delimiter] },
                            target: {
                                pos: delimiterPos,
                                end: delimiterPos + 1,
                            },
                        });
                    }
                    // It was trailing and we've consumed the close token.
                    break;
                }
                // Not trailing. We can safely skip the progress check below here
                // because we know that we consumed a real delimiter.
                continue;
            }
            else if (kind.close === Token.None) {
                // If a list is *not* surrounded by punctuation, then the list ends when
                // there's no delimiter after an item.
                break;
            }
            else if (parseOptional(kind.close)) {
                // If a list *is* surrounded by punctuation, then the list ends when we
                // reach the close token.
                break;
            }
            else if (atEndOfListWithError(kind)) {
                // Error recovery: If a list *is* surrounded by punctionation, then
                // the list ends at statement keyword or end-of-file under the
                // assumption that the closing delimter is missing. This check is
                // duplicated from above to preempt the parseExpected(delimeter)
                // below.
                parseExpected(kind.close);
                break;
            }
            else {
                // Error recovery: if a list kind *is* surrounded by punctuation and we
                // find neither a delimiter nor a close token after an item, then we
                // assume there is a missing delimiter between items.
                //
                // Example: `model M { a: B <missing semicolon> c: D }
                parseExpected(kind.delimiter);
            }
            if (pos === tokenPos()) {
                // Error recovery: we've inserted everything during this loop iteration
                // and haven't made any progress. Assume that the current token is a bad
                // representation of the end of the the list that we're trying to get
                // through.
                //
                // Simple repro: `model M { ]` would loop forever without this check.
                //
                parseExpected(kind.close);
                nextToken();
                // remove the item that was entirely inserted by error recovery.
                items.pop();
                break;
            }
        }
        return items;
    }
    /**
     * Parse a delimited list with surrounding open and close punctuation if the
     * open token is present. Otherwise, return an empty list.
     */
    function parseOptionalList(kind, parseItem) {
        return token() === kind.open ? parseList(kind, parseItem) : [];
    }
    function parseOptionalDelimiter(kind) {
        if (parseOptional(kind.delimiter)) {
            return true;
        }
        if (token() === kind.toleratedDelimiter) {
            if (!kind.toleratedDelimiterIsValid) {
                parseExpected(kind.delimiter);
            }
            nextToken();
            return true;
        }
        return false;
    }
    function atEndOfListWithError(kind) {
        return (kind.close !== Token.None &&
            (isStatementKeyword(token()) || token() == Token.EndOfFile) &&
            token() !== kind.allowedStatementKeyword);
    }
    function parseEmptyStatement() {
        const pos = tokenPos();
        parseExpected(Token.Semicolon);
        return { kind: SyntaxKind.EmptyStatement, ...finishNode(pos) };
    }
    function parseInvalidStatement(pos, decorators) {
        // Error recovery: avoid an avalanche of errors when we get cornered into
        // parsing statements where none exist. Skip until we find a statement
        // keyword or decorator and only report one error for a contiguous range of
        // neither.
        do {
            nextToken();
        } while (!isStatementKeyword(token()) &&
            token() != Token.At &&
            token() != Token.Semicolon &&
            token() != Token.EndOfFile);
        error({
            code: "token-expected",
            messageId: "statement",
            target: { pos, end: previousTokenEnd },
        });
        return { kind: SyntaxKind.InvalidStatement, decorators, ...finishNode(pos) };
    }
    function error(report) {
        var _a, _b, _c, _d, _e, _f;
        parseErrorInNextFinishedNode = true;
        const location = {
            file: scanner.file,
            pos: (_b = (_a = report.target) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : tokenPos(),
            end: (_d = (_c = report.target) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : tokenEnd(),
        };
        if (!report.printable) {
            treePrintable = false;
        }
        // Error recovery: don't report more than 1 consecutive error at the same
        // position. The code path taken by error recovery after logging an error
        // can otherwise produce redundant and less decipherable errors, which this
        // suppresses.
        const realPos = (_f = (_e = report.target) === null || _e === void 0 ? void 0 : _e.realPos) !== null && _f !== void 0 ? _f : location.pos;
        if (realPositionOfLastError === realPos) {
            return;
        }
        realPositionOfLastError = realPos;
        const diagnostic = createDiagnostic({
            ...report,
            target: location,
        });
        assert(diagnostic.severity === "error", "This function assumes it's reporting an error.");
        parseDiagnostics.push(diagnostic);
    }
    function reportDiagnostic(diagnostic) {
        if (diagnostic.severity === "error") {
            parseErrorInNextFinishedNode = true;
            treePrintable = false;
        }
        parseDiagnostics.push(diagnostic);
    }
    function assert(condition, message) {
        const location = {
            file: scanner.file,
            pos: tokenPos(),
            end: tokenEnd(),
        };
        compilerAssert(condition, message, location);
    }
    function reportInvalidDecorators(decorators, nodeName) {
        for (const decorator of decorators) {
            error({ code: "invalid-decorator-location", format: { nodeName }, target: decorator });
        }
    }
    function reportInvalidDirective(directives, nodeName) {
        for (const directive of directives) {
            error({ code: "invalid-directive-location", format: { nodeName }, target: directive });
        }
    }
    function parseExpected(expectedToken) {
        if (token() === expectedToken) {
            nextToken();
            return true;
        }
        const location = getAdjustedDefaultLocation(expectedToken);
        error({
            code: "token-expected",
            format: { token: TokenDisplay[expectedToken] },
            target: location,
            printable: isPunctuation(expectedToken),
        });
        return false;
    }
    function expectTokenIsOneOf(...args) {
        const tok = token();
        for (const expected of args) {
            if (expected === Token.None) {
                continue;
            }
            if (tok === expected) {
                return tok;
            }
        }
        errorTokenIsNotOneOf(...args);
        return Token.None;
    }
    function parseExpectedOneOf(...args) {
        const tok = expectTokenIsOneOf(...args);
        if (tok !== Token.None) {
            nextToken();
        }
        return tok;
    }
    function errorTokenIsNotOneOf(...args) {
        const location = getAdjustedDefaultLocation(args[0]);
        const displayList = args.map((t, i) => {
            if (i === args.length - 1) {
                return `or ${TokenDisplay[t]}`;
            }
            return TokenDisplay[t];
        });
        error({ code: "token-expected", format: { token: displayList.join(", ") }, target: location });
    }
    function parseOptional(optionalToken) {
        if (token() === optionalToken) {
            nextToken();
            return true;
        }
        return false;
    }
    function getAdjustedDefaultLocation(token) {
        // Put the squiggly immediately after prior token when missing punctuation.
        // Avoids saying ';' is expected far away after a long comment, for example.
        // It's also confusing to squiggle the current token even if its nearby
        // in this case.
        return isPunctuation(token)
            ? { pos: previousTokenEnd, end: previousTokenEnd + 1, realPos: tokenPos() }
            : undefined;
    }
}
function visitChildren(node, cb) {
    if (node.directives) {
        visitEach(cb, node.directives);
    }
    switch (node.kind) {
        case SyntaxKind.CadlScript:
            return visitNode(cb, node.id) || visitEach(cb, node.statements);
        case SyntaxKind.ArrayExpression:
            return visitNode(cb, node.elementType);
        case SyntaxKind.DecoratorExpression:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.DirectiveExpression:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.ImportStatement:
            return visitNode(cb, node.path);
        case SyntaxKind.OperationStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.signature));
        case SyntaxKind.OperationSignatureDeclaration:
            return visitNode(cb, node.parameters) || visitNode(cb, node.returnType);
        case SyntaxKind.OperationSignatureReference:
            return visitNode(cb, node.baseOperation);
        case SyntaxKind.NamespaceStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                (isArray(node.statements) ? visitEach(cb, node.statements) : visitNode(cb, node.statements)));
        case SyntaxKind.InterfaceStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitEach(cb, node.extends) ||
                visitEach(cb, node.operations));
        case SyntaxKind.UsingStatement:
            return visitNode(cb, node.name);
        case SyntaxKind.IntersectionExpression:
            return visitEach(cb, node.options);
        case SyntaxKind.MemberExpression:
            return visitNode(cb, node.base) || visitNode(cb, node.id);
        case SyntaxKind.ModelExpression:
            return visitEach(cb, node.properties);
        case SyntaxKind.ModelProperty:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitNode(cb, node.value) ||
                visitNode(cb, node.default));
        case SyntaxKind.ModelSpreadProperty:
            return visitNode(cb, node.target);
        case SyntaxKind.ModelStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.extends) ||
                visitNode(cb, node.is) ||
                visitEach(cb, node.properties));
        case SyntaxKind.UnionStatement:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitEach(cb, node.options));
        case SyntaxKind.UnionVariant:
            return visitEach(cb, node.decorators) || visitNode(cb, node.id) || visitNode(cb, node.value);
        case SyntaxKind.EnumStatement:
            return (visitEach(cb, node.decorators) || visitNode(cb, node.id) || visitEach(cb, node.members));
        case SyntaxKind.EnumMember:
            return visitEach(cb, node.decorators) || visitNode(cb, node.id) || visitNode(cb, node.value);
        case SyntaxKind.EnumSpreadMember:
            return visitNode(cb, node.target);
        case SyntaxKind.AliasStatement:
            return (visitNode(cb, node.id) ||
                visitEach(cb, node.templateParameters) ||
                visitNode(cb, node.value));
        case SyntaxKind.TypeReference:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.TupleExpression:
            return visitEach(cb, node.values);
        case SyntaxKind.UnionExpression:
            return visitEach(cb, node.options);
        case SyntaxKind.Projection:
            return visitEach(cb, node.parameters) || visitEach(cb, node.body);
        case SyntaxKind.ProjectionExpressionStatement:
            return visitNode(cb, node.expr);
        case SyntaxKind.ProjectionCallExpression:
            return visitNode(cb, node.target) || visitEach(cb, node.arguments);
        case SyntaxKind.ProjectionMemberExpression:
            return visitNode(cb, node.base) || visitNode(cb, node.id);
        // binops
        case SyntaxKind.ProjectionLogicalExpression:
        case SyntaxKind.ProjectionRelationalExpression:
        case SyntaxKind.ProjectionArithmeticExpression:
        case SyntaxKind.ProjectionEqualityExpression:
            return visitNode(cb, node.left) || visitNode(cb, node.right);
        case SyntaxKind.ProjectionUnaryExpression:
            return visitNode(cb, node.target);
        case SyntaxKind.ProjectionModelExpression:
            return visitEach(cb, node.properties);
        case SyntaxKind.ProjectionModelProperty:
            return (visitEach(cb, node.decorators) ||
                visitNode(cb, node.id) ||
                visitNode(cb, node.value) ||
                visitNode(cb, node.default));
        case SyntaxKind.ProjectionModelSpreadProperty:
            return visitNode(cb, node.target);
        case SyntaxKind.ProjectionTupleExpression:
            return visitEach(cb, node.values);
        case SyntaxKind.ProjectionBlockExpression:
            return visitEach(cb, node.statements);
        case SyntaxKind.ProjectionIfExpression:
            return (visitNode(cb, node.test) || visitNode(cb, node.consequent) || visitNode(cb, node.alternate));
        case SyntaxKind.ProjectionLambdaExpression:
            return visitEach(cb, node.parameters) || visitNode(cb, node.body);
        case SyntaxKind.ProjectionStatement:
            return (visitNode(cb, node.id) ||
                visitNode(cb, node.selector) ||
                visitNode(cb, node.from) ||
                visitNode(cb, node.to));
        case SyntaxKind.ProjectionDecoratorReferenceExpression:
            return visitNode(cb, node.target);
        case SyntaxKind.Return:
            return visitNode(cb, node.value);
        // no children for the rest of these.
        case SyntaxKind.InvalidStatement:
            return visitEach(cb, node.decorators);
        case SyntaxKind.TemplateParameterDeclaration:
            return (visitNode(cb, node.id) || visitNode(cb, node.constraint) || visitNode(cb, node.default));
        case SyntaxKind.ProjectionLambdaParameterDeclaration:
            return visitNode(cb, node.id);
        case SyntaxKind.ProjectionParameterDeclaration:
            return visitNode(cb, node.id);
        case SyntaxKind.StringLiteral:
        case SyntaxKind.NumericLiteral:
        case SyntaxKind.BooleanLiteral:
        case SyntaxKind.Identifier:
        case SyntaxKind.EmptyStatement:
        case SyntaxKind.ProjectionModelSelector:
        case SyntaxKind.ProjectionUnionSelector:
        case SyntaxKind.ProjectionInterfaceSelector:
        case SyntaxKind.ProjectionOperationSelector:
        case SyntaxKind.ProjectionEnumSelector:
        case SyntaxKind.VoidKeyword:
        case SyntaxKind.NeverKeyword:
        case SyntaxKind.UnknownKeyword:
        case SyntaxKind.JsSourceFile:
            return;
        default:
            return;
    }
}
function visitNode(cb, node) {
    return node && cb(node);
}
function visitEach(cb, nodes) {
    if (!nodes) {
        return;
    }
    for (const node of nodes) {
        const result = cb(node);
        if (result) {
            return result;
        }
    }
    return;
}
function getNodeAtPosition(script, position, filter = (node) => true) {
    const realNode = getNodeAtPositionInternal(script, position, filter);
    if ((realNode === null || realNode === void 0 ? void 0 : realNode.kind) === SyntaxKind.StringLiteral) {
        return realNode;
    }
    // If we're not immediately after an identifier character, then advance
    // the position past any trivia. This is done because a zero-width
    // inserted missing identifier that the user is now trying to complete
    // starts after the trivia following the cursor.
    const cp = codePointBefore(script.file.text, position);
    if (!cp || !isIdentifierContinue(cp)) {
        const newPosition = skipTrivia(script.file.text, position);
        if (newPosition !== position) {
            return getNodeAtPositionInternal(script, newPosition, filter);
        }
    }
    return realNode;
}
function getNodeAtPositionInternal(script, position, filter = (node) => true) {
    return visit(script);
    function visit(node) {
        // We deliberately include the end position here because we need to hit
        // nodes when the cursor is positioned immediately after an identifier.
        // This is especially vital for completion. It's also generally OK
        // because the language doesn't (and should never) have syntax where you
        // could place the cursor ambiguously between two adjacent,
        // non-punctuation, non-trivia tokens that have no punctuation or trivia
        // separating them.
        if (node.pos <= position && position <= node.end) {
            // We only need to recursively visit children of nodes that satisfied
            // the condition above and therefore contain the given position. If a
            // node does not contain a position, then neither do its children.
            const child = visitChildren(node, visit);
            // A child match here is better than a self-match below as we want the
            // deepest (most specific) node. In other words, the search is depth
            // first. For example, consider `A<B<C>>`: If the cursor is on `B`,
            // then prefer B<C> over A<B<C>>.
            if (child) {
                return child;
            }
            if (filter(node)) {
                return node;
            }
        }
        return undefined;
    }
}
function hasParseError(node) {
    if (node.flags & 2 /* NodeFlags.ThisNodeHasError */) {
        return true;
    }
    checkForDescendantErrors(node);
    return node.flags & 4 /* NodeFlags.DescendantHasError */;
}
function checkForDescendantErrors(node) {
    if (node.flags & 1 /* NodeFlags.DescendantErrorsExamined */) {
        return;
    }
    node.flags |= 1 /* NodeFlags.DescendantErrorsExamined */;
    visitChildren(node, (child) => {
        if (child.flags & 2 /* NodeFlags.ThisNodeHasError */) {
            node.flags |= 4 /* NodeFlags.DescendantHasError */ | 1 /* NodeFlags.DescendantErrorsExamined */;
            return true;
        }
        checkForDescendantErrors(child);
        if (child.flags & 4 /* NodeFlags.DescendantHasError */) {
            node.flags |= 4 /* NodeFlags.DescendantHasError */ | 1 /* NodeFlags.DescendantErrorsExamined */;
            return true;
        }
        child.flags |= 1 /* NodeFlags.DescendantErrorsExamined */;
        return false;
    });
}
function isImportStatement(node) {
    return node.kind === SyntaxKind.ImportStatement;
}
function isBlocklessNamespace(node) {
    if (node.kind !== SyntaxKind.NamespaceStatement) {
        return false;
    }
    while (!isArray(node.statements) && node.statements) {
        node = node.statements;
    }
    return node.statements === undefined;
}
function getFirstAncestor(node, test) {
    for (let n = node.parent; n; n = n.parent) {
        if (test(n)) {
            return n;
        }
    }
    return undefined;
}
function getIdentifierContext(id) {
    const node = getFirstAncestor(id, (n) => n.kind !== SyntaxKind.MemberExpression);
    compilerAssert(node, "Identifier with no non-member-expression ancestor.");
    let kind;
    switch (node.kind) {
        case SyntaxKind.TypeReference:
            kind = IdentifierKind.TypeReference;
            break;
        case SyntaxKind.DecoratorExpression:
            kind = IdentifierKind.Decorator;
            break;
        case SyntaxKind.UsingStatement:
            kind = IdentifierKind.Using;
            break;
        default:
            kind =
                id.parent.id === id
                    ? IdentifierKind.Declaration
                    : IdentifierKind.Other;
            break;
    }
    return { node, kind };
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}

function pascalCaseTransform(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
}

function camelCaseTransform(input, index) {
    if (index === 0)
        return input.toLowerCase();
    return pascalCaseTransform(input, index);
}
function camelCase(input, options) {
    if (options === void 0) { options = {}; }
    return pascalCase(input, __assign({ transform: camelCaseTransform }, options));
}

function dotCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "." }, options));
}

function paramCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "-" }, options));
}

function snakeCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "_" }, options));
}

function createProjectionMembers(checker) {
    const { voidType, neverType, createType, createFunctionType, createLiteralType, cloneType } = checker;
    function createBaseMembers() {
        return {
            projectionSource: (base) => { var _a; return (_a = base.projectionSource) !== null && _a !== void 0 ? _a : voidType; },
            projectionBase: (base) => { var _a; return (_a = base.projectionBase) !== null && _a !== void 0 ? _a : voidType; },
        };
    }
    function createNameableMembers() {
        return {
            name: (base) => (base.name ? createLiteralType(base.name) : voidType),
            rename: (base) => {
                return createFunctionType((newName) => {
                    assertType("new name", newName, "String");
                    base.name = newName.value;
                    return voidType;
                });
            },
        };
    }
    return {
        Model: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            properties(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const props = Array.from(base.properties.values());
                            props.forEach((p) => block.call(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameProperty(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("current property name", oldNameT, "String");
                    assertType("new property name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const prop = base.properties.get(oldName);
                    if (!prop) {
                        throw new ProjectionError(`Property ${oldName} not found`);
                    }
                    prop.name = newName;
                    base.properties.delete(oldName);
                    base.properties.set(newName, prop);
                    return voidType;
                });
            },
            addProperty(base) {
                return createFunctionType((nameT, type, defaultT) => {
                    assertType("property", nameT, "String");
                    const name = nameT.value;
                    const prop = base.properties.get(name);
                    if (prop) {
                        throw new ProjectionError(`Property ${name} already exists`);
                    }
                    base.properties.set(name, createType({
                        kind: "ModelProperty",
                        name,
                        optional: false,
                        decorators: [],
                        node: undefined,
                        default: defaultT,
                        type,
                    }));
                    return voidType;
                });
            },
            deleteProperty(base) {
                return createFunctionType((nameT) => {
                    assertType("property", nameT, "String");
                    const name = nameT.value;
                    const prop = base.properties.get(name);
                    if (!prop) {
                        return voidType;
                    }
                    base.properties.delete(name);
                    return voidType;
                });
            },
        },
        ModelProperty: {
            name(base) {
                return createLiteralType(base.name);
            },
            type(base) {
                return base.type;
            },
            setType(base) {
                return createFunctionType((t) => {
                    base.type = t;
                    return voidType;
                });
            },
            setOptional(base) {
                return createFunctionType((optional) => {
                    assertType("Optional", optional, "Boolean");
                    base.optional = optional.value;
                    return voidType;
                });
            },
        },
        Union: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            variants(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const variants = Array.from(base.variants.values());
                            variants.forEach((p) => block.call(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameVariant(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("old variant name", oldNameT, "String");
                    assertType("new vaariant name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const variant = base.variants.get(oldName);
                    if (!variant) {
                        throw new ProjectionError(`Couldn't find variant ${variant}`);
                    }
                    base.variants.delete(oldName);
                    base.variants.set(newName, variant);
                    if (variant.kind === "UnionVariant") {
                        variant.name = newName;
                    }
                    return voidType;
                });
            },
            addVariant(base) {
                return createFunctionType((nameT, type) => {
                    assertType("Variant name", nameT, "String");
                    const name = nameT.value;
                    const variantType = createType({
                        kind: "UnionVariant",
                        decorators: [],
                        name,
                        node: undefined,
                        type,
                        union: base,
                    });
                    base.variants.set(name, variantType);
                    return voidType;
                });
            },
            deleteVariant(base) {
                return createFunctionType((nameT) => {
                    assertType("Name", nameT, "String");
                    const name = nameT.value;
                    base.variants.delete(name);
                    return voidType;
                });
            },
        },
        UnionVariant: {
            name(base) {
                if (typeof base.name === "string") {
                    return createLiteralType(base.name);
                }
                else {
                    throw new ProjectionError("Can't refer to name of anonymous union variant");
                }
            },
            setType(base) {
                return createFunctionType((type) => {
                    base.type = type;
                    return voidType;
                });
            },
            type(base) {
                return base.type;
            },
        },
        Operation: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            parameters(base) {
                return base.parameters;
            },
            returnType(base) {
                return base.returnType;
            },
        },
        Interface: {
            ...createBaseMembers(),
            ...createNameableMembers(),
            operations(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("block", block, "Function");
                            const props = Array.from(base.operations.values());
                            props.forEach((p) => block.call(p));
                            return voidType;
                        }),
                    },
                });
            },
            renameOperation(base) {
                return createFunctionType((oldNameT, newNameT) => {
                    assertType("operation name", oldNameT, "String");
                    assertType("operation name", newNameT, "String");
                    const oldName = oldNameT.value;
                    const newName = newNameT.value;
                    const op = base.operations.get(oldName);
                    if (!op) {
                        throw new ProjectionError(`Couldn't find operation named ${oldName}`);
                    }
                    const clone = cloneType(op);
                    clone.name = newName;
                    base.operations.delete(oldName);
                    base.operations.set(newName, clone);
                    return voidType;
                });
            },
            addOperation(base) {
                return createFunctionType((nameT, parameters, returnType) => {
                    assertType("operation name", nameT, "String");
                    assertType("parameters", parameters, "Model");
                    const name = nameT.value;
                    const prop = base.operations.get(name);
                    if (prop) {
                        throw new ProjectionError(`Operation named ${name} already exists`);
                    }
                    base.operations.set(name, createType({
                        kind: "Operation",
                        name,
                        node: undefined,
                        parameters,
                        returnType,
                        decorators: [],
                    }));
                    return voidType;
                });
            },
            deleteOperation(base) {
                return createFunctionType((nameT) => {
                    assertType("operation name", nameT, "String");
                    const name = nameT.value;
                    const prop = base.operations.get(name);
                    if (!prop) {
                        return voidType;
                    }
                    base.operations.delete(name);
                    return voidType;
                });
            },
        },
        Enum: {
            projectionSource(base) {
                var _a;
                return (_a = base.projectionSource) !== null && _a !== void 0 ? _a : voidType;
            },
            projectionBase(base) {
                return base.projectionBase || voidType;
            },
            ...createNameableMembers(),
            members(base) {
                return createType({
                    kind: "Object",
                    properties: {
                        forEach: createFunctionType((block) => {
                            assertType("parameter", block, "Function");
                            const props = Array.from(base.members);
                            props.forEach((p) => block.call(p));
                            return voidType;
                        }),
                    },
                });
            },
            name(base) {
                return createLiteralType(base.name);
            },
            addMember(base) {
                return createFunctionType((nameT, type) => {
                    assertType("enum member", nameT, "String");
                    type && assertType("enum type", type, "String", "Number");
                    const name = nameT.value;
                    const member = base.members.find((member) => member.name === name);
                    if (member) {
                        throw new ProjectionError(`Enum already has a member named ${name}`);
                    }
                    if (type !== undefined && type.kind !== "Number" && type.kind !== "String") {
                        throw new ProjectionError(`Enum member types must be string or number`);
                    }
                    base.members.push(createType({
                        kind: "EnumMember",
                        enum: base,
                        name,
                        decorators: [],
                        node: undefined,
                        value: type ? type.value : undefined,
                    }));
                    return voidType;
                });
            },
            deleteMember(base) {
                return createFunctionType((nameT) => {
                    assertType("enum member", nameT, "String");
                    const name = nameT.value;
                    const member = base.members.findIndex((member) => member.name === name);
                    if (member === -1)
                        return voidType;
                    base.members.splice(member, 1);
                    return voidType;
                });
            },
            renameMember(base) {
                return createFunctionType((nameT, newNameT) => {
                    assertType("enum member", nameT, "String");
                    assertType("enum member", newNameT, "String");
                    const name = nameT.value;
                    const newName = newNameT.value;
                    const member = base.members.find((member) => member.name === name);
                    if (!member) {
                        throw new ProjectionError(`Enum doesn't have member ${name}`);
                    }
                    member.name = newName;
                    return voidType;
                });
            },
        },
        EnumMember: {
            name(base) {
                return createLiteralType(base.name);
            },
            type(base) {
                return base.value ? createLiteralType(base.value) : neverType;
            },
        },
        String: {
            toCamelCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(camelCase(base.value));
                });
            },
            toPascalCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(pascalCase(base.value));
                });
            },
            toSnakeCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(snakeCase(base.value));
                });
            },
            toKebabCase(base) {
                return createFunctionType(() => {
                    return createLiteralType(paramCase(base.value));
                });
            },
        },
    };
}

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _MultiKeyMap_currentId, _MultiKeyMap_idMap, _MultiKeyMap_items;
/**
 * A map keyed by a set of objects.
 *
 * This is likely non-optimal.
 */
class MultiKeyMap {
    constructor() {
        _MultiKeyMap_currentId.set(this, 0);
        _MultiKeyMap_idMap.set(this, new WeakMap());
        _MultiKeyMap_items.set(this, new Map());
    }
    get(items) {
        return __classPrivateFieldGet(this, _MultiKeyMap_items, "f").get(this.compositeKeyFor(items));
    }
    set(items, value) {
        const key = this.compositeKeyFor(items);
        __classPrivateFieldGet(this, _MultiKeyMap_items, "f").set(key, value);
    }
    compositeKeyFor(items) {
        return items.map((i) => this.keyFor(i)).join(",");
    }
    keyFor(item) {
        var _a, _b;
        if (__classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").has(item)) {
            return __classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").get(item);
        }
        const id = (__classPrivateFieldSet(this, _MultiKeyMap_currentId, (_b = __classPrivateFieldGet(this, _MultiKeyMap_currentId, "f"), _a = _b++, _b), "f"), _a);
        __classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").set(item, id);
        return id;
    }
}
_MultiKeyMap_currentId = new WeakMap(), _MultiKeyMap_idMap = new WeakMap(), _MultiKeyMap_items = new WeakMap();
/**
 * Maps type arguments to type instantiation.
 */
const TypeInstantiationMap = class extends MultiKeyMap {
};
function createChecker(program) {
    let currentSymbolId = 0;
    const stdTypes = {};
    const symbolLinks = new Map();
    const mergedSymbols = new Map();
    const typePrototype = {
        get projections() {
            return (projectionsByTypeKind.get(this.kind) || []).concat(projectionsByType.get(this) || []);
        },
        projectionsByName(name) {
            return this.projections.filter((p) => p.id.sv === name);
        },
    };
    const globalNamespaceNode = createGlobalNamespaceNode();
    const globalNamespaceType = createGlobalNamespaceType();
    let cadlNamespaceNode;
    const errorType = createType({ kind: "Intrinsic", name: "ErrorType" });
    const voidType = createType({ kind: "Intrinsic", name: "void" });
    const neverType = createType({ kind: "Intrinsic", name: "never" });
    const unknownType = createType({ kind: "Intrinsic", name: "unknown" });
    const projectionsByTypeKind = new Map([
        ["Model", []],
        ["Union", []],
        ["Operation", []],
        ["Interface", []],
        ["Enum", []],
    ]);
    const projectionsByType = new Map();
    // whether we've checked this specific projection statement before
    // and added it to the various projection maps.
    const processedProjections = new Set();
    // interpreter state
    let currentProjectionDirection;
    /**
     * Set keeping track of node pending type resolution.
     * Key is the SymId of a node. It can be retrieved with getNodeSymId(node)
     */
    const pendingResolutions = new Set();
    for (const file of program.jsSourceFiles.values()) {
        mergeSourceFile(file);
    }
    for (const file of program.sourceFiles.values()) {
        mergeSourceFile(file);
    }
    for (const file of program.sourceFiles.values()) {
        setUsingsForFile(file);
    }
    const cadlNamespaceBinding = globalNamespaceNode.symbol.exports.get("Cadl");
    if (cadlNamespaceBinding) {
        // the cadl namespace binding will be absent if we've passed
        // the no-std-lib option.
        // the first declaration here is the JS file for the cadl script.
        cadlNamespaceNode = cadlNamespaceBinding.declarations[1];
        initializeCadlIntrinsics();
        for (const file of program.sourceFiles.values()) {
            for (const [name, binding] of cadlNamespaceBinding.exports) {
                const usedSym = createUsingSymbol(binding);
                file.locals.set(name, usedSym);
            }
        }
    }
    let evalContext = undefined;
    const checker = {
        getTypeForNode,
        checkProgram,
        checkSourceFile,
        getLiteralType,
        getTypeName,
        getNamespaceString,
        getGlobalNamespaceType,
        getGlobalNamespaceNode,
        setUsingsForFile,
        getMergedSymbol,
        mergeSourceFile,
        cloneType,
        resolveIdentifier,
        resolveCompletions,
        evalProjection: evalProjectionStatement,
        project,
        neverType,
        errorType,
        anyType: unknownType,
        voidType,
        createType,
        createAndFinishType,
        createFunctionType,
        createLiteralType,
        finishType,
        isTypeAssignableTo,
        isStdType,
        getEffectiveModelType,
        filterModelProperties,
    };
    const projectionMembers = createProjectionMembers(checker);
    return checker;
    function initializeCadlIntrinsics() {
        // a utility function to log strings or numbers
        cadlNamespaceBinding.exports.set("log", {
            flags: 65536 /* SymbolFlags.Function */,
            name: "log",
            value(p, str) {
                program.logger.log({ level: "debug", message: str });
                return voidType;
            },
            declarations: [],
        });
    }
    function getStdType(name) {
        var _a;
        const type = stdTypes[name];
        if (type !== undefined) {
            return type;
        }
        const sym = (_a = cadlNamespaceBinding === null || cadlNamespaceBinding === void 0 ? void 0 : cadlNamespaceBinding.exports) === null || _a === void 0 ? void 0 : _a.get(name);
        checkModelStatement(sym.declarations[0], undefined);
        const loadedType = stdTypes[name];
        compilerAssert(loadedType, "Cadl built-in array type should have been initalized before using array syntax.");
        return loadedType;
    }
    function mergeSourceFile(file) {
        mergeSymbolTable(file.symbol.exports, globalNamespaceNode.symbol.exports);
    }
    function setUsingsForFile(file) {
        const usedUsing = new Set();
        for (const using of file.usings) {
            const parentNs = using.parent;
            const sym = resolveTypeReference(using.name, undefined);
            if (!sym) {
                continue;
            }
            if (!(sym.flags & 2048 /* SymbolFlags.Namespace */)) {
                program.reportDiagnostic(createDiagnostic({ code: "using-invalid-ref", target: using }));
            }
            const namespaceSym = getMergedSymbol(sym);
            if (usedUsing.has(namespaceSym)) {
                reportDiagnostic(program, {
                    code: "duplicate-using",
                    format: { usingName: memberExpressionToString(using.name) },
                    target: using,
                });
                continue;
            }
            usedUsing.add(namespaceSym);
            for (const [name, binding] of sym.exports) {
                parentNs.locals.set(name, createUsingSymbol(binding));
            }
        }
        if (cadlNamespaceNode) {
            for (const [name, binding] of cadlNamespaceBinding.exports) {
                file.locals.set(name, createUsingSymbol(binding));
            }
        }
    }
    /**
     * Create the link for the given type to the symbol links.
     * If currently instantiating a template it will link to the instantiations.
     * Else will link to the declaredType.
     * @param links Symbol link
     * @param type Type
     * @param mapper Type mapper if in an template instantiation
     */
    function linkType(links, type, mapper) {
        if (mapper === undefined) {
            links.declaredType = type;
            links.instantiations = new TypeInstantiationMap();
        }
        else if (links.instantiations) {
            links.instantiations.set(mapper.args, type);
        }
    }
    function getTypeForNode(node, mapper) {
        switch (node.kind) {
            case SyntaxKind.ModelExpression:
                return checkModel(node, mapper);
            case SyntaxKind.ModelStatement:
                return checkModel(node, mapper);
            case SyntaxKind.ModelProperty:
                return checkModelProperty(node, mapper);
            case SyntaxKind.AliasStatement:
                return checkAlias(node, mapper);
            case SyntaxKind.EnumStatement:
                return checkEnum(node, mapper);
            case SyntaxKind.InterfaceStatement:
                return checkInterface(node, mapper);
            case SyntaxKind.UnionStatement:
                return checkUnion(node, mapper);
            case SyntaxKind.NamespaceStatement:
                return checkNamespace(node);
            case SyntaxKind.OperationStatement:
                return checkOperation(node, mapper);
            case SyntaxKind.NumericLiteral:
                return checkNumericLiteral(node);
            case SyntaxKind.BooleanLiteral:
                return checkBooleanLiteral(node);
            case SyntaxKind.TupleExpression:
                return checkTupleExpression(node, mapper);
            case SyntaxKind.StringLiteral:
                return checkStringLiteral(node);
            case SyntaxKind.ArrayExpression:
                return checkArrayExpression(node, mapper);
            case SyntaxKind.UnionExpression:
                return checkUnionExpression(node, mapper);
            case SyntaxKind.IntersectionExpression:
                return checkIntersectionExpression(node, mapper);
            case SyntaxKind.TypeReference:
                return checkTypeReference(node, mapper);
            case SyntaxKind.TemplateParameterDeclaration:
                return checkTemplateParameterDeclaration(node, mapper);
            case SyntaxKind.ProjectionStatement:
                return checkProjectionDeclaration(node);
            case SyntaxKind.VoidKeyword:
                return voidType;
            case SyntaxKind.NeverKeyword:
                return neverType;
            case SyntaxKind.UnknownKeyword:
                return unknownType;
        }
        // we don't emit an error here as we blindly call this function
        // with any node type, but some nodes don't produce a type
        // (e.g. imports). errorType should result in an error if it
        // bubbles out somewhere its not supposed to be.
        return errorType;
    }
    function getTypeName(type, options) {
        switch (type.kind) {
            case "Model":
                return getModelName(type, options);
            case "ModelProperty":
                return getModelPropertyName(type, options);
            case "Interface":
                return getInterfaceName(type, options);
            case "Operation":
                return getOperationName(type, options);
            case "Enum":
                return getEnumName(type, options);
            case "EnumMember":
                return `${getEnumName(type.enum, options)}.${type.name}`;
            case "Union":
                return type.name || type.options.map((x) => getTypeName(x, options)).join(" | ");
            case "UnionVariant":
                return getTypeName(type.type, options);
            case "Tuple":
                return "[" + type.values.map((x) => getTypeName(x, options)).join(", ") + "]";
            case "String":
            case "Number":
            case "Boolean":
                return type.value.toString();
            case "Intrinsic":
                return type.name;
        }
        return "(unnamed type)";
    }
    function getNamespaceString(type, options) {
        if (!type || !type.name) {
            return "";
        }
        const filter = options === null || options === void 0 ? void 0 : options.namespaceFilter;
        if (filter && !filter(type)) {
            return "";
        }
        const parent = getNamespaceString(type.namespace, options);
        return parent ? `${parent}.${type.name}` : type.name;
    }
    function getFullyQualifiedSymbolName(sym) {
        if (!sym)
            return "";
        const parent = sym.parent;
        return parent && parent.name !== ""
            ? `${getFullyQualifiedSymbolName(parent)}.${sym.name}`
            : sym.name;
    }
    function getEnumName(e, options) {
        const nsName = getNamespaceString(e.namespace, options);
        return nsName ? `${nsName}.${e.name}` : e.name;
    }
    /**
     * Return a fully qualified id of node
     */
    function getNodeSymId(node) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        return (_a = node.symbol) === null || _a === void 0 ? void 0 : _a.id;
    }
    /**
     * Check if the given namespace is the standard library `Cadl` namespace.
     */
    function isCadlNamespace(namespace) {
        var _a;
        return (namespace.name === "Cadl" &&
            (namespace.namespace === globalNamespaceType ||
                namespace.namespace === ((_a = program.currentProjector) === null || _a === void 0 ? void 0 : _a.projectedGlobalNamespace)));
    }
    /**
     * Check if the given type is defined right in the Cadl namespace.
     */
    function isInCadlNamespace(type) {
        return Boolean(type.namespace && isCadlNamespace(type.namespace));
    }
    function getModelName(model, options) {
        var _a, _b;
        const nsName = getNamespaceString(model.namespace, options);
        if (model.name === "" && model.properties.size === 0) {
            return "{}";
        }
        if (model.indexer && model.indexer.key.kind === "Model") {
            if (model.name === "Array" && isInCadlNamespace(model)) {
                return `${getTypeName(model.indexer.value, options)}[]`;
            }
        }
        if (model.name === "") {
            return (nsName ? nsName + "." : "") + "(anonymous model)";
        }
        const modelName = (nsName ? nsName + "." : "") + model.name;
        if (model.templateArguments && model.templateArguments.length > 0) {
            // template instantiation
            const args = model.templateArguments.map((x) => getTypeName(x, options));
            return `${modelName}<${args.join(", ")}>`;
        }
        else if (((_b = (_a = model.node) === null || _a === void 0 ? void 0 : _a.templateParameters) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            // template
            const params = model.node.templateParameters.map((t) => t.id.sv);
            return `${model.name}<${params.join(", ")}>`;
        }
        else {
            // regular old model.
            return modelName;
        }
    }
    function getModelPropertyName(prop, options) {
        const modelName = prop.model ? getModelName(prop.model, options) : undefined;
        return `${modelName !== null && modelName !== void 0 ? modelName : "(anonymous model)"}.${prop.name}`;
    }
    function getInterfaceName(iface, options) {
        const nsName = getNamespaceString(iface.namespace, options);
        return (nsName ? nsName + "." : "") + iface.name;
    }
    function getOperationName(op, options) {
        const nsName = getNamespaceString(op.namespace, options);
        return (nsName ? nsName + "." : "") + op.name;
    }
    function checkTemplateParameterDeclaration(node, mapper) {
        const parentNode = node.parent;
        const links = getSymbolLinks(node.symbol);
        let type = links.declaredType;
        if (type === undefined) {
            const index = parentNode.templateParameters.findIndex((v) => v === node);
            type = links.declaredType = createAndFinishType({
                kind: "TemplateParameter",
                node: node,
            });
            if (node.constraint) {
                type.constraint = getTypeForNode(node.constraint);
            }
            if (node.default) {
                type.default = checkTemplateParameterDefault(node.default, parentNode.templateParameters, index, type.constraint);
            }
        }
        return mapper ? mapper.getMappedType(type) : type;
    }
    function getResolvedTypeParameterDefault(declaredType, node, mapper) {
        if (declaredType.default === undefined) {
            return undefined;
        }
        if (isErrorType(declaredType.default)) {
            return declaredType.default;
        }
        return getTypeForNode(node.default, mapper);
    }
    function checkTemplateParameterDefault(nodeDefault, templateParameters, index, constraint) {
        var _a;
        function visit(node) {
            const type = getTypeForNode(node);
            let hasError = false;
            if (type.kind === "TemplateParameter") {
                for (let i = index; i < templateParameters.length; i++) {
                    if (type.node.symbol === templateParameters[i].symbol) {
                        program.reportDiagnostic(createDiagnostic({ code: "invalid-template-default", target: node }));
                        return undefined;
                    }
                }
                return type;
            }
            visitChildren(node, (x) => {
                const visited = visit(x);
                if (visited === undefined) {
                    hasError = true;
                }
            });
            return hasError ? undefined : type;
        }
        const type = (_a = visit(nodeDefault)) !== null && _a !== void 0 ? _a : errorType;
        if (!isErrorType(type) && constraint) {
            checkTypeAssignable(type, constraint, nodeDefault);
        }
        return type;
    }
    function checkTypeReference(node, mapper) {
        const sym = resolveTypeReference(node, mapper);
        if (!sym) {
            return errorType;
        }
        const type = checkTypeReferenceSymbol(sym, node, mapper);
        checkDeprecated(type, node);
        return type;
    }
    function checkDeprecated(type, target) {
        const deprecated = getDeprecated(program, type);
        if (deprecated) {
            reportDeprecated(program, deprecated, target);
        }
    }
    function checkTypeReferenceArgs(node, mapper) {
        const args = [];
        if (node.kind !== SyntaxKind.TypeReference) {
            return args;
        }
        for (const arg of node.arguments) {
            const value = getTypeForNode(arg, mapper);
            args.push([arg, value]);
        }
        return args;
    }
    function checkTemplateInstantiationArgs(templateNode, node, args, declarations) {
        if (args.length > declarations.length) {
            program.reportDiagnostic(createDiagnostic({ code: "invalid-template-args", messageId: "tooMany", target: node }));
        }
        const values = [];
        const params = [];
        let tooFew = false;
        for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            const declaredType = getTypeForNode(declaration);
            params.push(declaredType);
            if (i < args.length) {
                const [valueNode, value] = args[i];
                values.push(value);
                if (declaredType.constraint) {
                    checkTypeAssignable(value, declaredType.constraint, valueNode);
                }
            }
            else {
                const mapper = createTypeMapper(params, values);
                const defaultValue = getResolvedTypeParameterDefault(declaredType, declaration, mapper);
                if (defaultValue) {
                    values.push(defaultValue);
                }
                else {
                    tooFew = true;
                    values.push(errorType);
                }
            }
        }
        if (tooFew) {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-template-args",
                messageId: "tooFew",
                target: node,
            }));
        }
        return [params, values];
    }
    function checkTypeReferenceSymbol(sym, node, mapper) {
        if (sym.flags & 8192 /* SymbolFlags.Decorator */) {
            program.reportDiagnostic(createDiagnostic({ code: "invalid-type-ref", messageId: "decorator", target: sym }));
            return errorType;
        }
        if (sym.flags & 65536 /* SymbolFlags.Function */) {
            program.reportDiagnostic(createDiagnostic({ code: "invalid-type-ref", messageId: "function", target: sym }));
            return errorType;
        }
        if (sym.flags & 2097152 /* SymbolFlags.LateBound */) {
            compilerAssert(sym.type, "Expected late bound symbol to have type");
            return sym.type;
        }
        const symbolLinks = getSymbolLinks(sym);
        let baseType;
        const args = checkTypeReferenceArgs(node, mapper);
        if (sym.flags &
            (2 /* SymbolFlags.Model */ |
                1024 /* SymbolFlags.Alias */ |
                64 /* SymbolFlags.Interface */ |
                8 /* SymbolFlags.Operation */ |
                256 /* SymbolFlags.Union */)) {
            const decl = sym.declarations[0];
            if (decl.templateParameters.length === 0) {
                if (args.length > 0) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-template-args",
                        messageId: "notTemplate",
                        target: node,
                    }));
                }
                if (symbolLinks.declaredType) {
                    baseType = symbolLinks.declaredType;
                }
                else {
                    baseType =
                        sym.flags & 2 /* SymbolFlags.Model */
                            ? checkModelStatement(decl, mapper)
                            : sym.flags & 1024 /* SymbolFlags.Alias */
                                ? checkAlias(decl, mapper)
                                : sym.flags & 64 /* SymbolFlags.Interface */
                                    ? checkInterface(decl, mapper)
                                    : sym.flags & 8 /* SymbolFlags.Operation */
                                        ? checkOperation(decl, mapper)
                                        : checkUnion(decl, mapper);
                }
            }
            else {
                // declaration is templated, lets instantiate.
                if (!symbolLinks.declaredType) {
                    // we haven't checked the declared type yet, so do so.
                    sym.flags & 2 /* SymbolFlags.Model */
                        ? checkModelStatement(decl, mapper)
                        : sym.flags & 1024 /* SymbolFlags.Alias */
                            ? checkAlias(decl, mapper)
                            : sym.flags & 64 /* SymbolFlags.Interface */
                                ? checkInterface(decl, mapper)
                                : sym.flags & 8 /* SymbolFlags.Operation */
                                    ? checkOperation(decl, mapper)
                                    : checkUnion(decl, mapper);
                }
                const templateParameters = decl.templateParameters;
                const [params, instantiationArgs] = checkTemplateInstantiationArgs(decl, node, args, templateParameters);
                baseType = instantiateTemplate(decl, params, instantiationArgs);
            }
        }
        else {
            // some other kind of reference
            if (args.length > 0) {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-template-args",
                    messageId: "notTemplate",
                    target: node,
                }));
            }
            if (sym.flags & 16384 /* SymbolFlags.TemplateParameter */) {
                baseType = checkTemplateParameterDeclaration(sym.declarations[0], mapper);
            }
            else if (symbolLinks.type) {
                // Have a cached type for non-declarations
                baseType = symbolLinks.type;
            }
            else {
                // don't have a cached type for this symbol, so go grab it and cache it
                baseType = getTypeForNode(sym.declarations[0], mapper);
                symbolLinks.type = baseType;
            }
        }
        return baseType;
    }
    /**
     * Builds a model type from a template and its template arguments.
     * Adds the template node to a set we can check when we bind template
     * parameters to access type type arguments.
     *
     * This will fall over if the same template is ever being instantiated
     * twice at the same time, or if template parameters from more than one template
     * are ever in scope at once.
     */
    function instantiateTemplate(templateNode, params, args) {
        const symbolLinks = getSymbolLinks(templateNode.symbol);
        if (symbolLinks.instantiations === undefined) {
            const type = getTypeForNode(templateNode);
            if (isErrorType(type)) {
                return errorType;
            }
            else {
                compilerAssert(false, `Unexpected checker error. symbolLinks.instantiations was not defined for ${SyntaxKind[templateNode.kind]}`);
            }
        }
        const cached = symbolLinks.instantiations.get(args);
        if (cached) {
            return cached;
        }
        const mapper = createTypeMapper(params, args);
        const type = getTypeForNode(templateNode, mapper);
        if (!symbolLinks.instantiations.get(args)) {
            symbolLinks.instantiations.set(args, type);
        }
        if (type.kind === "Model") {
            type.templateNode = templateNode;
        }
        return type;
    }
    function checkUnionExpression(node, mapper) {
        const unionType = createAndFinishType({
            kind: "Union",
            node,
            get options() {
                return Array.from(this.variants.values()).map((v) => v.type);
            },
            expression: true,
            variants: new Map(),
            decorators: [],
        });
        for (const o of node.options) {
            const type = getTypeForNode(o, mapper);
            // The type `A | never` is just `A`
            if (type === neverType) {
                continue;
            }
            if (type.kind === "Union" && type.expression) {
                for (const [name, variant] of type.variants) {
                    unionType.variants.set(name, variant);
                }
            }
            else {
                const variant = createType({
                    kind: "UnionVariant",
                    type,
                    name: Symbol("name"),
                    decorators: [],
                    node: undefined,
                    union: unionType,
                });
                unionType.variants.set(variant.name, variant);
            }
        }
        return unionType;
    }
    /**
     * Intersection produces a model type from the properties of its operands.
     * So this doesn't work if we don't have a known set of properties (e.g.
     * with unions). The resulting model is anonymous.
     */
    function checkIntersectionExpression(node, mapper) {
        const options = node.options.map((o) => [o, getTypeForNode(o, mapper)]);
        return mergeModelTypes(node, options, mapper);
    }
    function mergeModelTypes(node, options, mapper) {
        const properties = new Map();
        const intersection = createType({
            kind: "Model",
            node,
            name: "",
            properties: properties,
            decorators: [],
            derivedModels: [],
        });
        const indexers = [];
        for (const [optionNode, option] of options) {
            if (option.kind === "TemplateParameter") {
                continue;
            }
            if (option.kind !== "Model") {
                program.reportDiagnostic(createDiagnostic({ code: "intersect-non-model", target: optionNode }));
                continue;
            }
            if (option.indexer) {
                if (isNeverIndexer(option.indexer)) {
                    reportDiagnostic(program, {
                        code: "intersect-invalid-index",
                        messageId: "never",
                        target: optionNode,
                    });
                }
                else if (option.indexer.key.name === "integer") {
                    program.reportDiagnostic(createDiagnostic({
                        code: "intersect-invalid-index",
                        messageId: "array",
                        target: optionNode,
                    }));
                }
                else {
                    indexers.push(option.indexer);
                }
            }
            if (indexers.length === 1) {
                intersection.indexer = indexers[0];
            }
            else if (indexers.length > 1) {
                intersection.indexer = {
                    key: indexers[0].key,
                    value: mergeModelTypes(node, indexers.map((x) => [x.value.node, x.value]), mapper),
                };
            }
            const allProps = walkPropertiesInherited(option);
            for (const prop of allProps) {
                if (properties.has(prop.name)) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "intersect-duplicate-property",
                        format: { propName: prop.name },
                        target: node,
                    }));
                    continue;
                }
                const newPropType = cloneType(prop, {
                    sourceProperty: prop,
                    model: intersection,
                });
                properties.set(prop.name, newPropType);
            }
        }
        return finishType(intersection, mapper);
    }
    function checkArrayExpression(node, mapper) {
        const elementType = getTypeForNode(node.elementType, mapper);
        const arrayType = getStdType("Array");
        const arrayNode = arrayType.node;
        const param = getTypeForNode(arrayNode.templateParameters[0]);
        return instantiateTemplate(arrayNode, [param], [elementType]);
    }
    function checkNamespace(node) {
        const links = getSymbolLinks(getMergedSymbol(node.symbol));
        let type = links.type;
        if (!type) {
            type = initializeTypeForNamespace(node);
        }
        if (isArray(node.statements)) {
            node.statements.forEach((x) => getTypeForNode(x));
        }
        else if (node.statements) {
            const subNs = checkNamespace(node.statements);
            type.namespaces.set(subNs.name, subNs);
        }
        return type;
    }
    function initializeTypeForNamespace(node) {
        compilerAssert(node.symbol, "Namespace is unbound.", node);
        const mergedSymbol = getMergedSymbol(node.symbol);
        const symbolLinks = getSymbolLinks(mergedSymbol);
        if (!symbolLinks.type) {
            // haven't seen this namespace before
            const namespace = getParentNamespaceType(node);
            const name = node.id.sv;
            const type = createType({
                kind: "Namespace",
                name,
                namespace,
                node,
                models: new Map(),
                operations: new Map(),
                namespaces: new Map(),
                interfaces: new Map(),
                unions: new Map(),
                enums: new Map(),
                decorators: [],
            });
            symbolLinks.type = type;
            for (const sourceNode of mergedSymbol.declarations) {
                // namespaces created from cadl scripts don't have decorators
                if (sourceNode.kind !== SyntaxKind.NamespaceStatement)
                    continue;
                type.decorators = type.decorators.concat(checkDecorators(sourceNode, undefined));
            }
            finishType(type);
            namespace === null || namespace === void 0 ? void 0 : namespace.namespaces.set(name, type);
        }
        return symbolLinks.type;
    }
    function getParentNamespaceType(node) {
        if (node === globalNamespaceType.node)
            return undefined;
        if (node.kind === SyntaxKind.ModelExpression) {
            let parent = node.parent;
            while (parent !== undefined) {
                if (parent.kind === SyntaxKind.ModelStatement ||
                    parent.kind === SyntaxKind.OperationStatement ||
                    parent.kind === SyntaxKind.EnumStatement ||
                    parent.kind === SyntaxKind.InterfaceStatement ||
                    parent.kind === SyntaxKind.UnionStatement ||
                    parent.kind === SyntaxKind.ModelExpression) {
                    return getParentNamespaceType(parent);
                }
                else {
                    parent = parent.parent;
                }
            }
            return undefined;
        }
        if (node.kind === SyntaxKind.OperationStatement &&
            node.parent &&
            node.parent.kind === SyntaxKind.InterfaceStatement) {
            return getParentNamespaceType(node.parent);
        }
        if (!node.symbol.parent) {
            return globalNamespaceType;
        }
        if (node.symbol.parent.declarations[0].kind === SyntaxKind.CadlScript ||
            node.symbol.parent.declarations[0].kind === SyntaxKind.JsSourceFile) {
            return globalNamespaceType;
        }
        const mergedSymbol = getMergedSymbol(node.symbol.parent);
        const symbolLinks = getSymbolLinks(mergedSymbol);
        if (!symbolLinks.type) {
            // in general namespaces should be typed before anything calls this function.
            // However, one case where this is not true is when a decorator on a namespace
            // refers to a model in another namespace. In this case, we need to evaluate
            // the namespace here.
            const namespaceNode = mergedSymbol.declarations.find((x) => x.kind === SyntaxKind.NamespaceStatement);
            compilerAssert(namespaceNode, "Can't find namespace declaration node.", node);
            symbolLinks.type = initializeTypeForNamespace(namespaceNode);
        }
        return symbolLinks.type;
    }
    function checkOperation(node, mapper, parentInterface) {
        // Operations defined in interfaces aren't bound to symbols
        const links = !parentInterface ? getSymbolLinks(node.symbol) : undefined;
        if (links) {
            if (links.declaredType && mapper === undefined) {
                // we're not instantiating this operation and we've already checked it
                return links.declaredType;
            }
        }
        const namespace = getParentNamespaceType(node);
        const name = node.id.sv;
        let decorators = checkDecorators(node, mapper);
        // Is this a definition or reference?
        let parameters, returnType;
        if (node.signature.kind === SyntaxKind.OperationSignatureReference) {
            // Attempt to resolve the operation
            const baseOperation = checkOperationIs(node, node.signature.baseOperation, mapper);
            if (!baseOperation) {
                return errorType;
            }
            // Reference the same return type and create the parameters type
            parameters = cloneType(baseOperation.parameters);
            parameters.node = parameters.node ? { ...parameters.node, parent: node } : undefined;
            returnType = baseOperation.returnType;
            // Copy decorators from the base operation, inserting the base decorators first
            decorators = [...baseOperation.decorators, ...decorators];
        }
        else {
            parameters = getTypeForNode(node.signature.parameters, mapper);
            returnType = getTypeForNode(node.signature.returnType, mapper);
        }
        const operationType = createType({
            kind: "Operation",
            name,
            namespace,
            node,
            parameters,
            returnType,
            decorators,
            interface: parentInterface,
        });
        operationType.parameters.namespace = namespace;
        if (node.parent.kind === SyntaxKind.InterfaceStatement) {
            if (shouldCreateTypeForTemplate(node.parent, mapper) &&
                shouldCreateTypeForTemplate(node, mapper)) {
                finishType(operationType, mapper);
            }
        }
        else {
            if (shouldCreateTypeForTemplate(node, mapper)) {
                finishType(operationType, mapper);
            }
            namespace === null || namespace === void 0 ? void 0 : namespace.operations.set(name, operationType);
        }
        if (links) {
            linkType(links, operationType, mapper);
        }
        return operationType;
    }
    function checkOperationIs(operation, opReference, mapper) {
        if (!opReference)
            return undefined;
        // Ensure that we don't end up with a circular reference to the same operation
        const opSymId = getNodeSymId(operation);
        if (opSymId) {
            pendingResolutions.add(opSymId);
        }
        const target = resolveTypeReference(opReference, mapper);
        if (target === undefined) {
            return undefined;
        }
        // Did we encounter a circular operation reference?
        if (pendingResolutions.has(getNodeSymId(target.declarations[0]))) {
            if (mapper === undefined) {
                reportDiagnostic(program, {
                    code: "circular-op-signature",
                    format: { typeName: target.declarations[0].id.sv },
                    target: opReference,
                });
            }
            return undefined;
        }
        // Resolve the base operation type
        const baseOperation = checkTypeReferenceSymbol(target, opReference, mapper);
        if (opSymId) {
            pendingResolutions.delete(opSymId);
        }
        if (isErrorType(baseOperation)) {
            return undefined;
        }
        // Was the wrong type referenced?
        if (baseOperation.kind !== "Operation") {
            program.reportDiagnostic(createDiagnostic({ code: "is-operation", target: opReference }));
            return;
        }
        return baseOperation;
    }
    function getGlobalNamespaceType() {
        return globalNamespaceType;
    }
    function getGlobalNamespaceNode() {
        return globalNamespaceNode;
    }
    function checkTupleExpression(node, mapper) {
        return createAndFinishType({
            kind: "Tuple",
            node: node,
            values: node.values.map((v) => getTypeForNode(v, mapper)),
        });
    }
    function getSymbolLinks(s) {
        const id = getSymbolId(s);
        if (symbolLinks.has(id)) {
            return symbolLinks.get(id);
        }
        const links = {};
        symbolLinks.set(id, links);
        return links;
    }
    function getSymbolId(s) {
        if (s.id === undefined) {
            s.id = currentSymbolId++;
        }
        return s.id;
    }
    function resolveIdentifierInTable(node, table, resolveDecorator = false) {
        var _a;
        if (!table) {
            return undefined;
        }
        let sym;
        if (resolveDecorator) {
            sym = table.get("@" + node.sv);
        }
        else {
            sym = table.get(node.sv);
        }
        if (!sym)
            return sym;
        if (sym.flags & 524288 /* SymbolFlags.DuplicateUsing */) {
            reportAmbiguousIdentifier(node, [...((_a = table.duplicates.get(sym)) !== null && _a !== void 0 ? _a : [])]);
            return sym;
        }
        return getMergedSymbol(sym);
    }
    function reportAmbiguousIdentifier(node, symbols) {
        const duplicateNames = symbols
            .map((x) => {
            const namespace = x.symbolSource.flags & (8192 /* SymbolFlags.Decorator */ | 65536 /* SymbolFlags.Function */)
                ? x.symbolSource.value.namespace
                : getNamespaceString(getTypeForNode(x.symbolSource.declarations[0], undefined).namespace);
            return `${namespace}.${node.sv}`;
        })
            .join(", ");
        program.reportDiagnostic(createDiagnostic({
            code: "ambiguous-symbol",
            format: { name: node.sv, duplicateNames },
            target: node,
        }));
    }
    function resolveIdentifier(id, mapper) {
        var _a, _b, _c;
        let sym;
        const { node, kind } = getIdentifierContext(id);
        switch (kind) {
            case IdentifierKind.Declaration:
                if (node.symbol) {
                    sym = getMergedSymbol(node.symbol);
                    break;
                }
                compilerAssert(node.parent, "Parent expected.");
                const containerType = getTypeForNode(node.parent, mapper);
                if (isAnonymous(containerType)) {
                    return undefined; // member of anonymous type cannot be referenced.
                }
                lateBindMemberContainer(containerType);
                let container = node.parent.symbol;
                if (!container && "symbol" in containerType && containerType.symbol) {
                    container = containerType.symbol;
                }
                if (!container) {
                    return undefined;
                }
                lateBindMembers(containerType, container);
                sym = resolveIdentifierInTable(id, (_a = container.exports) !== null && _a !== void 0 ? _a : container.members);
                break;
            case IdentifierKind.Other:
                return undefined;
            case IdentifierKind.Decorator:
            case IdentifierKind.Using:
            case IdentifierKind.TypeReference:
                let ref = id;
                let resolveDecorator = kind === IdentifierKind.Decorator;
                if (((_b = id.parent) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.MemberExpression) {
                    if (id.parent.id === id) {
                        // If the identifier is Y in X.Y, then resolve (X.Y).
                        ref = id.parent;
                    }
                    else {
                        // If the identifier is X in X.Y then we are resolving a
                        // namespace, which is never a decorator.
                        resolveDecorator = false;
                    }
                }
                sym = resolveTypeReference(ref, mapper, resolveDecorator);
                break;
            default:
                compilerAssert(false, "Unreachable");
        }
        return (_c = sym === null || sym === void 0 ? void 0 : sym.symbolSource) !== null && _c !== void 0 ? _c : sym;
    }
    function resolveCompletions(identifier) {
        var _a;
        const completions = new Map();
        const { kind } = getIdentifierContext(identifier);
        switch (kind) {
            case IdentifierKind.Using:
            case IdentifierKind.Decorator:
            case IdentifierKind.TypeReference:
                break; // supported
            case IdentifierKind.Other:
                return completions; // not implemented
            case IdentifierKind.Declaration:
                return completions; // cannot complete, name can be chosen arbitrarily
            default:
                compilerAssert(false, "Unreachable");
        }
        if (identifier.parent && identifier.parent.kind === SyntaxKind.MemberExpression) {
            const base = resolveTypeReference(identifier.parent.base, undefined, false);
            if (base) {
                const type = getTypeForNode(base.declarations[0], undefined);
                lateBindMemberContainer(type);
                lateBindMembers(type, base);
                addCompletions((_a = base.exports) !== null && _a !== void 0 ? _a : base.members);
            }
        }
        else {
            let scope = identifier.parent;
            while (scope && scope.kind !== SyntaxKind.CadlScript) {
                if (scope.symbol && scope.symbol.exports) {
                    const mergedSymbol = getMergedSymbol(scope.symbol);
                    addCompletions(mergedSymbol.exports);
                }
                if ("locals" in scope) {
                    addCompletions(scope.locals);
                }
                scope = scope.parent;
            }
            if (scope && scope.kind === SyntaxKind.CadlScript) {
                // check any blockless namespace decls
                for (const ns of scope.inScopeNamespaces) {
                    const mergedSymbol = getMergedSymbol(ns.symbol);
                    addCompletions(mergedSymbol.exports);
                }
                // check "global scope" declarations
                addCompletions(globalNamespaceNode.symbol.exports);
                // check "global scope" usings
                addCompletions(scope.locals);
            }
        }
        return completions;
        function addCompletions(table) {
            if (!table) {
                return;
            }
            for (const [key, sym] of table) {
                if (sym.flags & 524288 /* SymbolFlags.DuplicateUsing */) {
                    const duplicates = table.duplicates.get(sym);
                    for (const duplicate of duplicates) {
                        if (duplicate.flags & 262144 /* SymbolFlags.Using */) {
                            const fqn = getFullyQualifiedSymbolName(duplicate.symbolSource);
                            addCompletion(fqn, duplicate);
                        }
                    }
                }
                else {
                    addCompletion(key, sym);
                }
            }
        }
        function addCompletion(key, sym) {
            if (sym.symbolSource) {
                sym = sym.symbolSource;
            }
            if (!shouldAddCompletion(sym)) {
                return;
            }
            if (key.startsWith("@")) {
                key = key.slice(1);
            }
            if (!completions.has(key)) {
                completions.set(key, { sym });
            }
        }
        function shouldAddCompletion(sym) {
            switch (kind) {
                case IdentifierKind.Decorator:
                    // Only return decorators and namespaces when completing decorator
                    return !!(sym.flags & (8192 /* SymbolFlags.Decorator */ | 2048 /* SymbolFlags.Namespace */));
                case IdentifierKind.Using:
                    // Only return namespaces when completing using
                    return !!(sym.flags & 2048 /* SymbolFlags.Namespace */);
                case IdentifierKind.TypeReference:
                    // Do not return functions or decorators when completing types
                    return !(sym.flags & (65536 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Decorator */));
                default:
                    compilerAssert(false, "We should have bailed up-front on other kinds.");
            }
        }
    }
    function resolveIdentifierInScope(node, mapper, resolveDecorator = false) {
        var _a;
        compilerAssert(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) !== SyntaxKind.MemberExpression || node.parent.id !== node, "This function should not be used to resolve Y in member expression X.Y. Use resolveIdentifier() to resolve an arbitrary identifier.");
        if (hasParseError(node)) {
            // Don't report synthetic identifiers used for parser error recovery.
            // The parse error is the root cause and will already have been logged.
            return undefined;
        }
        let scope = node.parent;
        let binding;
        while (scope && scope.kind !== SyntaxKind.CadlScript) {
            if (scope.symbol && "exports" in scope.symbol) {
                const mergedSymbol = getMergedSymbol(scope.symbol);
                binding = resolveIdentifierInTable(node, mergedSymbol.exports, resolveDecorator);
                if (binding)
                    return binding;
            }
            if ("locals" in scope) {
                if ("duplicates" in scope.locals) {
                    binding = resolveIdentifierInTable(node, scope.locals, resolveDecorator);
                }
                else {
                    binding = resolveIdentifierInTable(node, scope.locals, resolveDecorator);
                }
                if (binding)
                    return binding;
            }
            scope = scope.parent;
        }
        if (!binding && scope && scope.kind === SyntaxKind.CadlScript) {
            // check any blockless namespace decls
            for (const ns of scope.inScopeNamespaces) {
                const mergedSymbol = getMergedSymbol(ns.symbol);
                binding = resolveIdentifierInTable(node, mergedSymbol.exports, resolveDecorator);
                if (binding)
                    return binding;
            }
            // check "global scope" declarations
            binding = resolveIdentifierInTable(node, globalNamespaceNode.symbol.exports, resolveDecorator);
            if (binding)
                return binding;
            // check using types
            binding = resolveIdentifierInTable(node, scope.locals, resolveDecorator);
            if (binding)
                return binding.flags & 524288 /* SymbolFlags.DuplicateUsing */ ? undefined : binding;
        }
        if (mapper === undefined) {
            program.reportDiagnostic(createDiagnostic({ code: "unknown-identifier", format: { id: node.sv }, target: node }));
        }
        return undefined;
    }
    function resolveTypeReference(node, mapper, resolveDecorator = false) {
        if (hasParseError(node)) {
            // Don't report synthetic identifiers used for parser error recovery.
            // The parse error is the root cause and will already have been logged.
            return undefined;
        }
        if (node.kind === SyntaxKind.TypeReference) {
            return resolveTypeReference(node.target, mapper, resolveDecorator);
        }
        if (node.kind === SyntaxKind.MemberExpression) {
            let base = resolveTypeReference(node.base, mapper);
            if (!base) {
                return undefined;
            }
            // when resolving a type reference based on an alias, unwrap the alias.
            if (base.flags & 1024 /* SymbolFlags.Alias */) {
                base = getAliasedSymbol(base, mapper);
            }
            if (base.flags & 2048 /* SymbolFlags.Namespace */) {
                const symbol = resolveIdentifierInTable(node.id, base.exports, resolveDecorator);
                if (!symbol) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-ref",
                        messageId: "underNamespace",
                        format: {
                            namespace: getFullyQualifiedSymbolName(base),
                            id: node.id.sv,
                        },
                        target: node,
                    }));
                    return undefined;
                }
                return symbol;
            }
            else if (base.flags & 8192 /* SymbolFlags.Decorator */) {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "inDecorator",
                    format: { id: node.id.sv },
                    target: node,
                }));
                return undefined;
            }
            else if (base.flags & 65536 /* SymbolFlags.Function */) {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "node",
                    format: { id: node.id.sv, nodeName: "function" },
                    target: node,
                }));
                return undefined;
            }
            else if (base.flags & 338 /* SymbolFlags.MemberContainer */) {
                const type = base.flags & 2097152 /* SymbolFlags.LateBound */
                    ? base.type
                    : getTypeForNode(base.declarations[0], mapper);
                if (type.kind !== "Model" &&
                    type.kind !== "Enum" &&
                    type.kind !== "Interface" &&
                    type.kind !== "Union") {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-ref",
                        messageId: "underContainer",
                        format: { kind: type.kind, id: node.id.sv },
                        target: node,
                    }));
                    return undefined;
                }
                lateBindMembers(type, base);
                const sym = resolveIdentifierInTable(node.id, base.members, resolveDecorator);
                if (!sym) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "invalid-ref",
                        messageId: "underContainer",
                        format: { kind: type.kind, id: node.id.sv },
                        target: node,
                    }));
                    return undefined;
                }
                return sym;
            }
            else {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-ref",
                    messageId: "node",
                    format: {
                        id: node.id.sv,
                        nodeName: base.declarations[0]
                            ? SyntaxKind[base.declarations[0].kind]
                            : "Unknown node",
                    },
                    target: node,
                }));
                return undefined;
            }
        }
        if (node.kind === SyntaxKind.Identifier) {
            const sym = resolveIdentifierInScope(node, mapper, resolveDecorator);
            if (!sym)
                return undefined;
            return sym.flags & 262144 /* SymbolFlags.Using */ ? sym.symbolSource : sym;
        }
        compilerAssert(false, "Unknown type reference kind", node);
    }
    /**
     * Return the symbol that is aliased by this alias declaration. If no such symbol is aliased,
     * return the symbol for the alias instead. For member containers which need to be late bound
     * (i.e. they contain symbols we don't know until we've instantiated the type and the type is an
     * instantiation) we late bind the container which creates the symbol that will hold its members.
     */
    function getAliasedSymbol(aliasSymbol, mapper) {
        var _a;
        const aliasType = checkAlias(aliasSymbol.declarations[0], mapper);
        switch (aliasType.kind) {
            case "Model":
            case "Interface":
            case "Union":
                if (aliasType.templateArguments) {
                    // this is an alias for some instantiation, so late-bind the instantiation
                    lateBindMemberContainer(aliasType);
                    return aliasType.symbol;
                }
            // fallthrough
            default:
                // get the symbol from the node aliased type's node, or just return the base
                // if it doesn't have a symbol (which will likely result in an error later on)
                return (_a = aliasType.node.symbol) !== null && _a !== void 0 ? _a : aliasSymbol;
        }
    }
    function checkStringLiteral(str) {
        return getLiteralType(str);
    }
    function checkNumericLiteral(num) {
        return getLiteralType(num);
    }
    function checkBooleanLiteral(bool) {
        return getLiteralType(bool);
    }
    function checkProgram() {
        program.reportDuplicateSymbols(globalNamespaceNode.symbol.exports);
        for (const file of program.sourceFiles.values()) {
            for (const ns of file.namespaces) {
                program.reportDuplicateSymbols(ns.symbol.exports);
                initializeTypeForNamespace(ns);
            }
        }
        for (const file of program.sourceFiles.values()) {
            checkSourceFile(file);
        }
    }
    function checkSourceFile(file) {
        for (const statement of file.statements) {
            getTypeForNode(statement, undefined);
        }
    }
    function checkModel(node, mapper) {
        if (node.kind === SyntaxKind.ModelStatement) {
            return checkModelStatement(node, mapper);
        }
        else {
            return checkModelExpression(node, mapper);
        }
    }
    function checkModelStatement(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this model and we've already checked it
            return links.declaredType;
        }
        const decorators = [];
        const type = createType({
            kind: "Model",
            name: node.id.sv,
            node: node,
            properties: new Map(),
            namespace: getParentNamespaceType(node),
            decorators,
            derivedModels: [],
        });
        linkType(links, type, mapper);
        const isBase = checkModelIs(node, node.is, mapper);
        if (isBase) {
            checkDeprecated(isBase, node.is);
            // copy decorators
            decorators.push(...isBase.decorators);
            if (isBase.indexer) {
                type.indexer = isBase.indexer;
            }
        }
        decorators.push(...checkDecorators(node, mapper));
        if (isBase) {
            for (const prop of isBase.properties.values()) {
                type.properties.set(prop.name, finishType({
                    ...prop,
                }));
            }
        }
        if (isBase) {
            type.baseModel = isBase.baseModel;
        }
        else if (node.extends) {
            type.baseModel = checkClassHeritage(node, node.extends, mapper);
            if (type.baseModel) {
                checkDeprecated(type.baseModel, node.extends);
            }
        }
        if (type.baseModel) {
            type.baseModel.derivedModels.push(type);
        }
        // Hold on to the model type that's being defined so that it
        // can be referenced
        if (mapper === undefined) {
            (_a = type.namespace) === null || _a === void 0 ? void 0 : _a.models.set(type.name, type);
        }
        const inheritedPropNames = new Set(Array.from(walkPropertiesInherited(type)).map((v) => v.name));
        // Evaluate the properties after
        checkModelProperties(node, type.properties, type, mapper, inheritedPropNames);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(type, mapper);
        }
        const indexer = getIndexer(program, type);
        if (type.name === "Array" && isInCadlNamespace(type)) {
            stdTypes.Array = type;
        }
        else if (type.name === "Record" && isInCadlNamespace(type)) {
            stdTypes.Record = type;
        }
        if (indexer) {
            type.indexer = indexer;
        }
        else {
            const intrinsicModelName = getIntrinsicModelName(program, type);
            if (intrinsicModelName) {
                type.indexer = { key: neverType, value: undefined };
            }
        }
        return type;
    }
    function shouldCreateTypeForTemplate(node, mapper) {
        // Node is not a template we should create the type.
        if (node.templateParameters.length === 0) {
            return true;
        }
        // There is no mapper so we shouldn't be instantiating the template.
        if (mapper === undefined) {
            return false;
        }
        // Some of the mapper args are still template parameter so we shouldn't create the type.
        return mapper.args.every((t) => t.kind !== "TemplateParameter");
    }
    function checkModelExpression(node, mapper) {
        const properties = new Map();
        const type = createType({
            kind: "Model",
            name: "",
            node: node,
            properties,
            indexer: undefined,
            namespace: getParentNamespaceType(node),
            decorators: [],
            derivedModels: [],
        });
        checkModelProperties(node, properties, type, mapper);
        return finishType(type);
    }
    function checkPropertyCompatibleWithIndexer(parentModel, property, diagnosticTarget) {
        if (parentModel.indexer === undefined) {
            return;
        }
        if (isNeverIndexer(parentModel.indexer)) {
            reportDiagnostic(program, {
                code: "no-prop",
                format: { propName: property.name },
                target: diagnosticTarget,
            });
        }
        else {
            const [valid, diagnostics] = isTypeAssignableTo(property.type, parentModel.indexer.value, diagnosticTarget.kind === SyntaxKind.ModelSpreadProperty
                ? diagnosticTarget
                : diagnosticTarget.value);
            if (!valid)
                program.reportDiagnostics(diagnostics);
        }
    }
    function checkModelProperties(node, properties, parentModel, mapper, inheritedPropertyNames) {
        for (const prop of node.properties) {
            if ("id" in prop) {
                const newProp = checkModelProperty(prop, mapper, parentModel);
                checkPropertyCompatibleWithIndexer(parentModel, newProp, prop);
                defineProperty(properties, newProp, inheritedPropertyNames);
            }
            else {
                // spread property
                const newProperties = checkSpreadProperty(prop.target, parentModel, mapper);
                for (const newProp of newProperties) {
                    checkPropertyCompatibleWithIndexer(parentModel, newProp, prop);
                    defineProperty(properties, newProp, inheritedPropertyNames, prop);
                }
            }
        }
    }
    function defineProperty(properties, newProp, inheritedPropertyNames, diagnosticTarget) {
        if (properties.has(newProp.name)) {
            program.reportDiagnostic(createDiagnostic({
                code: "duplicate-property",
                format: { propName: newProp.name },
                target: diagnosticTarget !== null && diagnosticTarget !== void 0 ? diagnosticTarget : newProp,
            }));
            return;
        }
        if (inheritedPropertyNames === null || inheritedPropertyNames === void 0 ? void 0 : inheritedPropertyNames.has(newProp.name)) {
            program.reportDiagnostic(createDiagnostic({
                code: "override-property",
                format: { propName: newProp.name },
                target: diagnosticTarget !== null && diagnosticTarget !== void 0 ? diagnosticTarget : newProp,
            }));
            return;
        }
        properties.set(newProp.name, newProp);
    }
    /**
     * Initializes a late bound symbol for the type. This is generally necessary when attempting to
     * access a symbol for a type that is created during the check phase.
     */
    function lateBindMemberContainer(type) {
        if (type.symbol)
            return;
        switch (type.kind) {
            case "Model":
                type.symbol = createSymbol(type.node, type.name, 2 /* SymbolFlags.Model */ | 2097152 /* SymbolFlags.LateBound */);
                type.symbol.type = type;
                break;
            case "Interface":
                type.symbol = createSymbol(type.node, type.name, 64 /* SymbolFlags.Interface */ | 2097152 /* SymbolFlags.LateBound */);
                type.symbol.type = type;
                break;
            case "Union":
                if (!type.name)
                    return; // don't make a symbol for anonymous unions
                type.symbol = createSymbol(type.node, type.name, 256 /* SymbolFlags.Union */ | 2097152 /* SymbolFlags.LateBound */);
                type.symbol.type = type;
                break;
        }
    }
    function lateBindMembers(type, containerSym) {
        switch (type.kind) {
            case "Model":
                for (const prop of walkPropertiesInherited(type)) {
                    const sym = createSymbol(prop.node, prop.name, 4 /* SymbolFlags.ModelProperty */ | 2097152 /* SymbolFlags.LateBound */);
                    sym.type = prop;
                    containerSym.members.set(prop.name, sym);
                }
                break;
            case "Enum":
                for (const member of type.members) {
                    const sym = createSymbol(member.node, member.name, 32 /* SymbolFlags.EnumMember */ | 2097152 /* SymbolFlags.LateBound */);
                    sym.type = member;
                    containerSym.members.set(member.name, sym);
                }
                break;
            case "Interface":
                for (const member of type.operations.values()) {
                    const sym = createSymbol(member.node, member.name, 128 /* SymbolFlags.InterfaceMember */ | 2097152 /* SymbolFlags.LateBound */);
                    sym.type = member;
                    containerSym.members.set(member.name, sym);
                }
                break;
            case "Union":
                for (const variant of type.variants.values()) {
                    // don't bind anything for union expressions
                    if (!variant.node || typeof variant.name === "symbol")
                        continue;
                    const sym = createSymbol(variant.node, variant.name, 512 /* SymbolFlags.UnionVariant */ | 2097152 /* SymbolFlags.LateBound */);
                    sym.type = variant;
                    containerSym.members.set(variant.name, sym);
                }
        }
    }
    function checkClassHeritage(model, heritageRef, mapper) {
        if (heritageRef.kind !== SyntaxKind.TypeReference) {
            reportDiagnostic(program, {
                code: "extend-model",
                target: heritageRef,
            });
            return undefined;
        }
        const modelSymId = getNodeSymId(model);
        pendingResolutions.add(modelSymId);
        const target = resolveTypeReference(heritageRef, mapper);
        if (target === undefined) {
            return undefined;
        }
        if (pendingResolutions.has(getNodeSymId(target.declarations[0]))) {
            if (mapper === undefined) {
                reportDiagnostic(program, {
                    code: "circular-base-type",
                    format: { typeName: target.declarations[0].id.sv },
                    target: target,
                });
            }
            return undefined;
        }
        const heritageType = checkTypeReferenceSymbol(target, heritageRef, mapper);
        pendingResolutions.delete(modelSymId);
        if (isErrorType(heritageType)) {
            compilerAssert(program.hasError(), "Should already have reported an error.", heritageRef);
            return undefined;
        }
        if (heritageType.kind !== "Model") {
            program.reportDiagnostic(createDiagnostic({ code: "extend-model", target: heritageRef }));
            return undefined;
        }
        if (isIntrinsic(program, heritageType)) {
            program.reportDiagnostic(createDiagnostic({
                code: "extend-primitive",
                target: heritageRef,
                format: {
                    modelName: model.id.sv,
                    baseModelName: heritageType.name,
                },
            }));
        }
        return heritageType;
    }
    function checkModelIs(model, isExpr, mapper) {
        if (!isExpr)
            return undefined;
        const modelSymId = getNodeSymId(model);
        pendingResolutions.add(modelSymId);
        let isType;
        if (isExpr.kind === SyntaxKind.ArrayExpression) {
            isType = checkArrayExpression(isExpr, mapper);
        }
        else if (isExpr.kind === SyntaxKind.TypeReference) {
            const target = resolveTypeReference(isExpr, mapper);
            if (target === undefined) {
                return undefined;
            }
            if (pendingResolutions.has(getNodeSymId(target.declarations[0]))) {
                if (mapper === undefined) {
                    reportDiagnostic(program, {
                        code: "circular-base-type",
                        format: { typeName: target.declarations[0].id.sv },
                        target: target,
                    });
                }
                return undefined;
            }
            isType = checkTypeReferenceSymbol(target, isExpr, mapper);
        }
        else {
            reportDiagnostic(program, { code: "is-model", target: isExpr });
            return undefined;
        }
        pendingResolutions.delete(modelSymId);
        if (isType.kind !== "Model") {
            program.reportDiagnostic(createDiagnostic({ code: "is-model", target: isExpr }));
            return;
        }
        return isType;
    }
    function checkSpreadProperty(targetNode, parentModel, mapper) {
        const targetType = getTypeForNode(targetNode, mapper);
        if (targetType.kind === "TemplateParameter" || isErrorType(targetType)) {
            return [];
        }
        if (targetType.kind !== "Model") {
            program.reportDiagnostic(createDiagnostic({ code: "spread-model", target: targetNode }));
            return [];
        }
        if (targetType.indexer && isNeverIndexer(targetType.indexer)) {
            program.reportDiagnostic(createDiagnostic({ code: "spread-model", messageId: "neverIndex", target: targetNode }));
            return [];
        }
        const props = [];
        // copy each property
        for (const prop of walkPropertiesInherited(targetType)) {
            const newProp = cloneType(prop, {
                sourceProperty: prop,
                model: parentModel,
            });
            props.push(newProp);
        }
        return props;
    }
    function* walkPropertiesInherited(model) {
        let current = model;
        while (current) {
            yield* current.properties.values();
            current = current.baseModel;
        }
    }
    function countPropertiesInherited(model, filter) {
        let count = 0;
        if (filter) {
            for (const each of walkPropertiesInherited(model)) {
                if (filter(each)) {
                    count++;
                }
            }
        }
        else {
            for (let m = model; m; m = m.baseModel) {
                count += m.properties.size;
            }
        }
        return count;
    }
    function checkModelProperty(prop, mapper, parentModel) {
        const decorators = checkDecorators(prop, mapper);
        const valueType = getTypeForNode(prop.value, mapper);
        const defaultValue = prop.default && checkDefault(prop.default, valueType);
        const name = prop.id.kind === SyntaxKind.Identifier ? prop.id.sv : prop.id.value;
        const type = createType({
            kind: "ModelProperty",
            name,
            node: prop,
            optional: prop.optional,
            type: valueType,
            decorators,
            default: defaultValue,
            model: parentModel,
        });
        const parentModelNode = prop.parent;
        if (parentModelNode.kind !== SyntaxKind.ModelStatement ||
            shouldCreateTypeForTemplate(parentModelNode, mapper)) {
            finishType(type, mapper);
        }
        return type;
    }
    function isValueType(type) {
        const valueTypes = new Set(["String", "Number", "Boolean", "EnumMember", "Tuple"]);
        return valueTypes.has(type.kind);
    }
    function checkDefault(defaultNode, type) {
        const defaultType = getTypeForNode(defaultNode, undefined);
        if (isErrorType(type)) {
            return errorType;
        }
        if (!isValueType(defaultType)) {
            program.reportDiagnostic(createDiagnostic({
                code: "unsupported-default",
                format: { type: type.kind },
                target: defaultType,
            }));
            return errorType;
        }
        const [related, diagnostics] = isTypeAssignableTo(defaultType, type, defaultNode);
        if (!related) {
            program.reportDiagnostics(diagnostics);
            return errorType;
        }
        else {
            return defaultType;
        }
    }
    function checkDecorators(node, mapper) {
        const decorators = [];
        for (const decNode of node.decorators) {
            const sym = resolveTypeReference(decNode.target, undefined, true);
            if (!sym) {
                program.reportDiagnostic(createDiagnostic({
                    code: "unknown-decorator",
                    target: decNode,
                }));
                continue;
            }
            if (!(sym.flags & 8192 /* SymbolFlags.Decorator */)) {
                program.reportDiagnostic(createDiagnostic({
                    code: "invalid-decorator",
                    format: { id: sym.name },
                    target: decNode,
                }));
                continue;
            }
            decorators.unshift({
                decorator: sym.value,
                node: decNode,
                args: checkDecoratorArguments(decNode, mapper),
            });
        }
        return decorators;
    }
    function checkDecoratorArguments(decorator, mapper) {
        return decorator.arguments.map((argNode) => {
            const type = getTypeForNode(argNode, mapper);
            const value = type.kind === "Number" || type.kind === "String" || type.kind === "Boolean"
                ? type.value
                : type;
            return {
                value,
                node: argNode,
            };
        });
    }
    function checkAlias(node, mapper) {
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            return links.declaredType;
        }
        const aliasSymId = getNodeSymId(node);
        if (pendingResolutions.has(aliasSymId)) {
            if (mapper === undefined) {
                reportDiagnostic(program, {
                    code: "circular-alias-type",
                    format: { typeName: node.id.sv },
                    target: node,
                });
            }
            links.declaredType = errorType;
            return errorType;
        }
        pendingResolutions.add(aliasSymId);
        const type = getTypeForNode(node.value, mapper);
        linkType(links, type, mapper);
        pendingResolutions.delete(aliasSymId);
        return type;
    }
    function checkEnum(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (!links.type) {
            const enumType = (links.type = createType({
                kind: "Enum",
                name: node.id.sv,
                node,
                members: [],
                decorators: [],
            }));
            const memberNames = new Set();
            for (const member of node.members) {
                if (member.kind === SyntaxKind.EnumMember) {
                    const memberType = checkEnumMember(enumType, member, mapper, memberNames);
                    if (memberType) {
                        enumType.members.push(memberType);
                    }
                }
                else {
                    const members = checkEnumSpreadMember(enumType, member.target, mapper, memberNames);
                    for (const memberType of members) {
                        enumType.members.push(memberType);
                    }
                }
            }
            const namespace = getParentNamespaceType(node);
            enumType.namespace = namespace;
            (_a = enumType.namespace) === null || _a === void 0 ? void 0 : _a.enums.set(enumType.name, enumType);
            enumType.decorators = checkDecorators(node, mapper);
            finishType(enumType, mapper);
        }
        return links.type;
    }
    function checkInterface(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this interface and we've already checked it
            return links.declaredType;
        }
        const decorators = checkDecorators(node, mapper);
        const interfaceType = createType({
            kind: "Interface",
            decorators,
            node,
            namespace: getParentNamespaceType(node),
            operations: new Map(),
            name: node.id.sv,
        });
        linkType(links, interfaceType, mapper);
        for (const extendsNode of node.extends) {
            const extendsType = getTypeForNode(extendsNode, mapper);
            if (extendsType.kind !== "Interface") {
                program.reportDiagnostic(createDiagnostic({ code: "extends-interface", target: extendsNode }));
                continue;
            }
            for (const newMember of extendsType.operations.values()) {
                if (interfaceType.operations.has(newMember.name)) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "extends-interface-duplicate",
                        format: { name: newMember.name },
                        target: extendsNode,
                    }));
                }
                interfaceType.operations.set(newMember.name, cloneType(newMember, { interface: interfaceType }));
            }
        }
        checkInterfaceMembers(node, mapper, interfaceType);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(interfaceType, mapper);
        }
        if (mapper === undefined) {
            (_a = interfaceType.namespace) === null || _a === void 0 ? void 0 : _a.interfaces.set(interfaceType.name, interfaceType);
        }
        return interfaceType;
    }
    function checkInterfaceMembers(node, mapper, interfaceType) {
        const ownMembers = new Map();
        for (const opNode of node.operations) {
            const opType = checkOperation(opNode, mapper, interfaceType);
            if (opType.kind === "Operation") {
                if (ownMembers.has(opType.name)) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "interface-duplicate",
                        format: { name: opType.name },
                        target: opNode,
                    }));
                    continue;
                }
                ownMembers.set(opType.name, opType);
                interfaceType.operations.set(opType.name, opType);
            }
        }
    }
    function checkUnion(node, mapper) {
        var _a;
        const links = getSymbolLinks(node.symbol);
        if (links.declaredType && mapper === undefined) {
            // we're not instantiating this union and we've already checked it
            return links.declaredType;
        }
        const decorators = checkDecorators(node, mapper);
        const variants = new Map();
        const unionType = createType({
            kind: "Union",
            decorators,
            node,
            namespace: getParentNamespaceType(node),
            name: node.id.sv,
            variants,
            get options() {
                return Array.from(this.variants.values()).map((v) => v.type);
            },
            expression: false,
        });
        checkUnionVariants(unionType, node, variants, mapper);
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(unionType, mapper);
        }
        linkType(links, unionType, mapper);
        if (mapper === undefined) {
            (_a = unionType.namespace) === null || _a === void 0 ? void 0 : _a.unions.set(unionType.name, unionType);
        }
        return unionType;
    }
    function checkUnionVariants(parentUnion, node, variants, mapper) {
        for (const variantNode of node.options) {
            const variantType = checkUnionVariant(parentUnion, node, variantNode, mapper);
            if (variants.has(variantType.name)) {
                program.reportDiagnostic(createDiagnostic({
                    code: "union-duplicate",
                    format: { name: variantType.name.toString() },
                    target: variantNode,
                }));
                continue;
            }
            variants.set(variantType.name, variantType);
        }
    }
    function checkUnionVariant(parentUnion, node, variantNode, mapper) {
        const name = variantNode.id.kind === SyntaxKind.Identifier ? variantNode.id.sv : variantNode.id.value;
        const decorators = checkDecorators(variantNode, mapper);
        const type = getTypeForNode(variantNode.value, mapper);
        const variantType = createType({
            kind: "UnionVariant",
            name,
            node: variantNode,
            decorators,
            type,
            union: parentUnion,
        });
        if (shouldCreateTypeForTemplate(node, mapper)) {
            finishType(variantType, mapper);
        }
        return variantType;
    }
    function checkEnumMember(parentEnum, node, mapper, existingMemberNames) {
        const name = node.id.kind === SyntaxKind.Identifier ? node.id.sv : node.id.value;
        const value = node.value ? node.value.value : undefined;
        const decorators = checkDecorators(node, mapper);
        if (existingMemberNames.has(name)) {
            program.reportDiagnostic(createDiagnostic({
                code: "enum-member-duplicate",
                format: { name: name },
                target: node,
            }));
            return;
        }
        existingMemberNames.add(name);
        return createAndFinishType({
            kind: "EnumMember",
            enum: parentEnum,
            name,
            node,
            value,
            decorators,
        });
    }
    function checkEnumSpreadMember(parentEnum, targetNode, mapper, existingMemberNames) {
        const members = [];
        const targetType = getTypeForNode(targetNode, mapper);
        if (!isErrorType(targetType)) {
            if (targetType.kind !== "Enum") {
                program.reportDiagnostic(createDiagnostic({ code: "spread-enum", target: targetNode }));
                return members;
            }
            for (const member of targetType.members) {
                if (existingMemberNames.has(member.name)) {
                    program.reportDiagnostic(createDiagnostic({
                        code: "enum-member-duplicate",
                        format: { name: member.name },
                        target: targetNode,
                    }));
                }
                else {
                    existingMemberNames.add(member.name);
                    const clonedMember = cloneType(member, {
                        enum: parentEnum,
                        sourceMember: member,
                    });
                    if (clonedMember) {
                        members.push(clonedMember);
                    }
                }
            }
        }
        return members;
    }
    // the types here aren't ideal and could probably be refactored.
    function createAndFinishType(typeDef) {
        createType(typeDef);
        return finishType(typeDef);
    }
    /**
     * Given the own-properties of a type, returns a fully-initialized type.
     * So far, that amounts to setting the prototype to typePrototype which
     * contains the `projections` getter.
     */
    function createType(typeDef) {
        Object.setPrototypeOf(typeDef, typePrototype);
        return typeDef;
    }
    function finishType(typeDef, mapper) {
        typeDef.templateArguments = mapper === null || mapper === void 0 ? void 0 : mapper.args;
        if ("decorators" in typeDef) {
            for (const decApp of typeDef.decorators) {
                applyDecoratorToType(decApp, typeDef);
            }
        }
        Object.setPrototypeOf(typeDef, typePrototype);
        return typeDef;
    }
    function applyDecoratorToType(decApp, target) {
        var _a;
        compilerAssert("decorators" in target, "Cannot apply decorator to non-decoratable type", target);
        for (const arg of decApp.args) {
            if (typeof arg.value === "object") {
                if (isErrorType(arg.value)) {
                    // If one of the decorator argument is an error don't run it.
                    return;
                }
            }
        }
        // peel `fn` off to avoid setting `this`.
        try {
            const fn = decApp.decorator;
            const context = createDecoratorContext(program, decApp);
            fn(context, target, ...decApp.args.map((x) => x.value));
        }
        catch (error) {
            // do not fail the language server for exceptions in decorators
            if (program.compilerOptions.designTimeBuild) {
                program.reportDiagnostic(createDiagnostic({
                    code: "decorator-fail",
                    format: { decoratorName: decApp.decorator.name, error: error.stack },
                    target: (_a = decApp.node) !== null && _a !== void 0 ? _a : target,
                }));
            }
            else {
                throw error;
            }
        }
    }
    function createDecoratorContext(program, decApp) {
        function createPassThruContext(program, decApp) {
            return {
                program,
                decoratorTarget: decApp.node,
                getArgumentTarget: () => decApp.node,
                call: (decorator, target, ...args) => {
                    return decorator(createPassThruContext(program, decApp), target, ...args);
                },
            };
        }
        return {
            program,
            decoratorTarget: decApp.node,
            getArgumentTarget: (index) => {
                var _a;
                return (_a = decApp.args[index]) === null || _a === void 0 ? void 0 : _a.node;
            },
            call: (decorator, target, ...args) => {
                return decorator(createPassThruContext(program, decApp), target, ...args);
            },
        };
    }
    function getLiteralType(node) {
        return createLiteralType(node.value);
    }
    function mergeSymbolTable(source, target) {
        for (const [sym, duplicates] of source.duplicates) {
            const targetSet = target.duplicates.get(sym);
            if (targetSet === undefined) {
                target.duplicates.set(sym, new Set([...duplicates]));
            }
            else {
                for (const duplicate of duplicates) {
                    targetSet.add(duplicate);
                }
            }
        }
        for (const [key, sourceBinding] of source) {
            if (sourceBinding.flags & 2048 /* SymbolFlags.Namespace */) {
                // we are merging a namespace symbol. See if is an existing namespace symbol
                // to merge with.
                let existingBinding = target.get(key);
                if (!existingBinding) {
                    existingBinding = {
                        ...sourceBinding,
                    };
                    target.set(key, existingBinding);
                    mergedSymbols.set(sourceBinding, existingBinding);
                }
                else if (existingBinding.flags & 2048 /* SymbolFlags.Namespace */) {
                    existingBinding.declarations.push(...sourceBinding.declarations);
                    mergedSymbols.set(sourceBinding, existingBinding);
                    mergeSymbolTable(sourceBinding.exports, existingBinding.exports);
                }
                else {
                    // this will set a duplicate error
                    target.set(key, sourceBinding);
                }
            }
            else {
                target.set(key, sourceBinding);
            }
        }
    }
    function getMergedSymbol(sym) {
        if (!sym)
            return sym;
        return mergedSymbols.get(sym) || sym;
    }
    function createGlobalNamespaceNode() {
        const nsId = {
            kind: SyntaxKind.Identifier,
            pos: 0,
            end: 0,
            sv: "__GLOBAL_NS",
            symbol: undefined,
            flags: 8 /* NodeFlags.Synthetic */,
        };
        const nsNode = {
            kind: SyntaxKind.NamespaceStatement,
            decorators: [],
            pos: 0,
            end: 0,
            id: nsId,
            symbol: undefined,
            locals: createSymbolTable(),
            flags: 8 /* NodeFlags.Synthetic */,
        };
        nsNode.symbol = createSymbol(nsNode, "__GLOBAL_NS", 2048 /* SymbolFlags.Namespace */);
        return nsNode;
    }
    function createGlobalNamespaceType() {
        return createAndFinishType({
            kind: "Namespace",
            name: "",
            node: globalNamespaceNode,
            models: new Map(),
            operations: new Map(),
            namespaces: new Map(),
            interfaces: new Map(),
            unions: new Map(),
            enums: new Map(),
            decorators: [],
        });
    }
    /**
     * Clone a type, resulting in an identical type with all the same decorators
     * applied. Decorators are re-run on the clone to achieve this.
     *
     * Care is taken to clone nested data structures that are part of the type.
     * Any type with e.g. a map or an array property must recreate the map or array
     * so that clones don't share the same object.
     *
     * For types which have sub-types that are part of it, e.g. enums with members,
     * unions with variants, or models with properties, the sub-types are cloned
     * as well.
     *
     * If the entire type graph needs to be cloned, then cloneType must be called
     * recursively by the caller.
     */
    function cloneType(type, additionalProps = {}) {
        // Create a new decorator list with the same decorators so that edits to the
        // new decorators list doesn't affect the cloned type
        const decorators = "decorators" in type ? [...type.decorators] : undefined;
        // TODO: this needs to handle other types
        let clone;
        switch (type.kind) {
            case "Model":
                clone = finishType({
                    ...type,
                    decorators,
                    properties: Object.prototype.hasOwnProperty.call(additionalProps, "properties")
                        ? undefined
                        : new Map(Array.from(type.properties.entries()).map(([key, prop]) => [key, cloneType(prop)])),
                    ...additionalProps,
                });
                break;
            case "Union":
                clone = finishType({
                    ...type,
                    decorators,
                    variants: new Map(Array.from(type.variants.entries()).map(([key, prop]) => [
                        key,
                        prop.kind === "UnionVariant" ? cloneType(prop) : prop,
                    ])),
                    get options() {
                        return Array.from(this.variants.values()).map((v) => v.type);
                    },
                    ...additionalProps,
                });
                break;
            case "Interface":
                clone = finishType({
                    ...type,
                    decorators,
                    operations: new Map(type.operations.entries()),
                    ...additionalProps,
                });
                break;
            case "Enum":
                clone = finishType({
                    ...type,
                    decorators,
                    members: type.members.map((v) => cloneType(v)),
                    ...additionalProps,
                });
                break;
            default:
                clone = finishType({
                    ...type,
                    ...(decorators ? { decorators } : {}),
                    ...additionalProps,
                });
        }
        const projection = projectionsByType.get(type);
        if (projection) {
            projectionsByType.set(clone, projection);
        }
        return clone;
    }
    function checkProjectionDeclaration(node) {
        // todo: check for duplicate projection decls on individual types
        // right now you can declare the same projection on a specific type
        // this could maybe go in the binder? But right now we don't know
        // what an identifier resolves to until check time.
        const links = getSymbolLinks(node.symbol);
        if (processedProjections.has(node)) {
            return links.declaredType;
        }
        processedProjections.add(node);
        program.reportDiagnostic(createDiagnostic({ code: "projections-are-experimental", target: node }));
        let type;
        if (links.declaredType) {
            type = links.declaredType;
        }
        else {
            type = links.declaredType = createType({
                kind: "Projection",
                node: undefined,
                nodeByKind: new Map(),
                nodeByType: new Map(),
            });
        }
        switch (node.selector.kind) {
            case SyntaxKind.ProjectionModelSelector:
                projectionsByTypeKind.get("Model").push(node);
                type.nodeByKind.set("Model", node);
                break;
            case SyntaxKind.ProjectionOperationSelector:
                projectionsByTypeKind.get("Operation").push(node);
                type.nodeByKind.set("Operation", node);
                break;
            case SyntaxKind.ProjectionUnionSelector:
                projectionsByTypeKind.get("Union").push(node);
                type.nodeByKind.set("Union", node);
                break;
            case SyntaxKind.ProjectionInterfaceSelector:
                projectionsByTypeKind.get("Interface").push(node);
                type.nodeByKind.set("Interface", node);
                break;
            case SyntaxKind.ProjectionEnumSelector:
                projectionsByTypeKind.get("Enum").push(node);
                type.nodeByKind.set("Enum", node);
                break;
            default:
                const projected = checkTypeReference(node.selector, undefined);
                let current = projectionsByType.get(projected);
                if (!current) {
                    current = [];
                    projectionsByType.set(projected, current);
                }
                current.push(node);
                type.nodeByType.set(projected, node);
                break;
        }
        return type;
    }
    function evalProjectionNode(node) {
        switch (node.kind) {
            case SyntaxKind.ProjectionExpressionStatement:
                return evalProjectionExpressionStatement(node);
            case SyntaxKind.ProjectionCallExpression:
                return evalProjectionCallExpression(node);
            case SyntaxKind.ProjectionMemberExpression:
                return evalProjectionMemberExpression(node);
            case SyntaxKind.ProjectionDecoratorReferenceExpression:
                return evalProjectionDecoratorReference(node);
            case SyntaxKind.Identifier:
                return evalProjectionIdentifier(node);
            case SyntaxKind.ProjectionLambdaExpression:
                return evalProjectionLambdaExpression(node);
            case SyntaxKind.StringLiteral:
                return evalStringLiteral(node);
            case SyntaxKind.NumericLiteral:
                return evalNumericLiteral(node);
            case SyntaxKind.BooleanLiteral:
                return evalBooleanLiteral(node);
            case SyntaxKind.ProjectionBlockExpression:
                return evalProjectionBlockExpression(node);
            case SyntaxKind.ProjectionArithmeticExpression:
                return evalProjectionArithmeticExpression(node);
            case SyntaxKind.ProjectionIfExpression:
                return evalProjectionIfExpression(node);
            case SyntaxKind.ProjectionEqualityExpression:
                return evalProjectionEqualityExpression(node);
            case SyntaxKind.ProjectionUnaryExpression:
                return evalProjectionUnaryExpression(node);
            case SyntaxKind.ProjectionRelationalExpression:
                return evalProjectionRelationalExpression(node);
            case SyntaxKind.ProjectionModelExpression:
                return evalProjectionModelExpression(node);
            case SyntaxKind.VoidKeyword:
                return voidType;
            case SyntaxKind.NeverKeyword:
                return neverType;
            case SyntaxKind.UnknownKeyword:
                return unknownType;
            case SyntaxKind.Return:
                return evalReturnKeyword(node);
            default:
                compilerAssert(false, `Can't eval the node ${SyntaxKind[node.kind]}`);
        }
    }
    function evalReturnKeyword(node) {
        const value = evalProjectionNode(node.value);
        if (value.kind === "Return") {
            return value;
        }
        return {
            kind: "Return",
            value,
        };
    }
    function evalProjectionModelExpression(node) {
        const modelType = createType({
            kind: "Model",
            name: "",
            node: node,
            decorators: [],
            properties: new Map(),
            derivedModels: [],
        });
        for (const propNode of node.properties) {
            if (propNode.kind === SyntaxKind.ProjectionModelProperty) {
                const prop = evalProjectionModelProperty(propNode, modelType);
                if (prop.kind === "Return") {
                    return prop;
                }
                modelType.properties.set(prop.name, prop);
            }
            else {
                const props = evalProjectionModelSpreadProperty(propNode);
                if (!Array.isArray(props)) {
                    // return record
                    return props;
                }
                for (const newProp of props) {
                    modelType.properties.set(newProp.name, newProp);
                }
            }
        }
        return modelType;
    }
    function evalProjectionModelProperty(node, model) {
        const type = evalProjectionNode(node.value);
        if (type.kind === "Return") {
            return type;
        }
        return createType({
            kind: "ModelProperty",
            name: node.id.kind === SyntaxKind.Identifier ? node.id.sv : node.id.value,
            node: node,
            decorators: [],
            optional: node.optional,
            type,
            model,
        });
    }
    function evalProjectionModelSpreadProperty(node) {
        const target = evalProjectionNode(node.target);
        if (target.kind === "Return") {
            return target;
        }
        if (target.kind !== "Model") {
            throw new ProjectionError(`Can only spread models`);
        }
        const props = [];
        // copy each property
        for (const prop of walkPropertiesInherited(target)) {
            const newProp = cloneType(prop, { sourceProperty: prop });
            props.push(newProp);
        }
        return props;
    }
    function evalProjectionRelationalExpression(node) {
        const left = evalProjectionNode(node.left);
        if (left.kind === "Return") {
            return left;
        }
        else if (left.kind !== "Number" && left.kind !== "String") {
            throw new ProjectionError("Can only compare numbers or strings");
        }
        const right = evalProjectionNode(node.right);
        if (right.kind === "Return") {
            return right;
        }
        else if (right.kind !== "Number" && right.kind !== "String") {
            throw new ProjectionError("Can only compare numbers or strings");
        }
        if (left.kind !== right.kind) {
            throw new ProjectionError("Can't compare numbers and strings");
        }
        switch (node.op) {
            case "<":
                return createLiteralType(left.value < right.value);
            case "<=":
                return createLiteralType(left.value <= right.value);
            case ">":
                return createLiteralType(left.value > right.value);
            case ">=":
                return createLiteralType(left.value >= right.value);
        }
    }
    function evalProjectionUnaryExpression(node) {
        const target = evalProjectionNode(node.target);
        if (target.kind !== "Boolean") {
            throw new ProjectionError("Can't negate a non-boolean");
        }
        switch (node.op) {
            case "!":
                return createLiteralType(!target.value);
        }
    }
    function evalProjectionEqualityExpression(node) {
        const left = evalProjectionNode(node.left);
        if (left.kind === "Return") {
            return left;
        }
        else if (left.kind !== "Number" && left.kind !== "String") {
            throw new ProjectionError("Comparisons must be strings or numbers");
        }
        const right = evalProjectionNode(node.right);
        if (right.kind === "Return") {
            return right;
        }
        else if (right.kind !== "Number" && right.kind !== "String") {
            throw new ProjectionError("Comparisons must be strings or numbers");
        }
        if (right.kind !== left.kind) {
            throw new ProjectionError("Can't compare number and string");
        }
        switch (node.op) {
            case "==":
                return createLiteralType(left.value === right.value);
            case "!=":
                return createLiteralType(left.value !== right.value);
        }
    }
    function evalProjectionIfExpression(node) {
        let ifExpr = node;
        while (ifExpr) {
            const test = evalProjectionNode(ifExpr.test);
            if (test.kind === "Return") {
                return test;
            }
            if (typeIsTruthy(test)) {
                return evalProjectionBlockExpression(ifExpr.consequent);
            }
            else if (ifExpr.alternate &&
                ifExpr.alternate.kind === SyntaxKind.ProjectionBlockExpression) {
                return evalProjectionBlockExpression(ifExpr.alternate);
            }
            else {
                ifExpr = ifExpr.alternate;
            }
        }
        return voidType;
    }
    function typeIsTruthy(t) {
        switch (t.kind) {
            case "Boolean":
                return t.value;
            case "Number":
                return !!t.value;
            case "String":
                return !!t.value;
            default:
                return true;
        }
    }
    function createEvalContext(node, parent) {
        return {
            node,
            locals: new Map(),
            parent,
        };
    }
    function evalProjectionBlockExpression(node) {
        let lastVal = voidType;
        for (const stmt of node.statements) {
            const stmtValue = evalProjectionNode(stmt);
            if (stmtValue.kind === "Return") {
                return stmtValue;
            }
            lastVal = stmtValue;
        }
        return lastVal;
    }
    function evalProjectionArithmeticExpression(node) {
        const lhs = evalProjectionNode(node.left);
        if (lhs.kind === "Return") {
            return lhs;
        }
        if (lhs.kind !== "Number" && lhs.kind !== "String") {
            throw new ProjectionError(`Operator ${node.op} can only apply to strings or numbers`);
        }
        const rhs = evalProjectionNode(node.right);
        if (rhs.kind === "Return") {
            return rhs;
        }
        if (rhs.kind !== "Number" && rhs.kind !== "String") {
            throw new ProjectionError(`Operator ${node.op} can only apply to strings or numbers`);
        }
        if (rhs.kind !== lhs.kind) {
            throw new ProjectionError(`Operator ${node.op}'s operands need to be the same type`);
        }
        if (lhs.kind === "String") {
            return createLiteralType(lhs.value + rhs.value);
        }
        else {
            return createLiteralType(lhs.value + rhs.value);
        }
    }
    function evalProjectionStatement(node, target, args) {
        let topLevelProjection = false;
        if (!currentProjectionDirection) {
            topLevelProjection = true;
            currentProjectionDirection = node.direction;
        }
        if (currentProjectionDirection === "from" && !target.projectionSource) {
            // this model wasn't projected, so we'll just return the target
            return target;
        }
        const originalContext = evalContext;
        evalContext = createEvalContext(node);
        for (const [i, param] of node.parameters.entries()) {
            if (!args[i]) {
                throw new ProjectionError("need argument for parameter " + SyntaxKind[node.parameters[i].kind]);
            }
            const argVal = args[i];
            let typeVal;
            if (typeof argVal === "number" || typeof argVal === "string" || typeof argVal === "boolean") {
                typeVal = createLiteralType(argVal);
            }
            else {
                typeVal = argVal;
            }
            evalContext.locals.set(param.id.sv, typeVal);
        }
        evalContext.locals.set("self", target);
        let lastVal = voidType;
        for (const item of node.body) {
            lastVal = evalProjectionNode(item);
            if (lastVal.kind === "Return") {
                break;
            }
        }
        if (topLevelProjection) {
            currentProjectionDirection = undefined;
        }
        const selfResult = evalContext.locals.get("self");
        evalContext = originalContext;
        if (lastVal.kind === "Return") {
            return lastVal.value;
        }
        else {
            return selfResult;
        }
    }
    function evalProjectionExpressionStatement(node) {
        return evalProjectionNode(node.expr);
    }
    function evalProjectionCallExpression(node) {
        const target = evalProjectionNode(node.target);
        if (!target)
            throw new ProjectionError("target undefined");
        const args = [];
        for (const arg of node.arguments) {
            args.push(evalProjectionNode(arg));
        }
        if (target.kind !== "Function") {
            throw new ProjectionError("Can't call non-function, got type " + target.kind);
        }
        return target.call(...args);
    }
    function evalProjectionMemberExpression(node) {
        const base = evalProjectionNode(node.base);
        if (base.kind === "Return") {
            return base;
        }
        const member = node.id.sv;
        const selector = node.selector;
        if (selector === ".") {
            switch (base.kind) {
                case "Namespace":
                    const sym = base.node.symbol.exports.get(member);
                    if (sym) {
                        const links = getSymbolLinks(sym);
                        return links.declaredType || links.type || errorType;
                    }
                    else {
                        throw new ProjectionError(`Namespace doesn't have member ${member}`);
                    }
                case "Model":
                    const prop = base.properties.get(member);
                    if (!prop) {
                        throw new ProjectionError(`Model doesn't have property ${member}`);
                    }
                    return prop;
                case "Enum":
                    const enumMember = base.members.find((v) => v.name === member);
                    if (!enumMember) {
                        throw new ProjectionError(`Enum doesn't have member ${member}`);
                    }
                    return enumMember;
                case "Union":
                    const variant = base.variants.get(member);
                    if (!variant) {
                        throw new ProjectionError(`Union doesn't have variant ${member}`);
                    }
                    return variant;
                default:
                    throw new ProjectionError(`Can't get member "${member}" of type ${base.kind} because it has no members. Did you mean to use "::" instead of "."?`);
            }
        }
        switch (base.kind) {
            case "Object":
                return base.properties[member] || errorType;
            default:
                const typeOps = projectionMembers[base.kind];
                if (!typeOps) {
                    throw new ProjectionError(`${base.kind} doesn't have an object model member named ${member}`);
                }
                // any cast needed to ensure we don't get a too complex union error on the call
                // to op further down.
                const op = typeOps[member];
                if (!op) {
                    throw new ProjectionError(`${base.kind} doesn't have an object model member named ${member}`);
                }
                return op(base);
        }
    }
    function createFunctionType(fn) {
        return createType({
            kind: "Function",
            call: fn,
        });
    }
    function literalTypeToValue(type) {
        return type.value;
    }
    function createLiteralType(value, node) {
        if (program.literalTypes.has(value)) {
            return program.literalTypes.get(value);
        }
        let type;
        switch (typeof value) {
            case "string":
                type = createType({ kind: "String", value });
                break;
            case "boolean":
                type = createType({ kind: "Boolean", value });
                break;
            case "number":
                type = createType({
                    kind: "Number",
                    value,
                });
                break;
        }
        program.literalTypes.set(value, type);
        return type;
    }
    function evalProjectionDecoratorReference(node) {
        const ref = resolveTypeReference(node.target, undefined, true);
        if (!ref)
            throw new ProjectionError("Can't find decorator.");
        compilerAssert(ref.flags & 8192 /* SymbolFlags.Decorator */, "should only resolve decorator symbols");
        return createType({
            kind: "Function",
            call(...args) {
                ref.value({ program }, ...marshalProjectionArguments(args));
                return voidType;
            },
        });
    }
    function evalProjectionIdentifier(node) {
        // first check the eval context
        let currentContext = evalContext;
        while (currentContext) {
            if (currentContext.locals.has(node.sv)) {
                return currentContext.locals.get(node.sv);
            }
            currentContext = currentContext.parent;
        }
        // next, resolve outside
        const ref = resolveTypeReference(node, undefined);
        if (!ref)
            throw new ProjectionError("Unknown identifier " + node.sv);
        if (ref.flags & 8192 /* SymbolFlags.Decorator */) {
            // shouldn't ever resolve a decorator symbol here (without passing
            // true to resolveTypeReference)
            return errorType;
        }
        else if (ref.flags & 65536 /* SymbolFlags.Function */) {
            // TODO: store this in a symbol link probably?
            const t = createType({
                kind: "Function",
                call(...args) {
                    const retval = ref.value(program, ...marshalProjectionArguments(args));
                    return marshalProjectionReturn(retval);
                },
            });
            return t;
        }
        else {
            const links = getSymbolLinks(ref);
            compilerAssert(links.declaredType, "Should have checked all types by now");
            return links.declaredType;
        }
    }
    function marshalProjectionArguments(args) {
        return args.map((arg) => {
            if (arg.kind === "Boolean" || arg.kind === "String" || arg.kind === "Number") {
                return literalTypeToValue(arg);
            }
            return arg;
        });
    }
    function marshalProjectionReturn(value) {
        if (typeof value === "boolean" || typeof value === "string" || typeof value === "number") {
            return createLiteralType(value);
        }
        if (typeof value === "object" && value !== null) {
            if ("kind" in value) {
                return value;
            }
            else {
                // this could probably be more robust
                return createType({
                    kind: "Object",
                    properties: value,
                });
            }
        }
        throw new ProjectionError("Can't marshal value returned from JS function into cadl");
    }
    function evalProjectionLambdaExpression(node) {
        const type = createType({
            kind: "Function",
            call(...args) {
                return callLambdaExpression(node, args);
            },
        });
        return type;
    }
    function callLambdaExpression(node, args) {
        const originalContext = evalContext;
        evalContext = createEvalContext(node, originalContext);
        for (const [i, param] of node.parameters.entries()) {
            evalContext.locals.set(param.id.sv, args[i]);
        }
        const retval = evalProjectionBlockExpression(node.body);
        evalContext = originalContext;
        if (retval.kind === "Return") {
            return retval.value;
        }
        return retval;
    }
    function evalStringLiteral(node) {
        return createLiteralType(node.value);
    }
    function evalNumericLiteral(node) {
        return createLiteralType(node.value);
    }
    function evalBooleanLiteral(node) {
        return createLiteralType(node.value);
    }
    function project(target, projection, args = []) {
        return evalProjectionStatement(projection, target, args.map(marshalProjectionReturn));
    }
    function memberExpressionToString(expr) {
        let current = expr;
        const parts = [];
        while (current.kind === SyntaxKind.MemberExpression) {
            parts.push(current.id.sv);
            current = current.base;
        }
        parts.push(current.sv);
        return parts.reverse().join(".");
    }
    /**
     * Check if the source type can be assigned to the target type and emit diagnostics
     * @param source Source type
     * @param target Target type
     * @param diagnosticTarget Target for the diagnostic, unless something better can be inffered.
     */
    function checkTypeAssignable(source, target, diagnosticTarget) {
        const [related, diagnostics] = isTypeAssignableTo(source, target, diagnosticTarget);
        if (!related) {
            program.reportDiagnostics(diagnostics);
        }
        return related;
    }
    /**
     * Check if the source type can be assigned to the target type.
     * @param source Source type
     * @param target Target type
     * @param diagnosticTarget Target for the diagnostic, unless something better can be inffered.
     */
    function isTypeAssignableTo(source, target, diagnosticTarget) {
        var _a;
        if (source === target)
            return [true, []];
        if (source.kind === "TemplateParameter") {
            source = (_a = source.constraint) !== null && _a !== void 0 ? _a : unknownType;
        }
        const isSimpleTypeRelated = isSimpleTypeAssignableTo(source, target);
        if (isSimpleTypeRelated === true) {
            return [true, []];
        }
        else if (isSimpleTypeRelated === false) {
            return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
        if (target.kind === "Model" && target.indexer !== undefined && source.kind === "Model") {
            return isIndexerValid(source, target, diagnosticTarget);
        }
        else if (target.kind === "Model" && source.kind === "Model") {
            return isModelRelatedTo(source, target, diagnosticTarget);
        }
        else if (target.kind === "Model" && target.indexer && source.kind === "Tuple") {
            for (const item of source.values) {
                const [related, diagnostics] = isTypeAssignableTo(item, target.indexer.value, diagnosticTarget);
                if (!related) {
                    return [false, diagnostics];
                }
            }
            return [true, []];
        }
        else if (target.kind === "Tuple" && source.kind === "Tuple") {
            return isTupleAssignableToTuple(source, target, diagnosticTarget);
        }
        else if (target.kind === "Union") {
            return isAssignableToUnion(source, target, diagnosticTarget);
        }
        else if (target.kind === "Enum") {
            return isAssignableToEnum(source, target, diagnosticTarget);
        }
        return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
    }
    function isSimpleTypeAssignableTo(source, target) {
        if (isVoidType(target) || isNeverType(target))
            return false;
        if (isUnknownType(target))
            return true;
        const sourceIntrinsicName = getIntrinsicModelName(program, source);
        const targetIntrinsicName = getIntrinsicModelName(program, target);
        if (targetIntrinsicName) {
            switch (source.kind) {
                case "Number":
                    return (IntrinsicTypeRelations.isAssignable(targetIntrinsicName, "numeric") &&
                        isNumericLiteralRelatedTo(source, targetIntrinsicName));
                case "String":
                    return IntrinsicTypeRelations.isAssignable("string", targetIntrinsicName);
                case "Boolean":
                    return IntrinsicTypeRelations.isAssignable("boolean", targetIntrinsicName);
                case "Model":
                    if (!sourceIntrinsicName) {
                        return false;
                    }
            }
            if (!sourceIntrinsicName) {
                return false;
            }
            return IntrinsicTypeRelations.isAssignable(sourceIntrinsicName, targetIntrinsicName);
        }
        if (sourceIntrinsicName && target.kind === "Model") {
            return false;
        }
        if (target.kind === "String") {
            return source.kind === "String" && target.value === source.value;
        }
        if (target.kind === "Number") {
            return source.kind === "Number" && target.value === source.value;
        }
        return undefined;
    }
    function isNumericLiteralRelatedTo(source, targetInstrinsicType) {
        if (targetInstrinsicType === "numeric")
            return true;
        const isInt = Number.isInteger(source.value);
        if (targetInstrinsicType === "integer")
            return isInt;
        if (targetInstrinsicType === "float")
            return true;
        const [low, high, options] = numericRanges[targetInstrinsicType];
        return source.value >= low && source.value <= high && (!options.int || isInt);
    }
    function isModelRelatedTo(source, target, diagnosticTarget) {
        const diagnostics = [];
        for (const prop of walkPropertiesInherited(target)) {
            const sourceProperty = getProperty(source, prop.name);
            if (sourceProperty === undefined) {
                if (!prop.optional) {
                    diagnostics.push(createDiagnostic({
                        code: "missing-property",
                        format: {
                            propertyName: prop.name,
                            sourceType: getTypeName(source),
                            targetType: getTypeName(target),
                        },
                        target: source,
                    }));
                }
            }
            else {
                const [related, propDiagnostics] = isTypeAssignableTo(sourceProperty.type, prop.type, diagnosticTarget);
                if (!related) {
                    diagnostics.push(...propDiagnostics);
                }
            }
        }
        return [diagnostics.length === 0, diagnostics];
    }
    function getProperty(model, name) {
        var _a;
        return ((_a = model.properties.get(name)) !== null && _a !== void 0 ? _a : (model.baseModel !== undefined ? getProperty(model.baseModel, name) : undefined));
    }
    function isIndexerValid(source, target, diagnosticTarget) {
        if (isNeverIndexer(target.indexer)) {
            // TODO better error here saying that you cannot assign to
            return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
        // Model expressions should be able to be assigned.
        if (source.name === "") {
            return isIndexConstraintValid(target.indexer.value, source, diagnosticTarget);
        }
        else {
            if (source.indexer === undefined || source.indexer.key !== target.indexer.key) {
                return [
                    false,
                    [
                        createDiagnostic({
                            code: "missing-index",
                            format: {
                                indexType: getTypeName(target.indexer.key),
                                sourceType: getTypeName(source),
                            },
                            target,
                        }),
                    ],
                ];
            }
            return isTypeAssignableTo(source.indexer.value, target.indexer.value, diagnosticTarget);
        }
    }
    /**
     * @param constraintType Type of the constraints(All properties must have this type).
     * @param type Type of the model that should be respecting the constraint.
     * @param diagnosticTarget Diagnostic target unless something better can be inffered.
     */
    function isIndexConstraintValid(constraintType, type, diagnosticTarget) {
        for (const prop of type.properties.values()) {
            const [related, diagnostics] = isTypeAssignableTo(prop.type, constraintType, diagnosticTarget);
            if (!related) {
                return [false, diagnostics];
            }
        }
        if (type.baseModel) {
            const [related, diagnostics] = isIndexConstraintValid(constraintType, type.baseModel, diagnosticTarget);
            if (!related) {
                return [false, diagnostics];
            }
        }
        return [true, []];
    }
    function isTupleAssignableToTuple(source, target, diagnosticTarget) {
        if (source.values.length !== target.values.length) {
            return [
                false,
                [
                    createDiagnostic({
                        code: "unassignable",
                        messageId: "withDetails",
                        format: {
                            sourceType: getTypeName(source),
                            targetType: getTypeName(target),
                            details: `Source has ${source.values.length} element(s) but target requires ${target.values.length}.`,
                        },
                        target: diagnosticTarget,
                    }),
                ],
            ];
        }
        for (const [index, sourceItem] of source.values.entries()) {
            const targetItem = target.values[index];
            const [related, diagnostics] = isTypeAssignableTo(sourceItem, targetItem, diagnosticTarget);
            if (!related) {
                return [false, diagnostics];
            }
        }
        return [true, []];
    }
    function isAssignableToUnion(source, target, diagnosticTarget) {
        for (const option of target.options) {
            const [related] = isTypeAssignableTo(source, option, diagnosticTarget);
            if (related) {
                return [true, []];
            }
        }
        return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
    }
    function isAssignableToEnum(source, target, diagnosticTarget) {
        switch (source.kind) {
            case "Enum":
                if (source === target) {
                    return [true, []];
                }
                else {
                    return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
                }
            case "EnumMember":
                if (source.enum === target) {
                    return [true, []];
                }
                else {
                    return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
                }
            default:
                return [false, [createUnassignableDiagnostic(source, target, diagnosticTarget)]];
        }
    }
    function createUnassignableDiagnostic(source, target, diagnosticTarget) {
        return createDiagnostic({
            code: "unassignable",
            format: { targetType: getTypeName(target), value: getTypeName(source) },
            target: diagnosticTarget,
        });
    }
    function isStdType(type, stdType) {
        if (type.kind !== "Model")
            return false;
        const intrinsicModelName = getIntrinsicModelName(program, type);
        if (intrinsicModelName)
            return stdType === undefined || stdType === intrinsicModelName;
        if (stdType === "Array" && type === stdTypes["Array"])
            return true;
        if (stdType === "Record" && type === stdTypes["Record"])
            return true;
        return false;
    }
    function getProjectedEffectiveModelType(type) {
        if (!program.currentProjector) {
            return type;
        }
        const projectedType = program.currentProjector.projectType(type);
        if (projectedType.kind !== "Model") {
            compilerAssert(false, "Fail");
        }
        return projectedType;
    }
    function getEffectiveModelType(model, filter) {
        if (filter) {
            model = filterModelProperties(model, filter);
        }
        if (model.name) {
            // named model
            return getProjectedEffectiveModelType(model);
        }
        // We would need to change the algorithm if this doesn't hold. We
        // assume model has no inherited properties below.
        compilerAssert(!model.baseModel, "Anonymous model with base model.");
        if (model.properties.size === 0) {
            // empty model
            return model;
        }
        // Find the candidate set of named model types that could have been the
        // source of every property in the model.
        let candidates;
        for (const property of model.properties.values()) {
            const sources = getNamedSourceModels(property);
            if (!sources) {
                // unsourced property: no possible match
                return model;
            }
            if (!candidates) {
                // first sourced property: initialize candidates to its sources
                candidates = sources;
                continue;
            }
            // Add any derived types we observe to both sides. A derived type can
            // substitute for a base type in these sets because derived types have
            // all the properties of their bases.
            //
            // NOTE: Once property overrides are allowed, this code will need to
            // be updated to check that the current property is not overridden by
            // the derived type before adding it here. An override would invalidate
            // this substitution.
            addDerivedModels(sources, candidates);
            addDerivedModels(candidates, sources);
            // remove candidates that are not common to this property
            for (const element of candidates) {
                if (!sources.has(element)) {
                    candidates.delete(element);
                }
            }
        }
        // Search for a candidate that has no additional properties (ignoring
        // filtered properties). If so, it is effectively the same type as the
        // input model. Consider a candidate that meets this test without
        // ignoring filtering as a better match than one that requires filtering
        // to meet this test.
        let match;
        for (const candidate of candidates !== null && candidates !== void 0 ? candidates : []) {
            if (model.properties.size === countPropertiesInherited(candidate)) {
                match = candidate;
                break; // exact match
            }
            if (filter &&
                !match &&
                model.properties.size === countPropertiesInherited(candidate, filter)) {
                match = candidate;
                continue; // match with filter: keep searching for exact match
            }
        }
        return match ? getProjectedEffectiveModelType(match) : model;
    }
    function filterModelProperties(model, filter) {
        let filtered = false;
        for (const property of walkPropertiesInherited(model)) {
            if (!filter(property)) {
                filtered = true;
                break;
            }
        }
        if (!filtered) {
            return model;
        }
        const properties = new Map();
        const newModel = createType({
            kind: "Model",
            node: undefined,
            name: "",
            indexer: undefined,
            properties,
            decorators: [],
            derivedModels: [],
        });
        for (const property of walkPropertiesInherited(model)) {
            if (filter(property)) {
                const newProperty = cloneType(property, {
                    sourceProperty: property,
                    model: newModel,
                });
                properties.set(property.name, newProperty);
            }
        }
        return finishType(newModel);
    }
}
function isAnonymous(type) {
    return !("name" in type) || typeof type.name !== "string" || !type.name;
}
function isErrorType(type) {
    return type.kind === "Intrinsic" && type.name === "ErrorType";
}
function createUsingSymbol(symbolSource) {
    return { flags: 262144 /* SymbolFlags.Using */, declarations: [], name: symbolSource.name, symbolSource };
}
const numericRanges = {
    int64: [BigInt("-9223372036854775807"), BigInt("9223372036854775808"), { int: true }],
    int32: [-2147483648, 2147483647, { int: true }],
    int16: [-32768, 32767, { int: true }],
    int8: [-128, 127, { int: true }],
    uint64: [0, BigInt("18446744073709551615"), { int: true }],
    uint32: [0, 4294967295, { int: true }],
    uint16: [0, 65535, { int: true }],
    uint8: [0, 255, { int: true }],
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, { int: true }],
    float32: [-3.4e38, 3.4e38, { int: false }],
    float64: [Number.MIN_VALUE, Number.MAX_VALUE, { int: false }],
};
class IntrinsicTypeRelationTree {
    constructor(data) {
        this.map = new Map();
        for (const [key, value] of Object.entries(data)) {
            if (value === undefined) {
                continue;
            }
            const parents = Array.isArray(value) ? value : [value];
            const set = new Set([
                key,
                ...parents,
                ...parents.flatMap((parent) => { var _a; return [...((_a = this.map.get(parent)) !== null && _a !== void 0 ? _a : [])]; }),
            ]);
            this.map.set(key, set);
        }
    }
    isAssignable(source, target) {
        var _a;
        return (_a = this.map.get(source)) === null || _a === void 0 ? void 0 : _a.has(target);
    }
}
const IntrinsicTypeRelations = new IntrinsicTypeRelationTree({
    Record: "unknown",
    bytes: "unknown",
    numeric: "unknown",
    integer: "numeric",
    float: "numeric",
    int64: "integer",
    safeint: "int64",
    int32: "safeint",
    int16: "int32",
    int8: "int16",
    uint64: "integer",
    uint32: "uint64",
    uint16: "uint32",
    uint8: "uint16",
    float64: "float",
    float32: "float64",
    string: "unknown",
    plainDate: "unknown",
    plainTime: "unknown",
    zonedDateTime: "unknown",
    duration: "unknown",
    boolean: "unknown",
    null: "unknown",
    Map: "unknown",
});
/**
 * Find all named models that could have been the source of the given
 * property. This includes the named parents of all property sources in a
 * chain.
 */
function getNamedSourceModels(property) {
    var _a;
    if (!property.sourceProperty) {
        return undefined;
    }
    const set = new Set();
    for (let p = property; p; p = p.sourceProperty) {
        if ((_a = p.model) === null || _a === void 0 ? void 0 : _a.name) {
            set.add(p.model);
        }
    }
    return set;
}
/**
 * Find derived types of `models` in `possiblyDerivedModels` and add them to
 * `models`.
 */
function addDerivedModels(models, possiblyDerivedModels) {
    for (const element of possiblyDerivedModels) {
        if (!models.has(element)) {
            for (let t = element.baseModel; t; t = t.baseModel) {
                if (models.has(t)) {
                    models.add(element);
                    break;
                }
            }
        }
    }
}
function isNeverIndexer(indexer) {
    return isNeverType(indexer.key);
}
function createTypeMapper(parameters, args) {
    const map = new Map();
    for (const [index, param] of parameters.entries()) {
        map.set(param, args[index]);
    }
    return {
        args,
        getMappedType: (type) => {
            var _a;
            return (_a = map.get(type)) !== null && _a !== void 0 ? _a : type;
        },
    };
}

class ResolveModuleError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
    }
}
const defaultDirectoryIndexFiles = ["index.mjs", "index.js"];
/**
 * Resolve a module
 * @param host
 * @param name
 * @param options
 * @returns
 */
async function resolveModule(host, name, options) {
    const realpath = async (x) => resolvePath(await host.realpath(x));
    const { baseDir } = options;
    const absoluteStart = baseDir === "" ? "." : await realpath(resolvePath(baseDir));
    if (!(await isDirectory(host, absoluteStart))) {
        throw new TypeError(`Provided basedir '${baseDir}'is not a directory.`);
    }
    // Check if the module name is referencing a path(./foo, /foo, file:/foo)
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(name)) {
        const res = resolvePath(absoluteStart, name);
        const m = (await loadAsFile(res)) || (await loadAsDirectory(res));
        if (m)
            return realpath(m);
    }
    const module = await findAsNodeModule(name, absoluteStart);
    if (module)
        return realpath(module);
    throw new ResolveModuleError("MODULE_NOT_FOUND", `Cannot find module '${name}' from '${baseDir}'`);
    /**
     * Returns a list of all the parent directory and the given one.
     */
    function listAllParentDirs(baseDir) {
        const paths = [baseDir];
        let current = getDirectoryPath(baseDir);
        while (current !== paths[paths.length - 1]) {
            paths.push(current);
            current = getDirectoryPath(current);
        }
        return paths;
    }
    function getPackageCandidates(name, baseDir) {
        const dirs = listAllParentDirs(baseDir);
        return dirs.flatMap((x) => [
            { path: x, type: "self" },
            { path: joinPaths(x, "node_modules", name), type: "node_modules" },
        ]);
    }
    async function findAsNodeModule(name, baseDir) {
        const dirs = getPackageCandidates(name, baseDir);
        for (const { type, path } of dirs) {
            if (type === "node_modules") {
                if (await isDirectory(host, path)) {
                    const n = await loadAsDirectory(path);
                    if (n)
                        return n;
                }
            }
            else if (type === "self") {
                const pkgFile = resolvePath(path, "package.json");
                if (await isFile(host, pkgFile)) {
                    const pkg = await readPackage(host, pkgFile);
                    if (pkg.name === name) {
                        const n = await loadPackage(path, pkg);
                        if (n)
                            return n;
                    }
                }
            }
        }
        return undefined;
    }
    async function loadAsDirectory(directory) {
        var _a;
        const pkgFile = resolvePath(directory, "package.json");
        if (await isFile(host, pkgFile)) {
            const pkg = await readPackage(host, pkgFile);
            return loadPackage(directory, pkg);
        }
        for (const file of (_a = options.directoryIndexFiles) !== null && _a !== void 0 ? _a : defaultDirectoryIndexFiles) {
            const resolvedFile = await loadAsFile(joinPaths(directory, file));
            if (resolvedFile) {
                return resolvedFile;
            }
        }
        return undefined;
    }
    async function loadPackage(directory, pkg) {
        var _a;
        const mainFile = options.resolveMain ? options.resolveMain(pkg) : pkg.main;
        if (typeof mainFile !== "string") {
            throw new TypeError(`package "${pkg.name}" main must be a string but was '${mainFile}'`);
        }
        const mainFullPath = resolvePath(directory, mainFile);
        let loaded;
        try {
            loaded = (_a = (await loadAsFile(mainFullPath))) !== null && _a !== void 0 ? _a : (await loadAsDirectory(mainFullPath));
        }
        catch (e) {
            throw new Error(`Cannot find module '${mainFullPath}'. Please verify that the package.json has a valid "main" entry`);
        }
        if (loaded) {
            return loaded;
        }
        else {
            throw new ResolveModuleError("INVALID_MAIN", `Package ${pkg.name} main file "${mainFile}" is invalid.`);
        }
    }
    async function loadAsFile(file) {
        if (await isFile(host, file)) {
            return file;
        }
        const extensions = [".mjs", ".js"];
        for (const ext of extensions) {
            const fileWithExtension = file + ext;
            if (await isFile(host, fileWithExtension)) {
                return fileWithExtension;
            }
        }
        return undefined;
    }
}
async function readPackage(host, pkgfile) {
    const content = await host.readFile(pkgfile);
    return JSON.parse(content);
}
async function isDirectory(host, path) {
    try {
        const stats = await host.stat(path);
        return stats.isDirectory();
    }
    catch (e) {
        if (e.code === "ENOENT" || e.code === "ENOTDIR") {
            return false;
        }
        throw e;
    }
}
async function isFile(host, path) {
    try {
        const stats = await host.stat(path);
        return stats.isFile();
    }
    catch (e) {
        if (e.code === "ENOENT" || e.code === "ENOTDIR") {
            return false;
        }
        throw e;
    }
}

/**
 * Creates a projector which returns a projected view of either the global namespace or the
 * start node provided. Projecting a type effectively clones every type referenced underneath
 * it. This is accomplished by doing a semantic walk of each type, cloning each type we find,
 * and running projection code on the clone.
 *
 * Projectors can run multiple projections at once. In such cases, each projection is run
 * on the same clone of the unprojected type. It is up to projections and the user to ensure
 * that projections which depend on a particular shape are run when that shape is present (or
 * else to ensure that their projections are tolerant to shape changes).
 *
 * The projector maintains its own state maps and sets. If a projection is active (i.e.
 * program.currentProjector is set), then the projector's state will be returned instead
 * of the program's state. This ensures that there is no overlap between projected and
 * unprojected state. It also means that you cannot get state for nodes that are not
 * part of the active projection.
 *
 * Note that decorators are run on namespaces prior to cloning any child types to align
 * with the checker semantics, while projections are run after everything under the namespace
 * is cloned. All other run decorators and projections after all child types are cloned and
 * have their decorators run.
 */
function createProjector(program, projections, startNode) {
    const projectedTypes = new Map();
    const checker = program.checker;
    const neverType = checker.neverType;
    const scope = [];
    const projector = {
        projectedTypes,
        projections,
        projectType,
    };
    const projectedNamespaces = [];
    let projectingNamespaces = false;
    program.currentProjector = projector;
    const targetGlobalNs = startNode
        ? startNode.projector
            ? startNode.projector.projectedGlobalNamespace
            : program.checker.getGlobalNamespaceType()
        : program.checker.getGlobalNamespaceType();
    projectingNamespaces = true;
    // project all the namespaces first
    projector.projectedGlobalNamespace = projectNamespace(targetGlobalNs);
    projectingNamespaces = false;
    // then project all the types
    for (const ns of projectedNamespaces) {
        projectNamespaceContents(ns);
    }
    projectType(targetGlobalNs);
    projector.projectedStartNode = startNode
        ? projectedTypes.get(startNode)
        : projector.projectedGlobalNamespace;
    return projector;
    function projectType(type) {
        if (projectedTypes.has(type)) {
            return projectedTypes.get(type);
        }
        scope.push(type);
        let projected;
        switch (type.kind) {
            case "Namespace":
                compilerAssert(projectingNamespaces, `Namespace ${type.name} should have already been projected.`);
                projected = projectNamespace(type, false);
                break;
            case "Model":
                projected = projectModel(type);
                break;
            case "ModelProperty":
                projected = projectModelProperty(type);
                break;
            case "Operation":
                projected = projectOperation(type);
                break;
            case "Interface":
                projected = projectInterface(type);
                break;
            case "Union":
                projected = projectUnion(type);
                break;
            case "UnionVariant":
                projected = projectUnionVariant(type);
                break;
            case "Tuple":
                projected = projectTuple(type);
                break;
            case "Enum":
                projected = projectEnum(type);
                break;
            case "EnumMember":
                projected = projectEnumMember(type);
                break;
            default:
                projected = type;
        }
        scope.pop();
        return projected;
    }
    function projectSubNamespaces(ns, projectedNs) {
        if (ns.namespaces.size === projectedNs.namespaces.size) {
            // Sub namespace should already have been projected.
            return;
        }
        for (const [key, childNs] of ns.namespaces) {
            const projected = projectNamespace(childNs);
            if (projected.kind === "Namespace") {
                // todo: check for never?
                projectedNs.namespaces.set(key, projected);
            }
        }
    }
    function projectNamespace(ns, projectSubNamespace = true) {
        const alreadyProjected = projectedTypes.get(ns);
        if (alreadyProjected) {
            if (projectSubNamespace) {
                projectSubNamespaces(ns, alreadyProjected);
            }
            return alreadyProjected;
        }
        const childNamespaces = new Map();
        const childModels = new Map();
        const childOperations = new Map();
        const childInterfaces = new Map();
        const childUnions = new Map();
        const childEnums = new Map();
        const projectedNs = shallowClone(ns, {
            namespaces: childNamespaces,
            models: childModels,
            operations: childOperations,
            interfaces: childInterfaces,
            unions: childUnions,
            enums: childEnums,
            decorators: [],
        });
        projectedNs.decorators = projectDecorators(ns.decorators);
        if (ns.namespace) {
            projectedNs.namespace = projectNamespace(ns.namespace, false);
        }
        // ns run decorators before projecting anything inside them
        checker.finishType(projectedNs);
        if (projectSubNamespace) {
            projectSubNamespaces(ns, projectedNs);
        }
        projectedNamespaces.push(ns);
        return applyProjection(ns, projectedNs);
    }
    /**
     * Projects the contents of a namespace, but not the namespace itself. The namespace itself
     * is projected in an earlier phase.
     */
    function projectNamespaceContents(ns) {
        const projectedNs = projectedTypes.get(ns);
        compilerAssert(projectedNs, "Should have projected namespace by now");
        if (projectedNs.kind !== "Namespace") {
            // we projected the namespace to something else so don't do any more work.
            // this might happen if a namespace itself was added/removed/etc. and is
            // projected to never.
            return neverType;
        }
        for (const childModel of ns.models.values()) {
            const projected = projectType(childModel);
            if (projected.kind === "Model") {
                projectedNs.models.set(projected.name, projected);
            }
        }
        for (const childOperation of ns.operations.values()) {
            const projected = projectType(childOperation);
            if (projected.kind === "Operation") {
                projectedNs.operations.set(projected.name, projected);
            }
        }
        for (const childInterface of ns.interfaces.values()) {
            const projected = projectType(childInterface);
            if (projected.kind === "Interface") {
                projectedNs.interfaces.set(projected.name, projected);
            }
        }
        for (const childUnion of ns.unions.values()) {
            const projected = projectType(childUnion);
            if (projected.kind === "Union") {
                projectedNs.unions.set(projected.name, projected);
            }
        }
        for (const childEnum of ns.enums.values()) {
            const projected = projectType(childEnum);
            if (projected.kind === "Enum") {
                projectedNs.enums.set(projected.name, projected);
            }
        }
        return projectedNs;
    }
    function projectModel(model) {
        var _a;
        var _b;
        const properties = new Map();
        let templateArguments;
        const projectedModel = shallowClone(model, {
            properties,
            derivedModels: [],
        });
        if (model.templateArguments !== undefined) {
            templateArguments = [];
            for (const arg of model.templateArguments) {
                templateArguments.push(projectType(arg));
            }
        }
        if (model.baseModel) {
            projectedModel.baseModel = projectType(model.baseModel);
        }
        if (model.indexer) {
            if (isNeverIndexer(model.indexer)) {
                projectedModel.indexer = { key: neverType, value: undefined };
            }
            else {
                projectedModel.indexer = {
                    key: projectModel(model.indexer.key),
                    value: projectType(model.indexer.value),
                };
            }
        }
        projectedTypes.set(model, projectedModel);
        for (const [key, prop] of model.properties) {
            const projectedProp = projectType(prop);
            if (projectedProp.kind === "ModelProperty") {
                properties.set(key, projectedProp);
            }
        }
        projectedModel.decorators = projectDecorators(model.decorators);
        if (shouldFinishType(model)) {
            checker.finishType(projectedModel);
        }
        projectedModel.templateArguments = templateArguments;
        const projectedResult = applyProjection(model, projectedModel);
        if (!isNeverType(projectedResult) &&
            projectedResult.kind === "Model" &&
            projectedResult.baseModel) {
            (_a = (_b = projectedResult.baseModel).derivedModels) !== null && _a !== void 0 ? _a : (_b.derivedModels = []);
            projectedResult.baseModel.derivedModels.push(projectedModel);
        }
        return projectedResult;
    }
    /**
     * Returns true if we should finish a type. The only time we don't finish is when it's
     * a template type, because we don't want to run decorators for templates.
     */
    function shouldFinishType(type) {
        var _a, _b;
        if (((_a = type.node) === null || _a === void 0 ? void 0 : _a.kind) !== SyntaxKind.ModelStatement &&
            ((_b = type.node) === null || _b === void 0 ? void 0 : _b.kind) !== SyntaxKind.InterfaceStatement) {
            return true;
        }
        return !isTemplateDeclaration(type);
    }
    function projectModelProperty(prop) {
        const projectedType = projectType(prop.type);
        const projectedDecs = projectDecorators(prop.decorators);
        const projectedProp = shallowClone(prop, {
            type: projectedType,
            decorators: projectedDecs,
        });
        checker.finishType(projectedProp);
        return projectedProp;
    }
    function projectOperation(op) {
        const parameters = projectType(op.parameters);
        const returnType = projectType(op.returnType);
        const decorators = projectDecorators(op.decorators);
        const projectedOp = shallowClone(op, {
            decorators,
            parameters,
            returnType,
        });
        if (op.interface) {
            projectedOp.interface = projectedInterfaceScope();
        }
        else if (op.namespace) {
            projectedOp.namespace = projectedNamespaceScope();
        }
        checker.finishType(projectedOp);
        return applyProjection(op, projectedOp);
    }
    function projectInterface(iface) {
        const operations = new Map();
        const decorators = projectDecorators(iface.decorators);
        const projectedIface = shallowClone(iface, {
            decorators,
            operations,
        });
        for (const op of iface.operations.values()) {
            const projectedOp = projectType(op);
            if (projectedOp.kind === "Operation") {
                operations.set(projectedOp.name, projectedOp);
            }
        }
        if (shouldFinishType(iface)) {
            checker.finishType(projectedIface);
        }
        return applyProjection(iface, projectedIface);
    }
    function projectUnion(union) {
        const variants = new Map();
        const decorators = projectDecorators(union.decorators);
        const projectedUnion = shallowClone(union, {
            decorators,
            variants,
        });
        for (const [key, variant] of union.variants) {
            const projectedVariant = projectType(variant);
            if (projectedVariant.kind === "UnionVariant" && projectedVariant.type !== neverType) {
                variants.set(key, projectedVariant);
            }
        }
        if (shouldFinishType(union)) {
            checker.finishType(projectedUnion);
        }
        return applyProjection(union, projectedUnion);
    }
    function projectUnionVariant(variant) {
        const projectedType = projectType(variant.type);
        const projectedDecs = projectDecorators(variant.decorators);
        const projectedVariant = shallowClone(variant, {
            type: projectedType,
            decorators: projectedDecs,
        });
        checker.finishType(projectedVariant);
        return projectedVariant;
    }
    function projectTuple(tuple) {
        const values = [];
        const projectedTuple = shallowClone(tuple, {
            values,
        });
        for (const item of tuple.values) {
            values.push(projectType(item));
        }
        return projectedTuple;
    }
    function projectEnum(e) {
        const members = [];
        const decorators = projectDecorators(e.decorators);
        const projectedEnum = shallowClone(e, {
            members,
            decorators,
        });
        projectedTypes.set(e, projectedEnum);
        for (const member of e.members) {
            const projectedMember = projectType(member);
            if (projectedMember.kind === "EnumMember") {
                members.push(projectedMember);
            }
        }
        checker.finishType(projectedEnum);
        return applyProjection(e, projectedEnum);
    }
    function projectEnumMember(e) {
        const decorators = projectDecorators(e.decorators);
        const projectedMember = shallowClone(e, {
            decorators,
        });
        const parentEnum = projectType(e.enum);
        projectedMember.enum = parentEnum;
        checker.finishType(projectedMember);
        return projectedMember;
    }
    function projectDecorators(decs) {
        const decorators = [];
        for (const dec of decs) {
            const args = [];
            for (const arg of dec.args) {
                // filter out primitive arguments
                if (typeof arg.value !== "object") {
                    args.push(arg);
                    continue;
                }
                const projected = projectType(arg.value);
                args.push({ ...arg, value: projected });
            }
            decorators.push({ ...dec, args });
        }
        return decorators;
    }
    function getInScopeProjections() {
        const candidates = new Set(projections);
        const inScope = [];
        let currentScope = namespaceScope();
        outer: while (currentScope) {
            for (const candidate of candidates) {
                if (!candidate.scope || candidate.scope === currentScope) {
                    candidates.delete(candidate);
                    inScope.push(candidate);
                    if (candidates.size === 0) {
                        break outer;
                    }
                }
            }
            currentScope = currentScope.namespace;
        }
        return inScope;
    }
    function namespaceScope() {
        for (let i = scope.length - 1; i >= 0; i--) {
            if (scope[i].namespace !== undefined) {
                return scope[i].namespace;
            }
        }
        return undefined;
    }
    function projectedNamespaceScope() {
        const ns = namespaceScope();
        if (!ns)
            return ns;
        return projectType(ns);
    }
    function interfaceScope() {
        for (let i = scope.length - 1; i >= 0; i--) {
            if ("interface" in scope[i]) {
                return scope[i].interface;
            }
        }
        return undefined;
    }
    function projectedInterfaceScope() {
        const iface = interfaceScope();
        if (!iface)
            return iface;
        if (!projectedTypes.has(iface)) {
            throw new Error("Interface should have been projected already");
        }
        return projectType(iface);
    }
    function applyProjection(baseType, projectedType) {
        const inScopeProjections = getInScopeProjections();
        for (const projectionApplication of inScopeProjections) {
            const projectionsByName = baseType.projectionsByName(projectionApplication.projectionName);
            if (projectionsByName.length === 0)
                continue;
            const targetNode = projectionApplication.direction === "from"
                ? projectionsByName[0].from
                : projectionsByName[0].to;
            const projected = checker.project(projectedType, targetNode, projectionApplication.arguments);
            if (projected !== projectedType) {
                // override the projected type cache with the returned type
                projectedTypes.set(baseType, projected);
                return projected;
            }
        }
        return projectedType;
    }
    function shallowClone(type, additionalProps) {
        var _a;
        const scopeProps = {};
        if ("namespace" in type && type.namespace !== undefined) {
            scopeProps.namespace = projectedNamespaceScope();
        }
        if ("interface" in type && type.interface !== undefined) {
            scopeProps.interface = projectedInterfaceScope();
        }
        const clone = checker.createType({
            ...type,
            ...additionalProps,
            ...scopeProps,
            projectionSource: type,
            projectionBase: (_a = type.projectionBase) !== null && _a !== void 0 ? _a : type,
            projector,
        });
        if (type.kind === "Union") {
            // create the options getter
            Object.defineProperty(clone, "options", {
                get() {
                    return Array.from(this.variants.values()).map((v) => v.type);
                },
            });
        }
        projectedTypes.set(type, clone);
        return clone;
    }
}

var _a, _b;
class StateMap {
    constructor(program, key) {
        this.program = program;
        this.key = key;
        this.internalState = new Map();
        this[_a] = "StateMap";
    }
    has(t) {
        var _c, _d;
        return (_d = (_c = this.dispatch(t)) === null || _c === void 0 ? void 0 : _c.has(t)) !== null && _d !== void 0 ? _d : false;
    }
    set(t, v) {
        this.dispatch(t).set(t, v);
        return this;
    }
    get(t) {
        return this.dispatch(t).get(t);
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        this.dispatch().forEach(cb, thisArg);
        return this;
    }
    get size() {
        return this.dispatch().size;
    }
    clear() {
        return this.dispatch().clear();
    }
    entries() {
        return this.dispatch().entries();
    }
    values() {
        return this.dispatch().values();
    }
    keys() {
        return this.dispatch().keys();
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    dispatch(keyType) {
        const key = keyType ? keyType.projector : this.program.currentProjector;
        if (!this.internalState.has(key)) {
            this.internalState.set(key, new Map());
        }
        return this.internalState.get(key);
    }
}
_a = Symbol.toStringTag;
class StateSet {
    constructor(program, key) {
        this.program = program;
        this.key = key;
        this.internalState = new Map();
        this[_b] = "StateSet";
    }
    has(t) {
        var _c, _d;
        return (_d = (_c = this.dispatch(t)) === null || _c === void 0 ? void 0 : _c.has(t)) !== null && _d !== void 0 ? _d : false;
    }
    add(t) {
        this.dispatch(t).add(t);
        return this;
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        this.dispatch().forEach(cb, thisArg);
        return this;
    }
    get size() {
        return this.dispatch().size;
    }
    clear() {
        return this.dispatch().clear();
    }
    values() {
        return this.dispatch().values();
    }
    keys() {
        return this.dispatch().keys();
    }
    entries() {
        return this.dispatch().entries();
    }
    [Symbol.iterator]() {
        return this.values();
    }
    dispatch(keyType) {
        const key = keyType ? keyType.projector : this.program.currentProjector;
        if (!this.internalState.has(key)) {
            this.internalState.set(key, new Set());
        }
        return this.internalState.get(key);
    }
}
_b = Symbol.toStringTag;
async function createProgram(host, mainFile, options = {}) {
    const validateCbs = [];
    const stateMaps = new Map();
    const stateSets = new Map();
    const diagnostics = [];
    const seenSourceFiles = new Set();
    const duplicateSymbols = new Set();
    let currentProjector;
    const emitters = [];
    const requireImports = new Map();
    const libraryLoaded = new Set();
    let error = false;
    const logger = createLogger({ sink: host.logSink, level: options.diagnosticLevel });
    const program = {
        checker: undefined,
        compilerOptions: options,
        sourceFiles: new Map(),
        jsSourceFiles: new Map(),
        literalTypes: new Map(),
        host,
        diagnostics,
        logger,
        emitters,
        loadCadlScript,
        evalCadlScript,
        getOption,
        stateMap,
        stateMaps,
        stateSet,
        stateSets,
        reportDiagnostic,
        reportDiagnostics,
        reportDuplicateSymbols,
        hasError() {
            return error;
        },
        onValidate(cb) {
            validateCbs.push(cb);
        },
        enableProjections,
        disableProjections,
        get currentProjector() {
            return currentProjector;
        },
        set currentProjector(v) {
            currentProjector = v;
        },
    };
    let virtualFileCount = 0;
    const binder = createBinder(program);
    if (!(options === null || options === void 0 ? void 0 : options.nostdlib)) {
        await loadStandardLibrary();
    }
    const resolvedMain = await resolveCadlEntrypoint(mainFile);
    // Load additional imports prior to compilation
    if (resolvedMain && options.additionalImports) {
        const importScript = options.additionalImports.map((i) => `import "${i}";`).join("\n");
        const sourceFile = createSourceFile(importScript, joinPaths(getDirectoryPath(resolvedMain), `__additional_imports`));
        await loadCadlScript(sourceFile);
    }
    if (resolvedMain) {
        await loadMain(resolvedMain);
    }
    if (resolvedMain && options.emitters) {
        const emitters = computeEmitters(options.emitters);
        await loadEmitters(resolvedMain, emitters);
    }
    const checker = (program.checker = createChecker(program));
    program.checker.checkProgram();
    if (program.hasError()) {
        return program;
    }
    for (const cb of validateCbs) {
        try {
            await cb(program);
        }
        catch (error) {
            if (options.designTimeBuild) {
                program.reportDiagnostic(createDiagnostic({
                    code: "on-validate-fail",
                    format: { error: error.stack },
                    target: NoTarget,
                }));
            }
            else {
                throw error;
            }
        }
    }
    for (const [requiredImport, emitterName] of requireImports) {
        if (!libraryLoaded.has(requiredImport)) {
            program.reportDiagnostic(createDiagnostic({
                code: "missing-import",
                format: { requiredImport, emitterName },
                target: NoTarget,
            }));
        }
    }
    if (program.hasError()) {
        return program;
    }
    for (const instance of emitters) {
        await instance.emitter(program, instance.options);
    }
    return program;
    async function loadStandardLibrary(program) {
        for (const dir of host.getLibDirs()) {
            await loadDirectory(dir, NoTarget);
        }
    }
    async function loadDirectory(dir, diagnosticTarget) {
        const mainFile = await resolveCadlEntrypointForDir(dir);
        await loadCadlFile(mainFile, diagnosticTarget);
        return mainFile;
    }
    async function loadCadlFile(path, diagnosticTarget) {
        if (seenSourceFiles.has(path)) {
            return;
        }
        seenSourceFiles.add(path);
        const file = await doIO(host.readFile, path, program.reportDiagnostic, {
            diagnosticTarget,
        });
        if (file) {
            await loadCadlScript(file);
        }
    }
    async function loadJsFile(path, diagnosticTarget) {
        const sourceFile = program.jsSourceFiles.get(path);
        if (sourceFile !== undefined) {
            return sourceFile;
        }
        const file = createSourceFile("", path);
        const exports = await doIO(host.getJsImport, path, program.reportDiagnostic, {
            diagnosticTarget,
            jsDiagnosticTarget: { file, pos: 0, end: 0 },
        });
        if (!exports) {
            return undefined;
        }
        return {
            kind: SyntaxKind.JsSourceFile,
            id: {
                kind: SyntaxKind.Identifier,
                sv: "",
                pos: 0,
                end: 0,
                symbol: undefined,
                flags: 8 /* NodeFlags.Synthetic */,
            },
            esmExports: exports,
            file,
            namespaceSymbols: [],
            symbol: undefined,
            pos: 0,
            end: 0,
            flags: 0 /* NodeFlags.None */,
        };
    }
    /**
     * Import the Javascript files decorator and lifecycle hooks.
     */
    async function importJsFile(path, diagnosticTarget) {
        const file = await loadJsFile(path, diagnosticTarget);
        if (file !== undefined) {
            program.jsSourceFiles.set(path, file);
            if (file.symbol === undefined) {
                binder.bindJsSourceFile(file);
            }
        }
    }
    async function loadCadlScript(cadlScript) {
        // This is not a diagnostic because the compiler should never reuse the same path.
        // It's the caller's responsibility to use unique paths.
        if (program.sourceFiles.has(cadlScript.path)) {
            throw new RangeError("Duplicate script path: " + cadlScript);
        }
        const sourceFile = parse$1(cadlScript);
        program.reportDiagnostics(sourceFile.parseDiagnostics);
        program.sourceFiles.set(cadlScript.path, sourceFile);
        binder.bindSourceFile(sourceFile);
        await loadScriptImports(sourceFile);
        return sourceFile;
    }
    function loadCadlScriptSync(cadlScript) {
        // This is not a diagnostic because the compiler should never reuse the same path.
        // It's the caller's responsibility to use unique paths.
        if (program.sourceFiles.has(cadlScript.path)) {
            throw new RangeError("Duplicate script path: " + cadlScript);
        }
        const sourceFile = parse$1(cadlScript);
        program.reportDiagnostics(sourceFile.parseDiagnostics);
        program.sourceFiles.set(cadlScript.path, sourceFile);
        for (const stmt of sourceFile.statements) {
            if (stmt.kind !== SyntaxKind.ImportStatement)
                break;
            program.reportDiagnostic(createDiagnostic({ code: "dynamic-import", target: stmt }));
        }
        binder.bindSourceFile(sourceFile);
        return sourceFile;
    }
    // Evaluates an arbitrary line of Cadl in the context of a
    // specified file path.  If no path is specified, use a
    // virtual file path
    function evalCadlScript(script) {
        const sourceFile = createSourceFile(script, `__virtual_file_${++virtualFileCount}`);
        const cadlScript = loadCadlScriptSync(sourceFile);
        checker.mergeSourceFile(cadlScript);
        checker.setUsingsForFile(cadlScript);
        for (const ns of cadlScript.namespaces) {
            const mergedSym = checker.getMergedSymbol(ns.symbol);
            reportDuplicateSymbols(mergedSym.exports);
        }
        reportDuplicateSymbols(checker.getGlobalNamespaceNode().symbol.exports);
    }
    async function loadScriptImports(file) {
        // collect imports
        const basedir = getDirectoryPath(file.file.path);
        await loadImports(file.statements.filter(isImportStatement).map((x) => ({ path: x.path.value, target: x })), basedir);
    }
    async function loadImports(imports, relativeTo) {
        // collect imports
        for (const { path, target } of imports) {
            await loadImport(path, target, relativeTo);
        }
    }
    async function loadImport(path, target, relativeTo) {
        const importFilePath = await resolveCadlLibrary(path, relativeTo, target);
        if (importFilePath) {
            libraryLoaded.add(path);
            logger.debug(`Loading library "${path}" from "${importFilePath}"`);
        }
        else {
            return;
        }
        const isDirectory = (await host.stat(importFilePath)).isDirectory();
        if (isDirectory) {
            return await loadDirectory(importFilePath, target);
        }
        const sourceFileKind = host.getSourceFileKind(importFilePath);
        switch (sourceFileKind) {
            case "js":
                return await importJsFile(importFilePath, target);
            case "cadl":
                return await loadCadlFile(importFilePath, target);
            default:
                program.reportDiagnostic(createDiagnostic({ code: "invalid-import", target }));
        }
    }
    async function loadEmitters(mainFile, emitters) {
        for (const [emitterPackage, options] of Object.entries(emitters)) {
            await loadEmitter(mainFile, emitterPackage, options);
        }
    }
    async function loadEmitter(mainFile, emitterPackage, options) {
        var _c, _d;
        const basedir = getDirectoryPath(mainFile);
        // attempt to resolve a node module with this name
        const module = await resolveJSLibrary(emitterPackage, basedir);
        if (!module) {
            return;
        }
        const file = await loadJsFile(module, NoTarget);
        if (file === undefined) {
            program.reportDiagnostic(createDiagnostic({
                code: "emitter-not-found",
                format: { emitterPackage },
                target: NoTarget,
            }));
            return;
        }
        const emitterFunction = file.esmExports.$onEmit;
        const libDefinition = file.esmExports.$lib;
        if (libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.requireImports) {
            for (const lib of libDefinition.requireImports) {
                requireImports.set(lib, libDefinition.name);
            }
        }
        if (emitterFunction !== undefined) {
            if ((_c = libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.emitter) === null || _c === void 0 ? void 0 : _c.options) {
                const optionValidator = new SchemaValidator((_d = libDefinition.emitter) === null || _d === void 0 ? void 0 : _d.options, {
                    coerceTypes: true,
                });
                const diagnostics = optionValidator.validate(options, NoTarget);
                if (diagnostics.length > 0) {
                    program.reportDiagnostics(diagnostics);
                    return;
                }
            }
            emitters.push({ emitter: emitterFunction, options });
        }
        else {
            program.reportDiagnostic(createDiagnostic({
                code: "emitter-not-found",
                format: { emitterPackage },
                target: NoTarget,
            }));
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/cadl/node_modules/myLib/main.cadl".
     */
    async function resolveCadlLibrary(specifier, baseDir, target) {
        try {
            return await resolveModule(getResolveModuleHost(), specifier, {
                baseDir,
                directoryIndexFiles: ["main.cadl", "index.mjs", "index.js"],
                resolveMain(pkg) {
                    var _c;
                    // this lets us follow node resolve semantics more-or-less exactly
                    // but using cadlMain instead of main.
                    return (_c = pkg.cadlMain) !== null && _c !== void 0 ? _c : pkg.main;
                },
            });
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                program.reportDiagnostic(createDiagnostic({ code: "import-not-found", format: { path: specifier }, target }));
                return undefined;
            }
            else if (e.code === "INVALID_MAIN") {
                program.reportDiagnostic(createDiagnostic({
                    code: "library-invalid",
                    format: { path: specifier },
                    messageId: "cadlMain",
                    target,
                }));
                return undefined;
            }
            else {
                throw e;
            }
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/cadl/node_modules/myLib/dist/lib.js".
     */
    async function resolveJSLibrary(specifier, baseDir) {
        try {
            return await resolveModule(getResolveModuleHost(), specifier, { baseDir });
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                program.reportDiagnostic(createDiagnostic({
                    code: "import-not-found",
                    format: { path: specifier },
                    target: NoTarget,
                }));
                return undefined;
            }
            else if (e.code === "INVALID_MAIN") {
                program.reportDiagnostic(createDiagnostic({
                    code: "library-invalid",
                    format: { path: specifier },
                    target: NoTarget,
                }));
                return undefined;
            }
            else {
                throw e;
            }
        }
    }
    function getResolveModuleHost() {
        return {
            realpath: host.realpath,
            stat: host.stat,
            readFile: async (path) => {
                const file = await host.readFile(path);
                return file.text;
            },
        };
    }
    /**
     * Resolve the path to the main file
     * @param path path to the entrypoint of the program. Can be the main.cadl, folder containg main.cadl or a project/library root.
     * @returns Absolute path to the entrypoint.
     */
    async function resolveCadlEntrypoint(path) {
        const resolvedPath = resolvePath(path);
        const mainStat = await doIO(host.stat, resolvedPath, program.reportDiagnostic);
        if (!mainStat) {
            return undefined;
        }
        if (mainStat.isDirectory()) {
            return resolveCadlEntrypointForDir(resolvedPath);
        }
        else {
            return resolvedPath;
        }
    }
    async function resolveCadlEntrypointForDir(dir) {
        const pkgJsonPath = resolvePath(dir, "package.json");
        const [pkg] = await loadFile(host, pkgJsonPath, JSON.parse, program.reportDiagnostic, {
            allowFileNotFound: true,
        });
        const mainFile = resolvePath(dir, typeof (pkg === null || pkg === void 0 ? void 0 : pkg.cadlMain) === "string" ? pkg.cadlMain : "main.cadl");
        return mainFile;
    }
    /**
     * Load the main file from the given path
     * @param mainPath Absolute path to the main file.
     * @param options Compiler options.
     * @returns
     */
    async function loadMain(mainPath, options) {
        if (!(await checkForCompilerVersionMismatch(mainPath))) {
            return;
        }
        const sourceFileKind = host.getSourceFileKind(mainPath);
        switch (sourceFileKind) {
            case "js":
                return await importJsFile(mainPath, NoTarget);
            case "cadl":
                return await loadCadlFile(mainPath, NoTarget);
            default:
                program.reportDiagnostic(createDiagnostic({ code: "invalid-main", target: NoTarget }));
        }
    }
    // It's important that we use the compiler version that resolves locally
    // from the input Cadl source location. Otherwise, there will be undefined
    // runtime behavior when decorators and handlers expect a
    // different version of cadl than the current one. Abort the compilation
    // with an error if the Cadl entry point resolves to a different local
    // compiler.
    async function checkForCompilerVersionMismatch(mainPath) {
        const baseDir = getDirectoryPath(mainPath);
        let actual;
        try {
            actual = await resolveModule({
                realpath: host.realpath,
                stat: host.stat,
                readFile: async (path) => {
                    const file = await host.readFile(path);
                    return file.text;
                },
            }, "@cadl-lang/compiler", { baseDir });
        }
        catch (err) {
            if (err.code === "MODULE_NOT_FOUND" || err.code === "INVALID_MAIN") {
                return true; // no local cadl, ok to use any compiler
            }
            throw err;
        }
        const expected = resolvePath(await host.realpath(host.fileURLToPath(import.meta.url)), "../index.js");
        if (actual !== expected) {
            // we have resolved node_modules/@cadl-lang/compiler/dist/core/index.js and we want to get
            // to the shim executable node_modules/.bin/cadl-server
            const betterCadlServerPath = resolvePath(actual, "../../../../../.bin/cadl-server");
            program.reportDiagnostic(createDiagnostic({
                code: "compiler-version-mismatch",
                format: { basedir: baseDir, betterCadlServerPath, actual, expected },
                target: NoTarget,
            }));
            return false;
        }
        return true;
    }
    function getOption(key) {
        return (options.miscOptions || {})[key];
    }
    function stateMap(key) {
        let m = stateMaps.get(key);
        if (!m) {
            m = new StateMap(program, key);
            stateMaps.set(key, m);
        }
        return m;
    }
    function stateSet(key) {
        let s = stateSets.get(key);
        if (!s) {
            s = new StateSet(program, key);
            stateSets.set(key, s);
        }
        return s;
    }
    function enableProjections(projections, startNode) {
        return createProjector(program, projections, startNode);
    }
    function disableProjections() {
        currentProjector = undefined;
    }
    function reportDiagnostic(diagnostic) {
        if (shouldSuppress(diagnostic)) {
            return;
        }
        if (options.warningAsError && diagnostic.severity === "warning") {
            diagnostic = { ...diagnostic, severity: "error" };
        }
        if (diagnostic.severity === "error") {
            error = true;
        }
        diagnostics.push(diagnostic);
    }
    function reportDiagnostics(newDiagnostics) {
        for (const diagnostic of newDiagnostics) {
            reportDiagnostic(diagnostic);
        }
    }
    function shouldSuppress(diagnostic) {
        const { target } = diagnostic;
        if (diagnostic.code === "error") {
            diagnostics.push(diagnostic);
            return false;
        }
        if (target === NoTarget || target === undefined) {
            return false;
        }
        if ("file" in target) {
            return false; // No global file suppress yet.
        }
        const node = getNode(target);
        if (node === undefined) {
            return false; // Can't find target cannot be suppressed.
        }
        const suppressing = findDirectiveSuppressingOnNode(diagnostic.code, node);
        if (suppressing) {
            if (diagnostic.severity === "error") {
                // Cannot suppress errors.
                diagnostics.push({
                    severity: "error",
                    code: "suppress-error",
                    message: "Errors cannot be suppressed.",
                    target: suppressing.node,
                });
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    }
    function findDirectiveSuppressingOnNode(code, node) {
        let current = node;
        do {
            if (current.directives) {
                const directive = findDirectiveSuppressingCode(code, current.directives);
                if (directive) {
                    return directive;
                }
            }
        } while ((current = current.parent));
        return undefined;
    }
    /**
     * Returns the directive node that is suppressing this code.
     * @param code Code to check for suppression.
     * @param directives List of directives.
     * @returns Directive suppressing this code if found, `undefined` otherwise
     */
    function findDirectiveSuppressingCode(code, directives) {
        for (const directive of directives.map((x) => parseDirective(x))) {
            if (directive.name === "suppress") {
                if (directive.code === code) {
                    return directive;
                }
            }
        }
        return undefined;
    }
    function parseDirective(node) {
        const args = node.arguments.map((x) => {
            return x.kind === SyntaxKind.Identifier ? x.sv : x.value;
        });
        switch (node.target.sv) {
            case "suppress":
                return { name: "suppress", code: args[0], message: args[1], node };
            default:
                throw new Error("Unexpected directive name.");
        }
    }
    function getNode(target) {
        if (!("kind" in target)) {
            // symbol
            if (target.flags & 262144 /* SymbolFlags.Using */) {
                return target.symbolSource.declarations[0];
            }
            return target.declarations[0]; // handle multiple decls
        }
        else if (typeof target.kind === "number") {
            // node
            return target;
        }
        else {
            // type
            return target.node;
        }
    }
    function reportDuplicateSymbols(symbols) {
        if (!symbols) {
            return;
        }
        for (const set of symbols.duplicates.values()) {
            for (const symbol of set) {
                if (!duplicateSymbols.has(symbol)) {
                    duplicateSymbols.add(symbol);
                    const name = symbol.flags & 262144 /* SymbolFlags.Using */ ? symbol.symbolSource.name : symbol.name;
                    reportDiagnostic(createDiagnostic({
                        code: "duplicate-symbol",
                        format: { name },
                        target: symbol,
                    }));
                }
            }
        }
    }
}
async function compile(mainFile, host, options) {
    return await createProgram(host, mainFile, options);
}
function computeEmitters(emitters) {
    const processedEmitters = {};
    for (const [emitter, options] of Object.entries(emitters)) {
        if (options === false) {
            continue;
        }
        processedEmitters[emitter] = options === true ? {} : options;
    }
    return processedEmitters;
}

var SemanticTokenKind;
(function (SemanticTokenKind) {
    SemanticTokenKind[SemanticTokenKind["Namespace"] = 0] = "Namespace";
    SemanticTokenKind[SemanticTokenKind["Type"] = 1] = "Type";
    SemanticTokenKind[SemanticTokenKind["Class"] = 2] = "Class";
    SemanticTokenKind[SemanticTokenKind["Enum"] = 3] = "Enum";
    SemanticTokenKind[SemanticTokenKind["Interface"] = 4] = "Interface";
    SemanticTokenKind[SemanticTokenKind["Struct"] = 5] = "Struct";
    SemanticTokenKind[SemanticTokenKind["TypeParameter"] = 6] = "TypeParameter";
    SemanticTokenKind[SemanticTokenKind["Parameter"] = 7] = "Parameter";
    SemanticTokenKind[SemanticTokenKind["Variable"] = 8] = "Variable";
    SemanticTokenKind[SemanticTokenKind["Property"] = 9] = "Property";
    SemanticTokenKind[SemanticTokenKind["EnumMember"] = 10] = "EnumMember";
    SemanticTokenKind[SemanticTokenKind["Event"] = 11] = "Event";
    SemanticTokenKind[SemanticTokenKind["Function"] = 12] = "Function";
    SemanticTokenKind[SemanticTokenKind["Method"] = 13] = "Method";
    SemanticTokenKind[SemanticTokenKind["Macro"] = 14] = "Macro";
    SemanticTokenKind[SemanticTokenKind["Keyword"] = 15] = "Keyword";
    SemanticTokenKind[SemanticTokenKind["Modifier"] = 16] = "Modifier";
    SemanticTokenKind[SemanticTokenKind["Comment"] = 17] = "Comment";
    SemanticTokenKind[SemanticTokenKind["String"] = 18] = "String";
    SemanticTokenKind[SemanticTokenKind["Number"] = 19] = "Number";
    SemanticTokenKind[SemanticTokenKind["Regexp"] = 20] = "Regexp";
    SemanticTokenKind[SemanticTokenKind["Operator"] = 21] = "Operator";
})(SemanticTokenKind || (SemanticTokenKind = {}));
const serverOptions = {
    noEmit: true,
    designTimeBuild: true,
};
const keywords = [
    // Root only
    ["import", { root: true }],
    // Root and namespace
    ["using", { root: true, namespace: true }],
    ["model", { root: true, namespace: true }],
    ["namespace", { root: true, namespace: true }],
    ["interface", { root: true, namespace: true }],
    ["union", { root: true, namespace: true }],
    ["enum", { root: true, namespace: true }],
    ["alias", { root: true, namespace: true }],
    ["op", { root: true, namespace: true }],
    // On model `model Foo <keyword> ...`
    ["extends", { model: true }],
    ["is", { model: true }],
    // On identifier`
    ["true", { identifier: true }],
    ["false", { identifier: true }],
];
function createServer(host) {
    // Remember original URL when we convert it to a local path so that we can
    // get it back. We can't convert it back because things like URL-encoding
    // could give us back an equivalent but non-identical URL but the original
    // URL is used as a key into the opened documents and so we must reproduce
    // it exactly.
    const pathToURLMap = new Map();
    // Cache all file I/O. Only open documents are sent over the LSP pipe. When
    // the compiler reads a file that isn't open, we use this cache to avoid
    // hitting the disk. Entries are invalidated when LSP client notifies us of
    // a file change.
    const fileSystemCache = createFileSystemCache();
    const compilerHost = createCompilerHost();
    let workspaceFolders = [];
    let isInitialized = false;
    let pendingMessages = [];
    return {
        get pendingMessages() {
            return pendingMessages;
        },
        get workspaceFolders() {
            return workspaceFolders;
        },
        initialize,
        initialized,
        workspaceFoldersChanged,
        watchedFilesChanged,
        gotoDefinition,
        documentClosed,
        complete,
        findReferences,
        prepareRename,
        rename,
        getSemanticTokens,
        buildSemanticTokens,
        checkChange,
        getFoldingRanges,
        getDocumentSymbols,
        log,
    };
    async function initialize(params) {
        var _a, _b;
        const tokenLegend = {
            tokenTypes: Object.keys(SemanticTokenKind)
                .filter((x) => Number.isNaN(Number(x)))
                .map((x) => x.slice(0, 1).toLocaleLowerCase() + x.slice(1)),
            tokenModifiers: [],
        };
        const capabilities = {
            textDocumentSync: node.exports.TextDocumentSyncKind.Incremental,
            definitionProvider: true,
            foldingRangeProvider: true,
            documentSymbolProvider: true,
            completionProvider: {
                resolveProvider: false,
                triggerCharacters: [".", "@", "/"],
                allCommitCharacters: [".", ",", ";", "("],
            },
            semanticTokensProvider: {
                full: true,
                legend: tokenLegend,
            },
            referencesProvider: true,
            renameProvider: {
                prepareProvider: true,
            },
        };
        if ((_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.workspaceFolders) {
            for (const w of (_b = params.workspaceFolders) !== null && _b !== void 0 ? _b : []) {
                workspaceFolders.push({
                    ...w,
                    path: ensureTrailingDirectorySeparator(await fileURLToRealPath(w.uri)),
                });
            }
            capabilities.workspace = {
                workspaceFolders: {
                    supported: true,
                    changeNotifications: true,
                },
            };
        }
        else if (params.rootUri) {
            workspaceFolders = [
                {
                    name: "<root>",
                    uri: params.rootUri,
                    path: ensureTrailingDirectorySeparator(await fileURLToRealPath(params.rootUri)),
                },
            ];
        }
        else if (params.rootPath) {
            workspaceFolders = [
                {
                    name: "<root>",
                    uri: compilerHost.pathToFileURL(params.rootPath),
                    path: ensureTrailingDirectorySeparator(await getNormalizedRealPath(compilerHost, params.rootPath)),
                },
            ];
        }
        log("Workspace Folders", workspaceFolders);
        return { capabilities };
    }
    function initialized(params) {
        isInitialized = true;
        log("Initialization complete.");
    }
    async function workspaceFoldersChanged(e) {
        log("Workspace Folders Changed", e);
        const map = new Map(workspaceFolders.map((f) => [f.uri, f]));
        for (const folder of e.removed) {
            map.delete(folder.uri);
        }
        for (const folder of e.added) {
            map.set(folder.uri, {
                ...folder,
                path: ensureTrailingDirectorySeparator(await fileURLToRealPath(folder.uri)),
            });
        }
        workspaceFolders = Array.from(map.values());
        log("Workspace Folders", workspaceFolders);
    }
    function watchedFilesChanged(params) {
        fileSystemCache.notify(params.changes);
    }
    async function compile(document, callback) {
        const path = await getPath(document);
        const mainFile = await getMainFileForDocument(path);
        const config = await loadCadlConfigForPath(compilerHost, mainFile);
        const options = {
            ...serverOptions,
            emitters: config.emitters,
        };
        if (!upToDate(document)) {
            return undefined;
        }
        let program;
        try {
            program = await createProgram(compilerHost, mainFile, options);
            if (!upToDate(document)) {
                return undefined;
            }
            if (mainFile !== path && !program.sourceFiles.has(path)) {
                // If the file that changed wasn't imported by anything from the main
                // file, retry using the file itself as the main file.
                program = await createProgram(compilerHost, path, options);
            }
            if (!upToDate(document)) {
                return undefined;
            }
            if (callback) {
                const doc = "version" in document ? document : host.getOpenDocumentByURL(document.uri);
                compilerAssert(doc, "Failed to get document.");
                const path = await getPath(doc);
                const script = program.sourceFiles.get(path);
                compilerAssert(script, "Failed to get script.");
                return await callback(program, doc, script);
            }
            return program;
        }
        catch (err) {
            host.sendDiagnostics({
                uri: document.uri,
                diagnostics: [
                    {
                        severity: node.exports.DiagnosticSeverity.Error,
                        range: node.exports.Range.create(0, 0, 0, 0),
                        message: `Internal compiler error!\nFile issue at https://github.com/microsoft/cadl\n\n` +
                            err.stack,
                    },
                ],
            });
            return undefined;
        }
    }
    async function getFoldingRanges(params) {
        const file = await compilerHost.readFile(await getPath(params.textDocument));
        const ast = parse$1(file, { comments: true });
        const ranges = [];
        let rangeStartSingleLines = -1;
        for (let i = 0; i < ast.comments.length; i++) {
            const comment = ast.comments[i];
            if (comment.kind === SyntaxKind.LineComment &&
                i + 1 < ast.comments.length &&
                ast.comments[i + 1].kind === SyntaxKind.LineComment &&
                ast.comments[i + 1].pos === skipWhiteSpace(file.text, comment.end)) {
                if (rangeStartSingleLines === -1) {
                    rangeStartSingleLines = comment.pos;
                }
            }
            else if (rangeStartSingleLines !== -1) {
                addRange(rangeStartSingleLines, comment.end);
                rangeStartSingleLines = -1;
            }
            else {
                addRange(comment.pos, comment.end);
            }
        }
        visitChildren(ast, addRangesForNode);
        function addRangesForNode(node) {
            let nodeStart = node.pos;
            if ("decorators" in node && node.decorators.length > 0) {
                const decoratorEnd = node.decorators[node.decorators.length - 1].end;
                addRange(nodeStart, decoratorEnd);
                nodeStart = skipTrivia(file.text, decoratorEnd);
            }
            addRange(nodeStart, node.end);
            visitChildren(node, addRangesForNode);
        }
        return ranges;
        function addRange(startPos, endPos) {
            const start = file.getLineAndCharacterOfPosition(startPos);
            const end = file.getLineAndCharacterOfPosition(endPos);
            if (start.line !== end.line) {
                ranges.push({
                    startLine: start.line,
                    startCharacter: start.character,
                    endLine: end.line,
                    endCharacter: end.character,
                });
            }
        }
    }
    function getSymbolNameAndKind(node$1) {
        switch (node$1.kind) {
            case SyntaxKind.NamespaceStatement:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Namespace };
            case SyntaxKind.CadlScript:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.File };
            case SyntaxKind.EnumStatement:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Enum };
            case SyntaxKind.InterfaceStatement:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Interface };
            case SyntaxKind.OperationStatement:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Function };
            case SyntaxKind.ModelStatement:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Struct };
            case SyntaxKind.ModelProperty:
                if (node$1.id.kind === SyntaxKind.StringLiteral) {
                    return { name: node$1.id.value, kind: node.exports.SymbolKind.Struct };
                }
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Struct };
            case SyntaxKind.UnionStatement:
                return { name: node$1.id.sv, kind: node.exports.SymbolKind.Enum };
            default:
                return undefined;
        }
    }
    async function getDocumentSymbols(params) {
        const file = await compilerHost.readFile(await getPath(params.textDocument));
        const ast = parse$1(file);
        const symbols = [];
        visitChildren(ast, addSymbolsForNode);
        function addSymbolsForNode(node$1) {
            const symbolNode = getSymbolNameAndKind(node$1);
            if (symbolNode !== undefined) {
                const start = file.getLineAndCharacterOfPosition(node$1.pos);
                const end = file.getLineAndCharacterOfPosition(node$1.end);
                symbols.push({
                    name: symbolNode.name,
                    kind: symbolNode.kind,
                    location: node.exports.Location.create(params.textDocument.uri, node.exports.Range.create(start, end)),
                });
            }
            visitChildren(node$1, addSymbolsForNode);
        }
        return symbols;
    }
    async function checkChange(change) {
        var _a, _b, _c;
        const program = await compile(change.document);
        if (!program) {
            return;
        }
        // Group diagnostics by file.
        //
        // Initialize diagnostics for all source files in program to empty array
        // as we must send an empty array when a file has no diagnostics or else
        // stale diagnostics from a previous run will stick around in the IDE.
        //
        const diagnosticMap = new Map();
        diagnosticMap.set(change.document, []);
        for (const each of program.sourceFiles.values()) {
            const document = (_a = each.file) === null || _a === void 0 ? void 0 : _a.document;
            if (document) {
                diagnosticMap.set(document, []);
            }
        }
        for (const each of program.diagnostics) {
            let document;
            const location = getSourceLocation(each.target);
            if (location === null || location === void 0 ? void 0 : location.file) {
                document = location.file.document;
            }
            else {
                // https://github.com/Microsoft/language-server-protocol/issues/256
                //
                // LSP does not currently allow sending a diagnostic with no location so
                // we report diagnostics with no location on the document that changed to
                // trigger.
                document = change.document;
            }
            if (!document || !upToDate(document)) {
                continue;
            }
            const start = document.positionAt((_b = location === null || location === void 0 ? void 0 : location.pos) !== null && _b !== void 0 ? _b : 0);
            const end = document.positionAt((_c = location === null || location === void 0 ? void 0 : location.end) !== null && _c !== void 0 ? _c : 0);
            const range = node.exports.Range.create(start, end);
            const severity = convertSeverity(each.severity);
            const diagnostic = node.exports.Diagnostic.create(range, each.message, severity, each.code, "Cadl");
            if (each.code === "deprecated") {
                diagnostic.tags = [node.exports.DiagnosticTag.Deprecated];
            }
            const diagnostics = diagnosticMap.get(document);
            compilerAssert(diagnostics, "Diagnostic reported against a source file that was not added to the program.");
            diagnostics.push(diagnostic);
        }
        for (const [document, diagnostics] of diagnosticMap) {
            sendDiagnostics(document, diagnostics);
        }
    }
    async function gotoDefinition(params) {
        const sym = await compile(params.textDocument, (program, document, file) => {
            const id = getNodeAtPosition(file, document.offsetAt(params.position));
            return (id === null || id === void 0 ? void 0 : id.kind) == SyntaxKind.Identifier ? program.checker.resolveIdentifier(id) : undefined;
        });
        return getLocations(sym === null || sym === void 0 ? void 0 : sym.declarations);
    }
    async function complete(params) {
        const completions = {
            isIncomplete: false,
            items: [],
        };
        await compile(params.textDocument, async (program, document, file) => {
            const node = getNodeAtPosition(file, document.offsetAt(params.position));
            if (node === undefined) {
                addKeywordCompletion("root", completions);
            }
            else {
                switch (node.kind) {
                    case SyntaxKind.NamespaceStatement:
                        addKeywordCompletion("namespace", completions);
                        break;
                    case SyntaxKind.Identifier:
                        addIdentifierCompletion(program, node, completions);
                        break;
                    case SyntaxKind.StringLiteral:
                        if (node.parent && node.parent.kind === SyntaxKind.ImportStatement) {
                            await addImportCompletion(program, document, completions, node);
                        }
                        break;
                }
            }
        });
        return completions;
    }
    async function findReferences(params) {
        const identifiers = await compile(params.textDocument, (program, document, file) => findReferenceIdentifiers(program, file, document.offsetAt(params.position)));
        return getLocations(identifiers);
    }
    async function prepareRename(params) {
        return await compile(params.textDocument, (_, document, file) => {
            var _a;
            const id = getNodeAtPosition(file, document.offsetAt(params.position));
            return (id === null || id === void 0 ? void 0 : id.kind) === SyntaxKind.Identifier ? (_a = getLocation(id)) === null || _a === void 0 ? void 0 : _a.range : undefined;
        });
    }
    async function rename(params) {
        const changes = {};
        await compile(params.textDocument, (program, document, file) => {
            const identifiers = findReferenceIdentifiers(program, file, document.offsetAt(params.position));
            for (const id of identifiers) {
                const location = getLocation(id);
                if (!location) {
                    continue;
                }
                const change = node.exports.TextEdit.replace(location.range, params.newName);
                if (location.uri in changes) {
                    changes[location.uri].push(change);
                }
                else {
                    changes[location.uri] = [change];
                }
            }
        });
        return { changes };
    }
    function findReferenceIdentifiers(program, file, pos) {
        var _a;
        const id = getNodeAtPosition(file, pos);
        if ((id === null || id === void 0 ? void 0 : id.kind) !== SyntaxKind.Identifier) {
            return [];
        }
        const sym = program.checker.resolveIdentifier(id);
        if (!sym) {
            return [id];
        }
        const references = [];
        for (const script of (_a = program.sourceFiles.values()) !== null && _a !== void 0 ? _a : []) {
            visitChildren(script, function visit(node) {
                if (node.kind === SyntaxKind.Identifier) {
                    const s = program.checker.resolveIdentifier(node);
                    if (s === sym || (sym.type && (s === null || s === void 0 ? void 0 : s.type) === sym.type)) {
                        references.push(node);
                    }
                }
                visitChildren(node, visit);
            });
        }
        return references;
    }
    function addKeywordCompletion(area, completions) {
        const filteredKeywords = keywords.filter(([_, x]) => area in x);
        for (const [keyword] of filteredKeywords) {
            completions.items.push({
                label: keyword,
                kind: node.exports.CompletionItemKind.Keyword,
            });
        }
    }
    async function addLibraryImportCompletion(program, document, completions) {
        const documentPath = await getPath(document);
        const projectRoot = await findProjectRoot(compilerHost, documentPath);
        if (projectRoot != undefined) {
            const [packagejson] = await loadFile(compilerHost, resolvePath(projectRoot, "package.json"), JSON.parse, program.reportDiagnostic);
            let dependencies = [];
            if (packagejson.dependencies != undefined) {
                dependencies = dependencies.concat(Object.keys(packagejson.dependencies));
            }
            if (packagejson.peerDependencies != undefined) {
                dependencies = dependencies.concat(Object.keys(packagejson.peerDependencies));
            }
            for (const dependency of dependencies) {
                const nodeProjectRoot = resolvePath(projectRoot, "node_modules", dependency);
                const [libPackageJson] = await loadFile(compilerHost, resolvePath(nodeProjectRoot, "package.json"), JSON.parse, program.reportDiagnostic);
                if (libPackageJson.cadlMain != undefined) {
                    completions.items.push({
                        label: dependency,
                        commitCharacters: [],
                        kind: node.exports.CompletionItemKind.Module,
                    });
                }
            }
        }
    }
    async function addImportCompletion(program, document, completions, node) {
        if (node.value.startsWith("./") || node.value.startsWith("../")) {
            await addRelativePathCompletion(program, document, completions, node);
        }
        else if (!node.value.startsWith(".")) {
            await addLibraryImportCompletion(program, document, completions);
        }
    }
    async function addRelativePathCompletion(program, document, completions, node$1) {
        const documentPath = await getPath(document);
        const documentFile = getBaseFileName(documentPath);
        const documentDir = getDirectoryPath(documentPath);
        const nodevalueDir = hasTrailingDirectorySeparator(node$1.value)
            ? node$1.value
            : getDirectoryPath(node$1.value);
        const mainCadl = resolvePath(documentDir, nodevalueDir);
        const files = (await program.host.readDir(mainCadl)).filter((x) => x !== documentFile && x !== "node_modules");
        for (const file of files) {
            const extension = getAnyExtensionFromPath(file);
            switch (extension) {
                case ".cadl":
                case ".js":
                case ".mjs":
                    completions.items.push({
                        label: file,
                        commitCharacters: [],
                        kind: node.exports.CompletionItemKind.File,
                    });
                    break;
                case "":
                    completions.items.push({
                        label: file,
                        commitCharacters: [],
                        kind: node.exports.CompletionItemKind.Folder,
                    });
                    break;
            }
        }
    }
    /**
     * Add completion options for an identifier.
     */
    function addIdentifierCompletion(program, node$1, completions) {
        var _a, _b;
        const result = program.checker.resolveCompletions(node$1);
        if (result.size === 0) {
            return;
        }
        for (const [key, { sym, label }] of result) {
            let documentation;
            let kind;
            let deprecated = false;
            if (sym.flags & (65536 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Decorator */)) {
                kind = node.exports.CompletionItemKind.Function;
            }
            else if (sym.flags & 2048 /* SymbolFlags.Namespace */ &&
                sym.declarations[0].kind !== SyntaxKind.NamespaceStatement) {
                kind = node.exports.CompletionItemKind.Module;
            }
            else {
                const type = (_a = sym.type) !== null && _a !== void 0 ? _a : program.checker.getTypeForNode(sym.declarations[0]);
                documentation = getDoc(program, type);
                kind = getCompletionItemKind(program, type);
                deprecated = isDeprecated(program, type);
            }
            const item = {
                label: label !== null && label !== void 0 ? label : key,
                documentation,
                kind,
                insertText: key,
            };
            if (deprecated) {
                item.tags = [node.exports.CompletionItemTag.Deprecated];
            }
            completions.items.push(item);
        }
        if (((_b = node$1.parent) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.TypeReference) {
            addKeywordCompletion("identifier", completions);
        }
    }
    function getCompletionItemKind(program, target) {
        var _a;
        switch ((_a = target.node) === null || _a === void 0 ? void 0 : _a.kind) {
            case SyntaxKind.EnumStatement:
            case SyntaxKind.UnionStatement:
                return node.exports.CompletionItemKind.Enum;
            case SyntaxKind.EnumMember:
            case SyntaxKind.UnionVariant:
                return node.exports.CompletionItemKind.EnumMember;
            case SyntaxKind.AliasStatement:
                return node.exports.CompletionItemKind.Variable;
            case SyntaxKind.ModelStatement:
                return isIntrinsic(program, target) ? node.exports.CompletionItemKind.Keyword : node.exports.CompletionItemKind.Class;
            case SyntaxKind.ModelProperty:
                return node.exports.CompletionItemKind.Field;
            case SyntaxKind.OperationStatement:
                return node.exports.CompletionItemKind.Method;
            case SyntaxKind.NamespaceStatement:
                return node.exports.CompletionItemKind.Module;
            default:
                return node.exports.CompletionItemKind.Struct;
        }
    }
    async function getSemanticTokens(params) {
        const ignore = -1;
        const defer = -2;
        const file = await compilerHost.readFile(await getPath(params.textDocument));
        const tokens = mapTokens();
        const ast = parse$1(file);
        classifyNode(ast);
        return Array.from(tokens.values()).filter((t) => t.kind !== undefined);
        function mapTokens() {
            const tokens = new Map();
            const scanner = createScanner(file, () => { });
            while (scanner.scan() !== Token.EndOfFile) {
                const kind = classifyToken(scanner.token);
                if (kind === ignore) {
                    continue;
                }
                tokens.set(scanner.tokenPosition, {
                    kind: kind === defer ? undefined : kind,
                    pos: scanner.tokenPosition,
                    end: scanner.position,
                });
            }
            return tokens;
        }
        function classifyToken(token) {
            switch (token) {
                case Token.Identifier:
                    return defer;
                case Token.StringLiteral:
                    return SemanticTokenKind.String;
                case Token.NumericLiteral:
                    return SemanticTokenKind.Number;
                case Token.MultiLineComment:
                case Token.SingleLineComment:
                    return SemanticTokenKind.Comment;
                default:
                    if (isKeyword(token)) {
                        return SemanticTokenKind.Keyword;
                    }
                    if (isPunctuation(token)) {
                        return SemanticTokenKind.Operator;
                    }
                    return ignore;
            }
        }
        function classifyNode(node) {
            switch (node.kind) {
                case SyntaxKind.DirectiveExpression:
                    classify(node.target, SemanticTokenKind.Keyword);
                    break;
                case SyntaxKind.TemplateParameterDeclaration:
                    classify(node.id, SemanticTokenKind.TypeParameter);
                    break;
                case SyntaxKind.ModelProperty:
                case SyntaxKind.UnionVariant:
                    classify(node.id, SemanticTokenKind.Property);
                    break;
                case SyntaxKind.AliasStatement:
                    classify(node.id, SemanticTokenKind.Struct);
                    break;
                case SyntaxKind.ModelStatement:
                    classify(node.id, SemanticTokenKind.Struct);
                    break;
                case SyntaxKind.EnumStatement:
                    classify(node.id, SemanticTokenKind.Enum);
                    break;
                case SyntaxKind.EnumMember:
                    classify(node.id, SemanticTokenKind.EnumMember);
                    break;
                case SyntaxKind.NamespaceStatement:
                    classify(node.id, SemanticTokenKind.Namespace);
                    break;
                case SyntaxKind.InterfaceStatement:
                    classify(node.id, SemanticTokenKind.Interface);
                    break;
                case SyntaxKind.OperationStatement:
                    classify(node.id, SemanticTokenKind.Function);
                    break;
                case SyntaxKind.DecoratorExpression:
                    classifyReference(node.target, SemanticTokenKind.Macro);
                    break;
                case SyntaxKind.TypeReference:
                    classifyReference(node.target);
                    break;
                case SyntaxKind.MemberExpression:
                    classifyReference(node);
                    break;
            }
            visitChildren(node, classifyNode);
        }
        function classify(node, kind) {
            const token = tokens.get(node.pos);
            if (token && token.kind === undefined) {
                token.kind = kind;
            }
        }
        function classifyReference(node, kind = SemanticTokenKind.Type) {
            switch (node.kind) {
                case SyntaxKind.MemberExpression:
                    classifyIdentifier(node.base, SemanticTokenKind.Namespace);
                    classifyIdentifier(node.id, kind);
                    break;
                case SyntaxKind.TypeReference:
                    classifyIdentifier(node.target, kind);
                    break;
                case SyntaxKind.Identifier:
                    classify(node, kind);
                    break;
            }
        }
        function classifyIdentifier(node, kind) {
            if (node.kind === SyntaxKind.Identifier) {
                classify(node, kind);
            }
        }
    }
    async function buildSemanticTokens(params) {
        const builder = new node.exports.SemanticTokensBuilder();
        const tokens = await getSemanticTokens(params);
        const file = await compilerHost.readFile(await getPath(params.textDocument));
        const starts = file.getLineStarts();
        for (const token of tokens) {
            const start = file.getLineAndCharacterOfPosition(token.pos);
            const end = file.getLineAndCharacterOfPosition(token.end);
            for (let pos = token.pos, line = start.line; line <= end.line; line++) {
                const endPos = line === end.line ? token.end : starts[line + 1];
                const character = line === start.line ? start.character : 0;
                builder.push(line, character, endPos - pos, token.kind, 0);
                pos = endPos;
            }
        }
        return builder.build();
    }
    function documentClosed(change) {
        // clear diagnostics on file close
        sendDiagnostics(change.document, []);
    }
    function getLocations(targets) {
        var _a;
        return (_a = targets === null || targets === void 0 ? void 0 : targets.map(getLocation).filter((x) => !!x)) !== null && _a !== void 0 ? _a : [];
    }
    function getLocation(target) {
        const location = getSourceLocation(target);
        if (location.isSynthetic) {
            return undefined;
        }
        const start = location.file.getLineAndCharacterOfPosition(location.pos);
        const end = location.file.getLineAndCharacterOfPosition(location.end);
        return {
            uri: getURL(location.file.path),
            range: node.exports.Range.create(start, end),
        };
    }
    function convertSeverity(severity) {
        switch (severity) {
            case "warning":
                return node.exports.DiagnosticSeverity.Warning;
            case "error":
                return node.exports.DiagnosticSeverity.Error;
        }
    }
    function log(message, details = undefined) {
        message = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (details) {
            message += ": " + JSON.stringify(details, undefined, 2);
        }
        if (!isInitialized) {
            pendingMessages.push(message);
            return;
        }
        for (const pending of pendingMessages) {
            host.log(pending);
        }
        pendingMessages = [];
        host.log(message);
    }
    function sendDiagnostics(document, diagnostics) {
        host.sendDiagnostics({
            uri: document.uri,
            version: document.version,
            diagnostics,
        });
    }
    /**
     * Determine if the given document is the latest version.
     *
     * A document can become out-of-date if a change comes in during an async
     * operation.
     */
    function upToDate(document) {
        var _a;
        if (!("version" in document)) {
            return true;
        }
        return document.version === ((_a = host.getOpenDocumentByURL(document.uri)) === null || _a === void 0 ? void 0 : _a.version);
    }
    /**
     * Infer the appropriate entry point (a.k.a. "main file") for analyzing a
     * change to the file at the given path. This is necessary because different
     * results can be obtained from compiling the same file with different entry
     * points.
     *
     * Walk directory structure upwards looking for package.json with cadlMain or
     * main.cadl file. Stop search when reaching a workspace root. If a root is
     * reached without finding an entry point, use the given path as its own
     * entry point.
     *
     * Untitled documents are always treated as their own entry points as they
     * do not exist in a directory that could pull them in via another entry
     * point.
     */
    async function getMainFileForDocument(path) {
        var _a;
        if (path.startsWith("untitled:")) {
            return path;
        }
        let dir = getDirectoryPath(path);
        const options = { allowFileNotFound: true };
        while (inWorkspace(dir)) {
            let mainFile = "main.cadl";
            let pkg;
            const pkgPath = joinPaths(dir, "package.json");
            const cached = (_a = (await fileSystemCache.get(pkgPath))) === null || _a === void 0 ? void 0 : _a.data;
            if (cached) {
                pkg = cached;
            }
            else {
                [pkg] = await loadFile(compilerHost, pkgPath, JSON.parse, logMainFileSearchDiagnostic, options);
                (await fileSystemCache.get(pkgPath)).data = pkg !== null && pkg !== void 0 ? pkg : {};
            }
            if (typeof (pkg === null || pkg === void 0 ? void 0 : pkg.cadlMain) === "string") {
                mainFile = pkg.cadlMain;
            }
            const candidate = joinPaths(dir, mainFile);
            const stat = await doIO(() => compilerHost.stat(candidate), candidate, logMainFileSearchDiagnostic, options);
            if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
                return candidate;
            }
            dir = getDirectoryPath(dir);
        }
        return path;
        function logMainFileSearchDiagnostic(diagnostic) {
            log(`Unexpected diagnostic while looking for main file of ${path}`, formatDiagnostic(diagnostic));
        }
    }
    function inWorkspace(path) {
        path = ensureTrailingDirectorySeparator(path);
        return workspaceFolders.some((f) => path.startsWith(f.path));
    }
    async function getPath(document) {
        if (isUntitled(document.uri)) {
            return document.uri;
        }
        const path = await fileURLToRealPath(document.uri);
        pathToURLMap.set(path, document.uri);
        return path;
    }
    function getURL(path) {
        var _a;
        if (isUntitled(path)) {
            return path;
        }
        return (_a = pathToURLMap.get(path)) !== null && _a !== void 0 ? _a : compilerHost.pathToFileURL(path);
    }
    function isUntitled(pathOrUrl) {
        return pathOrUrl.startsWith("untitled:");
    }
    function getOpenDocument(path) {
        const url = getURL(path);
        return url ? host.getOpenDocumentByURL(url) : undefined;
    }
    async function fileURLToRealPath(url) {
        return getNormalizedRealPath(compilerHost, compilerHost.fileURLToPath(url));
    }
    function createFileSystemCache() {
        const cache = new Map();
        let changes = [];
        return {
            async get(path) {
                for (const change of changes) {
                    const path = await fileURLToRealPath(change.uri);
                    cache.delete(path);
                }
                changes = [];
                return cache.get(path);
            },
            set(path, entry) {
                cache.set(path, entry);
            },
            notify(changes) {
                changes.push(...changes);
            },
        };
    }
    function createCompilerHost() {
        const base = host.compilerHost;
        return {
            ...base,
            readFile,
            stat,
            getSourceFileKind,
        };
        async function readFile(path) {
            // Try open files sent from client over LSP
            const document = getOpenDocument(path);
            if (document) {
                return {
                    document,
                    ...createSourceFile(document.getText(), path),
                };
            }
            // Try file system cache
            const cached = await fileSystemCache.get(path);
            if (cached) {
                if (cached.type === "error") {
                    throw cached.error;
                }
                return cached.file;
            }
            // Hit the disk and cache
            try {
                const file = await base.readFile(path);
                fileSystemCache.set(path, { type: "file", file });
                return file;
            }
            catch (error) {
                fileSystemCache.set(path, { type: "error", error });
                throw error;
            }
        }
        async function stat(path) {
            var _a;
            // if we have an open document for the path or a cache entry, then we know
            // it's a file and not a directory and needn't hit the disk.
            if (getOpenDocument(path) || ((_a = (await fileSystemCache.get(path))) === null || _a === void 0 ? void 0 : _a.type) === "file") {
                return {
                    isFile() {
                        return true;
                    },
                    isDirectory() {
                        return false;
                    },
                };
            }
            return await base.stat(path);
        }
        function getSourceFileKind(path) {
            const document = getOpenDocument(path);
            if ((document === null || document === void 0 ? void 0 : document.languageId) === "cadl") {
                return "cadl";
            }
            return getSourceFileKindFromExt(path);
        }
    }
}

/**
 * Helper to emit a file.
 * @param program Cadl Program
 * @param options File Emitter options
 */
async function emitFile(program, options) {
    const content = options.newLine && options.newLine === "crlf"
        ? options.content.replace(/(\r\n|\n|\r)/gm, "\r\n")
        : options.content;
    return await program.host.writeFile(options.path, content);
}

function navigateProgram(program, listeners) {
    const eventEmitter = listeners instanceof EventEmitter ? listeners : createEventEmitter(listeners);
    const visited = new Set();
    eventEmitter.emit("root", program);
    if (!program.checker) {
        return;
    }
    if (program.currentProjector) {
        navigateNamespaceType(program.currentProjector.projectedGlobalNamespace, eventEmitter, visited);
    }
    else {
        navigateNamespaceType(program.checker.getGlobalNamespaceType(), eventEmitter, visited);
    }
}
function navigateNamespaceType(namespace, eventEmitter, visited) {
    eventEmitter.emit("namespace", namespace);
    for (const model of namespace.models.values()) {
        navigateModelType(model, eventEmitter, visited);
    }
    for (const operation of namespace.operations.values()) {
        navigateOperationType(operation, eventEmitter, visited);
    }
    for (const subNamespace of namespace.namespaces.values()) {
        navigateNamespaceType(subNamespace, eventEmitter, visited);
    }
    for (const union of namespace.unions.values()) {
        navigateUnionType(union, eventEmitter, visited);
    }
    for (const iface of namespace.interfaces.values()) {
        navigateInterfaceType(iface, eventEmitter, visited);
    }
}
function checkVisited(visited, item) {
    if (visited.has(item)) {
        return true;
    }
    visited.add(item);
    return false;
}
function navigateOperationType(operation, eventEmitter, visited) {
    if (checkVisited(visited, operation)) {
        return;
    }
    eventEmitter.emit("operation", operation);
    for (const parameter of operation.parameters.properties.values()) {
        navigateType(parameter, eventEmitter, visited);
    }
    navigateType(operation.returnType, eventEmitter, visited);
}
function navigateModelType(model, eventEmitter, visited) {
    if (checkVisited(visited, model)) {
        return;
    }
    eventEmitter.emit("model", model);
    for (const property of model.properties.values()) {
        navigateModelTypeProperty(property, eventEmitter, visited);
    }
    if (model.baseModel) {
        navigateModelType(model.baseModel, eventEmitter, visited);
    }
    if (model.indexer && model.indexer.value) {
        navigateType(model.indexer.value, eventEmitter, visited);
    }
    eventEmitter.emit("exitModel", model);
}
function navigateModelTypeProperty(property, eventEmitter, visited) {
    if (checkVisited(visited, property)) {
        return;
    }
    eventEmitter.emit("modelProperty", property);
    navigateType(property.type, eventEmitter, visited);
}
function navigateInterfaceType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("interface", type);
    for (const op of type.operations.values()) {
        navigateType(op, eventEmitter, visited);
    }
}
function navigateEnumType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("enum", type);
}
function navigateUnionType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("union", type);
    for (const variant of type.variants.values()) {
        navigateType(variant, eventEmitter, visited);
    }
}
function navigateUnionTypeVariant(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("unionVariant", type);
    navigateType(type.type, eventEmitter, visited);
}
function navigateTupleType(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("tuple", type);
    for (const value of type.values) {
        navigateType(value, eventEmitter, visited);
    }
}
function navigateTemplateParameter(type, eventEmitter, visited) {
    if (checkVisited(visited, type)) {
        return;
    }
    eventEmitter.emit("templateParameter", type);
}
function navigateType(type, eventEmitter, visited) {
    switch (type.kind) {
        case "Model":
            return navigateModelType(type, eventEmitter, visited);
        case "ModelProperty":
            return navigateModelTypeProperty(type, eventEmitter, visited);
        case "Namespace":
            return navigateNamespaceType(type, eventEmitter, visited);
        case "Interface":
            return navigateInterfaceType(type, eventEmitter, visited);
        case "Enum":
            return navigateEnumType(type, eventEmitter, visited);
        case "Operation":
            return navigateOperationType(type, eventEmitter, visited);
        case "Union":
            return navigateUnionType(type, eventEmitter, visited);
        case "UnionVariant":
            return navigateUnionTypeVariant(type, eventEmitter, visited);
        case "Tuple":
            return navigateTupleType(type, eventEmitter, visited);
        case "TemplateParameter":
            return navigateTemplateParameter(type, eventEmitter, visited);
        case "Object":
        case "Projection":
        case "Function":
        case "Boolean":
        case "EnumMember":
        case "Intrinsic":
        case "Number":
        case "String":
            return;
        default:
            return;
    }
}
// Return property from type, nesting into baseTypes as needed.
function getProperty(type, propertyName) {
    while (type.baseModel) {
        if (type.properties.has(propertyName)) {
            return type.properties.get(propertyName);
        }
        type = type.baseModel;
    }
    return type.properties.get(propertyName);
}
class EventEmitter {
    constructor() {
        this.listeners = new Map();
    }
    on(name, listener) {
        const array = this.listeners.get(name);
        if (array) {
            array.push(listener);
        }
        else {
            this.listeners.set(name, [listener]);
        }
    }
    emit(name, ...args) {
        const listeners = this.listeners.get(name);
        if (listeners) {
            for (const listener of listeners) {
                listener(...args);
            }
        }
    }
}
function createEventEmitter(listeners) {
    const eventEmitter = new EventEmitter();
    for (const [name, listener] of Object.entries(listeners)) {
        eventEmitter.on(name, listener);
    }
    return eventEmitter;
}

/**
 * Check if the given type has template arguments.
 */
function isTemplateInstance(type) {
    const maybeTemplateType = type;
    return (maybeTemplateType.templateArguments !== undefined &&
        maybeTemplateType.templateArguments.length > 0);
}
/**
 * Resolve if the type is a template type declaration(Non initialized template type).
 */
function isTemplateDeclaration(type) {
    if (type.node === undefined) {
        return false;
    }
    const node = type.node;
    return node.templateParameters.length > 0 && !isTemplateInstance(type);
}
/**
 * Resolve if the type was created from a template type or is a template type declaration.
 */
function isTemplateDeclarationOrInstance(type) {
    if (type.node === undefined) {
        return false;
    }
    const node = type.node;
    return node.templateParameters && node.templateParameters.length > 0;
}
function isGlobalNamespace(program, namespace) {
    return program.checker.getGlobalNamespaceType() === namespace;
}

function parse(text, parsers, opts) {
    const result = parse$1(text, { comments: true });
    const errors = result.parseDiagnostics.filter((x) => x.severity === "error");
    if (errors.length > 0 && !result.printable) {
        throw new PrettierParserError(errors[0]);
    }
    return result;
}
class PrettierParserError extends Error {
    constructor(error) {
        var _a, _b;
        super(error.message);
        this.error = error;
        const location = getSourceLocation(error.target);
        this.loc = {
            start: (_a = location === null || location === void 0 ? void 0 : location.pos) !== null && _a !== void 0 ? _a : 0,
            end: (_b = location === null || location === void 0 ? void 0 : location.end) !== null && _b !== void 0 ? _b : 0,
        };
    }
}

var standalone = {exports: {}};

(function (module, exports) {
	(function(e){module.exports=e();})(function(){var we=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports);var Ye=we((Ig,ru)=>{var rr=function(e){return e&&e.Math==Math&&e};ru.exports=rr(typeof globalThis=="object"&&globalThis)||rr(typeof window=="object"&&window)||rr(typeof self=="object"&&self)||rr(typeof commonjsGlobal=="object"&&commonjsGlobal)||function(){return this}()||Function("return this")();});var Dt=we((Lg,nu)=>{nu.exports=function(e){try{return !!e()}catch{return !0}};});var Ct=we((jg,uu)=>{var So=Dt();uu.exports=!So(function(){return Object.defineProperty({},1,{get:function(){return 7}})[1]!=7});});var nr=we((Og,su)=>{var xo=Dt();su.exports=!xo(function(){var e=function(){}.bind();return typeof e!="function"||e.hasOwnProperty("prototype")});});var Et=we((qg,iu)=>{var bo=nr(),ur=Function.prototype.call;iu.exports=bo?ur.bind(ur):function(){return ur.apply(ur,arguments)};});var cu=we(lu=>{var au={}.propertyIsEnumerable,ou=Object.getOwnPropertyDescriptor,To=ou&&!au.call({1:2},1);lu.f=To?function(n){var t=ou(this,n);return !!t&&t.enumerable}:au;});var sr=we((Rg,pu)=>{pu.exports=function(e,n){return {enumerable:!(e&1),configurable:!(e&2),writable:!(e&4),value:n}};});var at=we((Vg,mu)=>{var fu=nr(),Du=Function.prototype,Bo=Du.bind,Or=Du.call,No=fu&&Bo.bind(Or,Or);mu.exports=fu?function(e){return e&&No(e)}:function(e){return e&&function(){return Or.apply(e,arguments)}};});var ir=we((Wg,gu)=>{var du=at(),wo=du({}.toString),_o=du("".slice);gu.exports=function(e){return _o(wo(e),8,-1)};});var hu=we(($g,yu)=>{var Po=Ye(),ko=at(),Io=Dt(),Lo=ir(),qr=Po.Object,jo=ko("".split);yu.exports=Io(function(){return !qr("z").propertyIsEnumerable(0)})?function(e){return Lo(e)=="String"?jo(e,""):qr(e)}:qr;});var Mr=we((Hg,vu)=>{var Oo=Ye(),qo=Oo.TypeError;vu.exports=function(e){if(e==null)throw qo("Can't call method on "+e);return e};});var ar=we((Gg,Cu)=>{var Mo=hu(),Ro=Mr();Cu.exports=function(e){return Mo(Ro(e))};});var ot=we((Jg,Eu)=>{Eu.exports=function(e){return typeof e=="function"};});var Ft=we((Ug,Fu)=>{var Vo=ot();Fu.exports=function(e){return typeof e=="object"?e!==null:Vo(e)};});var Rt=we((zg,Au)=>{var Rr=Ye(),Wo=ot(),$o=function(e){return Wo(e)?e:void 0};Au.exports=function(e,n){return arguments.length<2?$o(Rr[e]):Rr[e]&&Rr[e][n]};});var Vr=we((Xg,Su)=>{var Ho=at();Su.exports=Ho({}.isPrototypeOf);});var bu=we((Kg,xu)=>{var Go=Rt();xu.exports=Go("navigator","userAgent")||"";});var ku=we((Yg,Pu)=>{var _u=Ye(),Wr=bu(),Tu=_u.process,Bu=_u.Deno,Nu=Tu&&Tu.versions||Bu&&Bu.version,wu=Nu&&Nu.v8,ft,or;wu&&(ft=wu.split("."),or=ft[0]>0&&ft[0]<4?1:+(ft[0]+ft[1]));!or&&Wr&&(ft=Wr.match(/Edge\/(\d+)/),(!ft||ft[1]>=74)&&(ft=Wr.match(/Chrome\/(\d+)/),ft&&(or=+ft[1])));Pu.exports=or;});var $r=we((Qg,Lu)=>{var Iu=ku(),Jo=Dt();Lu.exports=!!Object.getOwnPropertySymbols&&!Jo(function(){var e=Symbol();return !String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&Iu&&Iu<41});});var Hr=we((Zg,ju)=>{var Uo=$r();ju.exports=Uo&&!Symbol.sham&&typeof Symbol.iterator=="symbol";});var Gr=we((e0,Ou)=>{var zo=Ye(),Xo=Rt(),Ko=ot(),Yo=Vr(),Qo=Hr(),Zo=zo.Object;Ou.exports=Qo?function(e){return typeof e=="symbol"}:function(e){var n=Xo("Symbol");return Ko(n)&&Yo(n.prototype,Zo(e))};});var lr=we((t0,qu)=>{var el=Ye(),tl=el.String;qu.exports=function(e){try{return tl(e)}catch{return "Object"}};});var Vt=we((r0,Mu)=>{var rl=Ye(),nl=ot(),ul=lr(),sl=rl.TypeError;Mu.exports=function(e){if(nl(e))return e;throw sl(ul(e)+" is not a function")};});var cr=we((n0,Ru)=>{var il=Vt();Ru.exports=function(e,n){var t=e[n];return t==null?void 0:il(t)};});var Wu=we((u0,Vu)=>{var al=Ye(),Jr=Et(),Ur=ot(),zr=Ft(),ol=al.TypeError;Vu.exports=function(e,n){var t,s;if(n==="string"&&Ur(t=e.toString)&&!zr(s=Jr(t,e))||Ur(t=e.valueOf)&&!zr(s=Jr(t,e))||n!=="string"&&Ur(t=e.toString)&&!zr(s=Jr(t,e)))return s;throw ol("Can't convert object to primitive value")};});var Hu=we((s0,$u)=>{$u.exports=!1;});var pr=we((i0,Ju)=>{var Gu=Ye(),ll=Object.defineProperty;Ju.exports=function(e,n){try{ll(Gu,e,{value:n,configurable:!0,writable:!0});}catch{Gu[e]=n;}return n};});var fr=we((a0,zu)=>{var cl=Ye(),pl=pr(),Uu="__core-js_shared__",fl=cl[Uu]||pl(Uu,{});zu.exports=fl;});var Xr=we((o0,Ku)=>{var Dl=Hu(),Xu=fr();(Ku.exports=function(e,n){return Xu[e]||(Xu[e]=n!==void 0?n:{})})("versions",[]).push({version:"3.22.2",mode:Dl?"pure":"global",copyright:"\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE",source:"https://github.com/zloirock/core-js"});});var Dr=we((l0,Yu)=>{var ml=Ye(),dl=Mr(),gl=ml.Object;Yu.exports=function(e){return gl(dl(e))};});var gt=we((c0,Qu)=>{var yl=at(),hl=Dr(),vl=yl({}.hasOwnProperty);Qu.exports=Object.hasOwn||function(n,t){return vl(hl(n),t)};});var Kr=we((p0,Zu)=>{var Cl=at(),El=0,Fl=Math.random(),Al=Cl(1 .toString);Zu.exports=function(e){return "Symbol("+(e===void 0?"":e)+")_"+Al(++El+Fl,36)};});var St=we((f0,us)=>{var Sl=Ye(),xl=Xr(),es=gt(),bl=Kr(),ts=$r(),ns=Hr(),Nt=xl("wks"),At=Sl.Symbol,rs=At&&At.for,Tl=ns?At:At&&At.withoutSetter||bl;us.exports=function(e){if(!es(Nt,e)||!(ts||typeof Nt[e]=="string")){var n="Symbol."+e;ts&&es(At,e)?Nt[e]=At[e]:ns&&rs?Nt[e]=rs(n):Nt[e]=Tl(n);}return Nt[e]};});var os=we((D0,as)=>{var Bl=Ye(),Nl=Et(),ss=Ft(),is=Gr(),wl=cr(),_l=Wu(),Pl=St(),kl=Bl.TypeError,Il=Pl("toPrimitive");as.exports=function(e,n){if(!ss(e)||is(e))return e;var t=wl(e,Il),s;if(t){if(n===void 0&&(n="default"),s=Nl(t,e,n),!ss(s)||is(s))return s;throw kl("Can't convert object to primitive value")}return n===void 0&&(n="number"),_l(e,n)};});var mr=we((m0,ls)=>{var Ll=os(),jl=Gr();ls.exports=function(e){var n=Ll(e,"string");return jl(n)?n:n+""};});var fs=we((d0,ps)=>{var Ol=Ye(),cs=Ft(),Yr=Ol.document,ql=cs(Yr)&&cs(Yr.createElement);ps.exports=function(e){return ql?Yr.createElement(e):{}};});var Qr=we((g0,Ds)=>{var Ml=Ct(),Rl=Dt(),Vl=fs();Ds.exports=!Ml&&!Rl(function(){return Object.defineProperty(Vl("div"),"a",{get:function(){return 7}}).a!=7});});var Zr=we(ds=>{var Wl=Ct(),$l=Et(),Hl=cu(),Gl=sr(),Jl=ar(),Ul=mr(),zl=gt(),Xl=Qr(),ms=Object.getOwnPropertyDescriptor;ds.f=Wl?ms:function(n,t){if(n=Jl(n),t=Ul(t),Xl)try{return ms(n,t)}catch{}if(zl(n,t))return Gl(!$l(Hl.f,n,t),n[t])};});var ys=we((h0,gs)=>{var Kl=Ct(),Yl=Dt();gs.exports=Kl&&Yl(function(){return Object.defineProperty(function(){},"prototype",{value:42,writable:!1}).prototype!=42});});var wt=we((v0,vs)=>{var hs=Ye(),Ql=Ft(),Zl=hs.String,ec=hs.TypeError;vs.exports=function(e){if(Ql(e))return e;throw ec(Zl(e)+" is not an object")};});var gr=we(Es=>{var tc=Ye(),rc=Ct(),nc=Qr(),uc=ys(),dr=wt(),Cs=mr(),sc=tc.TypeError,en=Object.defineProperty,ic=Object.getOwnPropertyDescriptor,tn="enumerable",rn="configurable",nn="writable";Es.f=rc?uc?function(n,t,s){if(dr(n),t=Cs(t),dr(s),typeof n=="function"&&t==="prototype"&&"value"in s&&nn in s&&!s[nn]){var a=ic(n,t);a&&a[nn]&&(n[t]=s.value,s={configurable:rn in s?s[rn]:a[rn],enumerable:tn in s?s[tn]:a[tn],writable:!1});}return en(n,t,s)}:en:function(n,t,s){if(dr(n),t=Cs(t),dr(s),nc)try{return en(n,t,s)}catch{}if("get"in s||"set"in s)throw sc("Accessors not supported");return "value"in s&&(n[t]=s.value),n};});var yr=we((E0,Fs)=>{var ac=Ct(),oc=gr(),lc=sr();Fs.exports=ac?function(e,n,t){return oc.f(e,n,lc(1,t))}:function(e,n,t){return e[n]=t,e};});var hr=we((F0,As)=>{var cc=at(),pc=ot(),un=fr(),fc=cc(Function.toString);pc(un.inspectSource)||(un.inspectSource=function(e){return fc(e)});As.exports=un.inspectSource;});var bs=we((A0,xs)=>{var Dc=Ye(),mc=ot(),dc=hr(),Ss=Dc.WeakMap;xs.exports=mc(Ss)&&/native code/.test(dc(Ss));});var Ns=we((S0,Bs)=>{var gc=Xr(),yc=Kr(),Ts=gc("keys");Bs.exports=function(e){return Ts[e]||(Ts[e]=yc(e))};});var sn=we((x0,ws)=>{ws.exports={};});var js=we((b0,Ls)=>{var hc=bs(),Is=Ye(),an=at(),vc=Ft(),Cc=yr(),on=gt(),ln=fr(),Ec=Ns(),Fc=sn(),_s="Object already initialized",pn=Is.TypeError,Ac=Is.WeakMap,vr,Wt,Cr,Sc=function(e){return Cr(e)?Wt(e):vr(e,{})},xc=function(e){return function(n){var t;if(!vc(n)||(t=Wt(n)).type!==e)throw pn("Incompatible receiver, "+e+" required");return t}};hc||ln.state?(yt=ln.state||(ln.state=new Ac),Ps=an(yt.get),cn=an(yt.has),ks=an(yt.set),vr=function(e,n){if(cn(yt,e))throw new pn(_s);return n.facade=e,ks(yt,e,n),n},Wt=function(e){return Ps(yt,e)||{}},Cr=function(e){return cn(yt,e)}):(xt=Ec("state"),Fc[xt]=!0,vr=function(e,n){if(on(e,xt))throw new pn(_s);return n.facade=e,Cc(e,xt,n),n},Wt=function(e){return on(e,xt)?e[xt]:{}},Cr=function(e){return on(e,xt)});var yt,Ps,cn,ks,xt;Ls.exports={set:vr,get:Wt,has:Cr,enforce:Sc,getterFor:xc};});var Ms=we((T0,qs)=>{var fn=Ct(),bc=gt(),Os=Function.prototype,Tc=fn&&Object.getOwnPropertyDescriptor,Dn=bc(Os,"name"),Bc=Dn&&function(){}.name==="something",Nc=Dn&&(!fn||fn&&Tc(Os,"name").configurable);qs.exports={EXISTS:Dn,PROPER:Bc,CONFIGURABLE:Nc};});var Hs=we((B0,$s)=>{var wc=Ye(),Rs=ot(),_c=gt(),Vs=yr(),Pc=pr(),kc=hr(),Ws=js(),Ic=Ms().CONFIGURABLE,Lc=Ws.get,jc=Ws.enforce,Oc=String(String).split("String");($s.exports=function(e,n,t,s){var a=s?!!s.unsafe:!1,r=s?!!s.enumerable:!1,u=s?!!s.noTargetGet:!1,i=s&&s.name!==void 0?s.name:n,o;if(Rs(t)&&(String(i).slice(0,7)==="Symbol("&&(i="["+String(i).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!_c(t,"name")||Ic&&t.name!==i)&&Vs(t,"name",i),o=jc(t),o.source||(o.source=Oc.join(typeof i=="string"?i:""))),e===wc){r?e[n]=t:Pc(n,t);return}else a?!u&&e[n]&&(r=!0):delete e[n];r?e[n]=t:Vs(e,n,t);})(Function.prototype,"toString",function(){return Rs(this)&&Lc(this).source||kc(this)});});var Er=we((N0,Gs)=>{var qc=Math.ceil,Mc=Math.floor;Gs.exports=function(e){var n=+e;return n!==n||n===0?0:(n>0?Mc:qc)(n)};});var Us=we((w0,Js)=>{var Rc=Er(),Vc=Math.max,Wc=Math.min;Js.exports=function(e,n){var t=Rc(e);return t<0?Vc(t+n,0):Wc(t,n)};});var Xs=we((_0,zs)=>{var $c=Er(),Hc=Math.min;zs.exports=function(e){return e>0?Hc($c(e),9007199254740991):0};});var _t=we((P0,Ks)=>{var Gc=Xs();Ks.exports=function(e){return Gc(e.length)};});var Zs=we((k0,Qs)=>{var Jc=ar(),Uc=Us(),zc=_t(),Ys=function(e){return function(n,t,s){var a=Jc(n),r=zc(a),u=Uc(s,r),i;if(e&&t!=t){for(;r>u;)if(i=a[u++],i!=i)return !0}else for(;r>u;u++)if((e||u in a)&&a[u]===t)return e||u||0;return !e&&-1}};Qs.exports={includes:Ys(!0),indexOf:Ys(!1)};});var ri=we((I0,ti)=>{var Xc=at(),mn=gt(),Kc=ar(),Yc=Zs().indexOf,Qc=sn(),ei=Xc([].push);ti.exports=function(e,n){var t=Kc(e),s=0,a=[],r;for(r in t)!mn(Qc,r)&&mn(t,r)&&ei(a,r);for(;n.length>s;)mn(t,r=n[s++])&&(~Yc(a,r)||ei(a,r));return a};});var ui=we((L0,ni)=>{ni.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"];});var ii=we(si=>{var Zc=ri(),ep=ui(),tp=ep.concat("length","prototype");si.f=Object.getOwnPropertyNames||function(n){return Zc(n,tp)};});var oi=we(ai=>{ai.f=Object.getOwnPropertySymbols;});var ci=we((q0,li)=>{var rp=Rt(),np=at(),up=ii(),sp=oi(),ip=wt(),ap=np([].concat);li.exports=rp("Reflect","ownKeys")||function(n){var t=up.f(ip(n)),s=sp.f;return s?ap(t,s(n)):t};});var Di=we((M0,fi)=>{var pi=gt(),op=ci(),lp=Zr(),cp=gr();fi.exports=function(e,n,t){for(var s=op(n),a=cp.f,r=lp.f,u=0;u<s.length;u++){var i=s[u];!pi(e,i)&&!(t&&pi(t,i))&&a(e,i,r(n,i));}};});var di=we((R0,mi)=>{var pp=Dt(),fp=ot(),Dp=/#|\.prototype\./,$t=function(e,n){var t=dp[mp(e)];return t==yp?!0:t==gp?!1:fp(n)?pp(n):!!n},mp=$t.normalize=function(e){return String(e).replace(Dp,".").toLowerCase()},dp=$t.data={},gp=$t.NATIVE="N",yp=$t.POLYFILL="P";mi.exports=$t;});var Ht=we((V0,gi)=>{var dn=Ye(),hp=Zr().f,vp=yr(),Cp=Hs(),Ep=pr(),Fp=Di(),Ap=di();gi.exports=function(e,n){var t=e.target,s=e.global,a=e.stat,r,u,i,o,c,v;if(s?u=dn:a?u=dn[t]||Ep(t,{}):u=(dn[t]||{}).prototype,u)for(i in n){if(c=n[i],e.noTargetGet?(v=hp(u,i),o=v&&v.value):o=u[i],r=Ap(s?i:t+(a?".":"#")+i,e.forced),!r&&o!==void 0){if(typeof c==typeof o)continue;Fp(c,o);}(e.sham||o&&o.sham)&&vp(c,"sham",!0),Cp(u,i,c,e);}};});var gn=we((W0,yi)=>{var Sp=ir();yi.exports=Array.isArray||function(n){return Sp(n)=="Array"};});var yn=we(($0,vi)=>{var hi=at(),xp=Vt(),bp=nr(),Tp=hi(hi.bind);vi.exports=function(e,n){return xp(e),n===void 0?e:bp?Tp(e,n):function(){return e.apply(n,arguments)}};});var hn=we((H0,Ei)=>{var Bp=Ye(),Np=gn(),wp=_t(),_p=yn(),Pp=Bp.TypeError,Ci=function(e,n,t,s,a,r,u,i){for(var o=a,c=0,v=u?_p(u,i):!1,m,d;c<s;){if(c in t){if(m=v?v(t[c],c,n):t[c],r>0&&Np(m))d=wp(m),o=Ci(e,n,m,d,o,r-1)-1;else {if(o>=9007199254740991)throw Pp("Exceed the acceptable array length");e[o]=m;}o++;}c++;}return o};Ei.exports=Ci;});var Si=we((G0,Ai)=>{var kp=St(),Ip=kp("toStringTag"),Fi={};Fi[Ip]="z";Ai.exports=String(Fi)==="[object z]";});var vn=we((J0,xi)=>{var Lp=Ye(),jp=Si(),Op=ot(),Fr=ir(),qp=St(),Mp=qp("toStringTag"),Rp=Lp.Object,Vp=Fr(function(){return arguments}())=="Arguments",Wp=function(e,n){try{return e[n]}catch{}};xi.exports=jp?Fr:function(e){var n,t,s;return e===void 0?"Undefined":e===null?"Null":typeof(t=Wp(n=Rp(e),Mp))=="string"?t:Vp?Fr(n):(s=Fr(n))=="Object"&&Op(n.callee)?"Arguments":s};});var _i=we((U0,wi)=>{var $p=at(),Hp=Dt(),bi=ot(),Gp=vn(),Jp=Rt(),Up=hr(),Ti=function(){},zp=[],Bi=Jp("Reflect","construct"),Cn=/^\s*(?:class|function)\b/,Xp=$p(Cn.exec),Kp=!Cn.exec(Ti),Gt=function(n){if(!bi(n))return !1;try{return Bi(Ti,zp,n),!0}catch{return !1}},Ni=function(n){if(!bi(n))return !1;switch(Gp(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return !1}try{return Kp||!!Xp(Cn,Up(n))}catch{return !0}};Ni.sham=!0;wi.exports=!Bi||Hp(function(){var e;return Gt(Gt.call)||!Gt(Object)||!Gt(function(){e=!0;})||e})?Ni:Gt;});var Li=we((z0,Ii)=>{var Yp=Ye(),Pi=gn(),Qp=_i(),Zp=Ft(),ef=St(),tf=ef("species"),ki=Yp.Array;Ii.exports=function(e){var n;return Pi(e)&&(n=e.constructor,Qp(n)&&(n===ki||Pi(n.prototype))?n=void 0:Zp(n)&&(n=n[tf],n===null&&(n=void 0))),n===void 0?ki:n};});var En=we((X0,ji)=>{var rf=Li();ji.exports=function(e,n){return new(rf(e))(n===0?0:n)};});var Oi=we(()=>{var nf=Ht(),uf=hn(),sf=Vt(),af=Dr(),of=_t(),lf=En();nf({target:"Array",proto:!0},{flatMap:function(n){var t=af(this),s=of(t),a;return sf(n),a=lf(t,0),a.length=uf(a,t,t,s,0,1,n,arguments.length>1?arguments[1]:void 0),a}});});var Fn=we((Q0,qi)=>{qi.exports={};});var Ri=we((Z0,Mi)=>{var cf=St(),pf=Fn(),ff=cf("iterator"),Df=Array.prototype;Mi.exports=function(e){return e!==void 0&&(pf.Array===e||Df[ff]===e)};});var An=we((ey,Wi)=>{var mf=vn(),Vi=cr(),df=Fn(),gf=St(),yf=gf("iterator");Wi.exports=function(e){if(e!=null)return Vi(e,yf)||Vi(e,"@@iterator")||df[mf(e)]};});var Hi=we((ty,$i)=>{var hf=Ye(),vf=Et(),Cf=Vt(),Ef=wt(),Ff=lr(),Af=An(),Sf=hf.TypeError;$i.exports=function(e,n){var t=arguments.length<2?Af(e):n;if(Cf(t))return Ef(vf(t,e));throw Sf(Ff(e)+" is not iterable")};});var Ui=we((ry,Ji)=>{var xf=Et(),Gi=wt(),bf=cr();Ji.exports=function(e,n,t){var s,a;Gi(e);try{if(s=bf(e,"return"),!s){if(n==="throw")throw t;return t}s=xf(s,e);}catch(r){a=!0,s=r;}if(n==="throw")throw t;if(a)throw s;return Gi(s),t};});var Qi=we((ny,Yi)=>{var Tf=Ye(),Bf=yn(),Nf=Et(),wf=wt(),_f=lr(),Pf=Ri(),kf=_t(),zi=Vr(),If=Hi(),Lf=An(),Xi=Ui(),jf=Tf.TypeError,Ar=function(e,n){this.stopped=e,this.result=n;},Ki=Ar.prototype;Yi.exports=function(e,n,t){var s=t&&t.that,a=!!(t&&t.AS_ENTRIES),r=!!(t&&t.IS_ITERATOR),u=!!(t&&t.INTERRUPTED),i=Bf(n,s),o,c,v,m,d,p,f,h=function(T){return o&&Xi(o,"normal",T),new Ar(!0,T)},w=function(T){return a?(wf(T),u?i(T[0],T[1],h):i(T[0],T[1])):u?i(T,h):i(T)};if(r)o=e;else {if(c=Lf(e),!c)throw jf(_f(e)+" is not iterable");if(Pf(c)){for(v=0,m=kf(e);m>v;v++)if(d=w(e[v]),d&&zi(Ki,d))return d;return new Ar(!1)}o=If(e,c);}for(p=o.next;!(f=Nf(p,o)).done;){try{d=w(f.value);}catch(T){Xi(o,"throw",T);}if(typeof d=="object"&&d&&zi(Ki,d))return d}return new Ar(!1)};});var ea=we((uy,Zi)=>{var Of=mr(),qf=gr(),Mf=sr();Zi.exports=function(e,n,t){var s=Of(n);s in e?qf.f(e,s,Mf(0,t)):e[s]=t;};});var ta=we(()=>{var Rf=Ht(),Vf=Qi(),Wf=ea();Rf({target:"Object",stat:!0},{fromEntries:function(n){var t={};return Vf(n,function(s,a){Wf(t,s,a);},{AS_ENTRIES:!0}),t}});});var ra=we(()=>{var $f=Ht(),Hf=Ye();$f({global:!0},{globalThis:Hf});});var na=we(()=>{ra();});var ua=we(()=>{var Gf=Ht(),Jf=hn(),Uf=Dr(),zf=_t(),Xf=Er(),Kf=En();Gf({target:"Array",proto:!0},{flat:function(){var n=arguments.length?arguments[0]:void 0,t=Uf(this),s=zf(t),a=Kf(t,0);return a.length=Jf(a,t,t,s,0,n===void 0?1:Xf(n)),a}});});var Pg=we((my,Co)=>{var Yf=["cliName","cliCategory","cliDescription"],Qf=["_"],Zf=["languageId"],sa,ia,aa,oa,la,ca;function kn(e,n){if(e==null)return {};var t=eD(e,n),s,a;if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)s=r[a],!(n.indexOf(s)>=0)&&(!Object.prototype.propertyIsEnumerable.call(e,s)||(t[s]=e[s]));}return t}function eD(e,n){if(e==null)return {};var t={},s=Object.keys(e),a,r;for(r=0;r<s.length;r++)a=s[r],!(n.indexOf(a)>=0)&&(t[a]=e[a]);return t}Oi();ta();na();ua();function Pt(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}var tD=Object.create,Br=Object.defineProperty,rD=Object.getOwnPropertyDescriptor,In=Object.getOwnPropertyNames,nD=Object.getPrototypeOf,uD=Object.prototype.hasOwnProperty,mt=(e,n)=>function(){return e&&(n=(0, e[In(e)[0]])(e=0)),n},Z=(e,n)=>function(){return n||(0, e[In(e)[0]])((n={exports:{}}).exports,n),n.exports},Ut=(e,n)=>{for(var t in n)Br(e,t,{get:n[t],enumerable:!0});},ga=(e,n,t,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let a of In(n))!uD.call(e,a)&&a!==t&&Br(e,a,{get:()=>n[a],enumerable:!(s=rD(n,a))||s.enumerable});return e},sD=(e,n,t)=>(t=e!=null?tD(nD(e)):{},ga(n||!e||!e.__esModule?Br(t,"default",{value:e,enumerable:!0}):t,e)),lt=e=>ga(Br({},"__esModule",{value:!0}),e),pa,fa,Tt,re=mt({"<define:process>"(){pa={},fa=[],Tt={env:pa,argv:fa};}}),ya=Z({"package.json"(e,n){n.exports={version:"2.7.1"};}}),iD=Z({"node_modules/diff/lib/diff/base.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.default=n;function n(){}n.prototype={diff:function(r,u){var i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},o=i.callback;typeof i=="function"&&(o=i,i={}),this.options=i;var c=this;function v(S){return o?(setTimeout(function(){o(void 0,S);},0),!0):S}r=this.castInput(r),u=this.castInput(u),r=this.removeEmpty(this.tokenize(r)),u=this.removeEmpty(this.tokenize(u));var m=u.length,d=r.length,p=1,f=m+d,h=[{newPos:-1,components:[]}],w=this.extractCommon(h[0],u,r,0);if(h[0].newPos+1>=m&&w+1>=d)return v([{value:this.join(u),count:u.length}]);function T(){for(var S=-1*p;S<=p;S+=2){var B=void 0,I=h[S-1],k=h[S+1],P=(k?k.newPos:0)-S;I&&(h[S-1]=void 0);var C=I&&I.newPos+1<m,D=k&&0<=P&&P<d;if(!C&&!D){h[S]=void 0;continue}if(!C||D&&I.newPos<k.newPos?(B=s(k),c.pushComponent(B.components,void 0,!0)):(B=I,B.newPos++,c.pushComponent(B.components,!0,void 0)),P=c.extractCommon(B,u,r,S),B.newPos+1>=m&&P+1>=d)return v(t(c,B.components,u,r,c.useLongestToken));h[S]=B;}p++;}if(o)(function S(){setTimeout(function(){if(p>f)return o();T()||S();},0);})();else for(;p<=f;){var A=T();if(A)return A}},pushComponent:function(r,u,i){var o=r[r.length-1];o&&o.added===u&&o.removed===i?r[r.length-1]={count:o.count+1,added:u,removed:i}:r.push({count:1,added:u,removed:i});},extractCommon:function(r,u,i,o){for(var c=u.length,v=i.length,m=r.newPos,d=m-o,p=0;m+1<c&&d+1<v&&this.equals(u[m+1],i[d+1]);)m++,d++,p++;return p&&r.components.push({count:p}),r.newPos=m,d},equals:function(r,u){return this.options.comparator?this.options.comparator(r,u):r===u||this.options.ignoreCase&&r.toLowerCase()===u.toLowerCase()},removeEmpty:function(r){for(var u=[],i=0;i<r.length;i++)r[i]&&u.push(r[i]);return u},castInput:function(r){return r},tokenize:function(r){return r.split("")},join:function(r){return r.join("")}};function t(a,r,u,i,o){for(var c=0,v=r.length,m=0,d=0;c<v;c++){var p=r[c];if(p.removed){if(p.value=a.join(i.slice(d,d+p.count)),d+=p.count,c&&r[c-1].added){var h=r[c-1];r[c-1]=r[c],r[c]=h;}}else {if(!p.added&&o){var f=u.slice(m,m+p.count);f=f.map(function(T,A){var S=i[d+A];return S.length>T.length?S:T}),p.value=a.join(f);}else p.value=a.join(u.slice(m,m+p.count));m+=p.count,p.added||(d+=p.count);}}var w=r[v-1];return v>1&&typeof w.value=="string"&&(w.added||w.removed)&&a.equals("",w.value)&&(r[v-2].value+=w.value,r.pop()),r}function s(a){return {newPos:a.newPos,components:a.components.slice(0)}}}}),aD=Z({"node_modules/diff/lib/diff/array.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.diffArrays=a,e.arrayDiff=void 0;var n=t(iD());function t(r){return r&&r.__esModule?r:{default:r}}var s=new n.default;e.arrayDiff=s,s.tokenize=function(r){return r.slice()},s.join=s.removeEmpty=function(r){return r};function a(r,u,i){return s.diff(r,u,i)}}}),Ln=Z({"src/document/doc-builders.js"(e,n){re();function t(F){return {type:"concat",parts:F}}function s(F){return {type:"indent",contents:F}}function a(F,l){return {type:"align",contents:l,n:F}}function r(F){let l=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return {type:"group",id:l.id,contents:F,break:Boolean(l.shouldBreak),expandedStates:l.expandedStates}}function u(F){return a(Number.NEGATIVE_INFINITY,F)}function i(F){return a({type:"root"},F)}function o(F){return a(-1,F)}function c(F,l){return r(F[0],Object.assign(Object.assign({},l),{},{expandedStates:F}))}function v(F){return {type:"fill",parts:F}}function m(F,l){let E=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return {type:"if-break",breakContents:F,flatContents:l,groupId:E.groupId}}function d(F,l){return {type:"indent-if-break",contents:F,groupId:l.groupId,negate:l.negate}}function p(F){return {type:"line-suffix",contents:F}}var f={type:"line-suffix-boundary"},h={type:"break-parent"},w={type:"trim"},T={type:"line",hard:!0},A={type:"line",hard:!0,literal:!0},S={type:"line"},B={type:"line",soft:!0},I=t([T,h]),k=t([A,h]),P={type:"cursor",placeholder:Symbol("cursor")};function C(F,l){let E=[];for(let y=0;y<l.length;y++)y!==0&&E.push(F),E.push(l[y]);return t(E)}function D(F,l,E){let y=F;if(l>0){for(let N=0;N<Math.floor(l/E);++N)y=s(y);y=a(l%E,y),y=a(Number.NEGATIVE_INFINITY,y);}return y}function g(F,l){return {type:"label",label:F,contents:l}}n.exports={concat:t,join:C,line:S,softline:B,hardline:I,literalline:k,group:r,conditionalGroup:c,fill:v,lineSuffix:p,lineSuffixBoundary:f,cursor:P,breakParent:h,ifBreak:m,trim:w,indent:s,indentIfBreak:d,align:a,addAlignmentToDoc:D,markAsRoot:i,dedentToRoot:u,dedent:o,hardlineWithoutBreakParent:T,literallineWithoutBreakParent:A,label:g};}}),jn=Z({"src/common/end-of-line.js"(e,n){re();function t(u){let i=u.indexOf("\r");return i>=0?u.charAt(i+1)===`
	`?"crlf":"cr":"lf"}function s(u){switch(u){case"cr":return "\r";case"crlf":return `\r
	`;default:return `
	`}}function a(u,i){let o;switch(i){case`
	`:o=/\n/g;break;case"\r":o=/\r/g;break;case`\r
	`:o=/\r\n/g;break;default:throw new Error('Unexpected "eol" '.concat(JSON.stringify(i),"."))}let c=u.match(o);return c?c.length:0}function r(u){return u.replace(/\r\n?/g,`
	`)}n.exports={guessEndOfLine:t,convertEndOfLineToChars:s,countEndOfLineChars:a,normalizeEndOfLine:r};}}),it=Z({"src/utils/get-last.js"(e,n){re();var t=s=>s[s.length-1];n.exports=t;}});function oD(){let{onlyFirst:e=!1}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(n,e?void 0:"g")}var lD=mt({"node_modules/strip-ansi/node_modules/ansi-regex/index.js"(){re();}});function cD(e){if(typeof e!="string")throw new TypeError("Expected a `string`, got `".concat(typeof e,"`"));return e.replace(oD(),"")}var pD=mt({"node_modules/strip-ansi/index.js"(){re(),lD();}});function fD(e){return Number.isInteger(e)?e>=4352&&(e<=4447||e===9001||e===9002||11904<=e&&e<=12871&&e!==12351||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141):!1}var DD=mt({"node_modules/is-fullwidth-code-point/index.js"(){re();}}),mD=Z({"node_modules/emoji-regex/index.js"(e,n){re(),n.exports=function(){return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g};}}),ha={};Ut(ha,{default:()=>dD});function dD(e){if(typeof e!="string"||e.length===0||(e=cD(e),e.length===0))return 0;e=e.replace((0, va.default)(),"  ");let n=0;for(let t=0;t<e.length;t++){let s=e.codePointAt(t);s<=31||s>=127&&s<=159||s>=768&&s<=879||(s>65535&&t++,n+=fD(s)?2:1);}return n}var va,gD=mt({"node_modules/string-width/index.js"(){re(),pD(),DD(),va=sD(mD());}}),Ca=Z({"src/utils/get-string-width.js"(e,n){re();var t=(gD(),lt(ha)).default,s=/[^\x20-\x7F]/;function a(r){return r?s.test(r)?t(r):r.length:0}n.exports=a;}}),On=Z({"src/document/doc-utils.js"(e,n){re();var t=it(),{literalline:s,join:a}=Ln(),r=l=>Array.isArray(l)||l&&l.type==="concat",u=l=>{if(Array.isArray(l))return l;if(l.type!=="concat"&&l.type!=="fill")throw new Error("Expect doc type to be `concat` or `fill`.");return l.parts},i={};function o(l,E,y,N){let x=[l];for(;x.length>0;){let b=x.pop();if(b===i){y(x.pop());continue}if(y&&x.push(b,i),!E||E(b)!==!1)if(r(b)||b.type==="fill"){let L=u(b);for(let M=L.length,j=M-1;j>=0;--j)x.push(L[j]);}else if(b.type==="if-break")b.flatContents&&x.push(b.flatContents),b.breakContents&&x.push(b.breakContents);else if(b.type==="group"&&b.expandedStates)if(N)for(let L=b.expandedStates.length,M=L-1;M>=0;--M)x.push(b.expandedStates[M]);else x.push(b.contents);else b.contents&&x.push(b.contents);}}function c(l,E){let y=new Map;return N(l);function N(b){if(y.has(b))return y.get(b);let L=x(b);return y.set(b,L),L}function x(b){if(Array.isArray(b))return E(b.map(N));if(b.type==="concat"||b.type==="fill"){let L=b.parts.map(N);return E(Object.assign(Object.assign({},b),{},{parts:L}))}if(b.type==="if-break"){let L=b.breakContents&&N(b.breakContents),M=b.flatContents&&N(b.flatContents);return E(Object.assign(Object.assign({},b),{},{breakContents:L,flatContents:M}))}if(b.type==="group"&&b.expandedStates){let L=b.expandedStates.map(N),M=L[0];return E(Object.assign(Object.assign({},b),{},{contents:M,expandedStates:L}))}if(b.contents){let L=N(b.contents);return E(Object.assign(Object.assign({},b),{},{contents:L}))}return E(b)}}function v(l,E,y){let N=y,x=!1;function b(L){let M=E(L);if(M!==void 0&&(x=!0,N=M),x)return !1}return o(l,b),N}function m(l){if(l.type==="group"&&l.break||l.type==="line"&&l.hard||l.type==="break-parent")return !0}function d(l){return v(l,m,!1)}function p(l){if(l.length>0){let E=t(l);!E.expandedStates&&!E.break&&(E.break="propagated");}return null}function f(l){let E=new Set,y=[];function N(b){if(b.type==="break-parent"&&p(y),b.type==="group"){if(y.push(b),E.has(b))return !1;E.add(b);}}function x(b){b.type==="group"&&y.pop().break&&p(y);}o(l,N,x,!0);}function h(l){return l.type==="line"&&!l.hard?l.soft?"":" ":l.type==="if-break"?l.flatContents||"":l}function w(l){return c(l,h)}var T=(l,E)=>l&&l.type==="line"&&l.hard&&E&&E.type==="break-parent";function A(l){if(!l)return l;if(r(l)||l.type==="fill"){let E=u(l);for(;E.length>1&&T(...E.slice(-2));)E.length-=2;if(E.length>0){let y=A(t(E));E[E.length-1]=y;}return Array.isArray(l)?E:Object.assign(Object.assign({},l),{},{parts:E})}switch(l.type){case"align":case"indent":case"indent-if-break":case"group":case"line-suffix":case"label":{let E=A(l.contents);return Object.assign(Object.assign({},l),{},{contents:E})}case"if-break":{let E=A(l.breakContents),y=A(l.flatContents);return Object.assign(Object.assign({},l),{},{breakContents:E,flatContents:y})}}return l}function S(l){return A(I(l))}function B(l){switch(l.type){case"fill":if(l.parts.every(y=>y===""))return "";break;case"group":if(!l.contents&&!l.id&&!l.break&&!l.expandedStates)return "";if(l.contents.type==="group"&&l.contents.id===l.id&&l.contents.break===l.break&&l.contents.expandedStates===l.expandedStates)return l.contents;break;case"align":case"indent":case"indent-if-break":case"line-suffix":if(!l.contents)return "";break;case"if-break":if(!l.flatContents&&!l.breakContents)return "";break}if(!r(l))return l;let E=[];for(let y of u(l)){if(!y)continue;let[N,...x]=r(y)?u(y):[y];typeof N=="string"&&typeof t(E)=="string"?E[E.length-1]+=N:E.push(N),E.push(...x);}return E.length===0?"":E.length===1?E[0]:Array.isArray(l)?E:Object.assign(Object.assign({},l),{},{parts:E})}function I(l){return c(l,E=>B(E))}function k(l){let E=[],y=l.filter(Boolean);for(;y.length>0;){let N=y.shift();if(!!N){if(r(N)){y.unshift(...u(N));continue}if(E.length>0&&typeof t(E)=="string"&&typeof N=="string"){E[E.length-1]+=N;continue}E.push(N);}}return E}function P(l){return c(l,E=>Array.isArray(E)?k(E):E.parts?Object.assign(Object.assign({},E),{},{parts:k(E.parts)}):E)}function C(l){return c(l,E=>typeof E=="string"&&E.includes(`
	`)?D(E):E)}function D(l){let E=arguments.length>1&&arguments[1]!==void 0?arguments[1]:s;return a(E,l.split(`
	`)).parts}function g(l){if(l.type==="line")return !0}function F(l){return v(l,g,!1)}n.exports={isConcat:r,getDocParts:u,willBreak:d,traverseDoc:o,findInDoc:v,mapDoc:c,propagateBreaks:f,removeLines:w,stripTrailingHardline:S,normalizeParts:k,normalizeDoc:P,cleanDoc:I,replaceTextEndOfLine:D,replaceEndOfLine:C,canBreak:F};}}),yD=Z({"src/document/doc-printer.js"(e,n){re();var{convertEndOfLineToChars:t}=jn(),s=it(),a=Ca(),{fill:r,cursor:u,indent:i}=Ln(),{isConcat:o,getDocParts:c}=On(),v,m=1,d=2;function p(){return {value:"",length:0,queue:[]}}function f(B,I){return w(B,{type:"indent"},I)}function h(B,I,k){return I===Number.NEGATIVE_INFINITY?B.root||p():I<0?w(B,{type:"dedent"},k):I?I.type==="root"?Object.assign(Object.assign({},B),{},{root:B}):w(B,{type:typeof I=="string"?"stringAlign":"numberAlign",n:I},k):B}function w(B,I,k){let P=I.type==="dedent"?B.queue.slice(0,-1):[...B.queue,I],C="",D=0,g=0,F=0;for(let L of P)switch(L.type){case"indent":y(),k.useTabs?l(1):E(k.tabWidth);break;case"stringAlign":y(),C+=L.n,D+=L.n.length;break;case"numberAlign":g+=1,F+=L.n;break;default:throw new Error("Unexpected type '".concat(L.type,"'"))}return x(),Object.assign(Object.assign({},B),{},{value:C,length:D,queue:P});function l(L){C+="	".repeat(L),D+=k.tabWidth*L;}function E(L){C+=" ".repeat(L),D+=L;}function y(){k.useTabs?N():x();}function N(){g>0&&l(g),b();}function x(){F>0&&E(F),b();}function b(){g=0,F=0;}}function T(B){if(B.length===0)return 0;let I=0;for(;B.length>0&&typeof s(B)=="string"&&/^[\t ]*$/.test(s(B));)I+=B.pop().length;if(B.length>0&&typeof s(B)=="string"){let k=s(B).replace(/[\t ]*$/,"");I+=s(B).length-k.length,B[B.length-1]=k;}return I}function A(B,I,k,P,C,D){let g=I.length,F=[B],l=[];for(;k>=0;){if(F.length===0){if(g===0)return !0;F.push(I[g-1]),g--;continue}let[E,y,N]=F.pop();if(typeof N=="string")l.push(N),k-=a(N);else if(o(N)){let x=c(N);for(let b=x.length-1;b>=0;b--)F.push([E,y,x[b]]);}else switch(N.type){case"indent":F.push([f(E,P),y,N.contents]);break;case"align":F.push([h(E,N.n,P),y,N.contents]);break;case"trim":k+=T(l);break;case"group":{if(D&&N.break)return !1;let x=N.break?m:y;F.push([E,x,N.expandedStates&&x===m?s(N.expandedStates):N.contents]),N.id&&(v[N.id]=x);break}case"fill":for(let x=N.parts.length-1;x>=0;x--)F.push([E,y,N.parts[x]]);break;case"if-break":case"indent-if-break":{let x=N.groupId?v[N.groupId]:y;if(x===m){let b=N.type==="if-break"?N.breakContents:N.negate?N.contents:i(N.contents);b&&F.push([E,y,b]);}if(x===d){let b=N.type==="if-break"?N.flatContents:N.negate?i(N.contents):N.contents;b&&F.push([E,y,b]);}break}case"line":switch(y){case d:if(!N.hard){N.soft||(l.push(" "),k-=1);break}return !0;case m:return !0}break;case"line-suffix":C=!0;break;case"line-suffix-boundary":if(C)return !1;break;case"label":F.push([E,y,N.contents]);break}}return !1}function S(B,I){v={};let k=I.printWidth,P=t(I.endOfLine),C=0,D=[[p(),m,B]],g=[],F=!1,l=[];for(;D.length>0;){let[y,N,x]=D.pop();if(typeof x=="string"){let b=P!==`
	`?x.replace(/\n/g,P):x;g.push(b),C+=a(b);}else if(o(x)){let b=c(x);for(let L=b.length-1;L>=0;L--)D.push([y,N,b[L]]);}else switch(x.type){case"cursor":g.push(u.placeholder);break;case"indent":D.push([f(y,I),N,x.contents]);break;case"align":D.push([h(y,x.n,I),N,x.contents]);break;case"trim":C-=T(g);break;case"group":switch(N){case d:if(!F){D.push([y,x.break?m:d,x.contents]);break}case m:{F=!1;let b=[y,d,x.contents],L=k-C,M=l.length>0;if(!x.break&&A(b,D,L,I,M))D.push(b);else if(x.expandedStates){let j=s(x.expandedStates);if(x.break){D.push([y,m,j]);break}else for(let $=1;$<x.expandedStates.length+1;$++)if($>=x.expandedStates.length){D.push([y,m,j]);break}else {let V=x.expandedStates[$],q=[y,d,V];if(A(q,D,L,I,M)){D.push(q);break}}}else D.push([y,m,x.contents]);break}}x.id&&(v[x.id]=s(D)[1]);break;case"fill":{let b=k-C,{parts:L}=x;if(L.length===0)break;let[M,j]=L,$=[y,d,M],V=[y,m,M],q=A($,[],b,I,l.length>0,!0);if(L.length===1){q?D.push($):D.push(V);break}let Y=[y,d,j],H=[y,m,j];if(L.length===2){q?D.push(Y,$):D.push(H,V);break}L.splice(0,2);let R=[y,N,r(L)],Q=L[0];A([y,d,[M,j,Q]],[],b,I,l.length>0,!0)?D.push(R,Y,$):q?D.push(R,H,$):D.push(R,H,V);break}case"if-break":case"indent-if-break":{let b=x.groupId?v[x.groupId]:N;if(b===m){let L=x.type==="if-break"?x.breakContents:x.negate?x.contents:i(x.contents);L&&D.push([y,N,L]);}if(b===d){let L=x.type==="if-break"?x.flatContents:x.negate?i(x.contents):x.contents;L&&D.push([y,N,L]);}break}case"line-suffix":l.push([y,N,x.contents]);break;case"line-suffix-boundary":l.length>0&&D.push([y,N,{type:"line",hard:!0}]);break;case"line":switch(N){case d:if(x.hard)F=!0;else {x.soft||(g.push(" "),C+=1);break}case m:if(l.length>0){D.push([y,N,x],...l.reverse()),l=[];break}x.literal?y.root?(g.push(P,y.root.value),C=y.root.length):(g.push(P),C=0):(C-=T(g),g.push(P+y.value),C=y.length);break}break;case"label":D.push([y,N,x.contents]);break;}D.length===0&&l.length>0&&(D.push(...l.reverse()),l=[]);}let E=g.indexOf(u.placeholder);if(E!==-1){let y=g.indexOf(u.placeholder,E+1),N=g.slice(0,E).join(""),x=g.slice(E+1,y).join(""),b=g.slice(y+1).join("");return {formatted:N+x+b,cursorNodeStart:N.length,cursorNodeText:x}}return {formatted:g.join("")}}n.exports={printDocToString:S};}}),hD=Z({"src/document/doc-debug.js"(e,n){re();var{isConcat:t,getDocParts:s}=On();function a(u){if(!u)return "";if(t(u)){let i=[];for(let o of s(u))if(t(o))i.push(...a(o).parts);else {let c=a(o);c!==""&&i.push(c);}return {type:"concat",parts:i}}return u.type==="if-break"?Object.assign(Object.assign({},u),{},{breakContents:a(u.breakContents),flatContents:a(u.flatContents)}):u.type==="group"?Object.assign(Object.assign({},u),{},{contents:a(u.contents),expandedStates:u.expandedStates&&u.expandedStates.map(a)}):u.type==="fill"?{type:"fill",parts:u.parts.map(a)}:u.contents?Object.assign(Object.assign({},u),{},{contents:a(u.contents)}):u}function r(u){let i=Object.create(null),o=new Set;return c(a(u));function c(m,d,p){if(typeof m=="string")return JSON.stringify(m);if(t(m)){let f=s(m).map(c).filter(Boolean);return f.length===1?f[0]:"[".concat(f.join(", "),"]")}if(m.type==="line"){let f=Array.isArray(p)&&p[d+1]&&p[d+1].type==="break-parent";return m.literal?f?"literalline":"literallineWithoutBreakParent":m.hard?f?"hardline":"hardlineWithoutBreakParent":m.soft?"softline":"line"}if(m.type==="break-parent")return Array.isArray(p)&&p[d-1]&&p[d-1].type==="line"&&p[d-1].hard?void 0:"breakParent";if(m.type==="trim")return "trim";if(m.type==="indent")return "indent("+c(m.contents)+")";if(m.type==="align")return m.n===Number.NEGATIVE_INFINITY?"dedentToRoot("+c(m.contents)+")":m.n<0?"dedent("+c(m.contents)+")":m.n.type==="root"?"markAsRoot("+c(m.contents)+")":"align("+JSON.stringify(m.n)+", "+c(m.contents)+")";if(m.type==="if-break")return "ifBreak("+c(m.breakContents)+(m.flatContents?", "+c(m.flatContents):"")+(m.groupId?(m.flatContents?"":', ""')+", { groupId: ".concat(v(m.groupId)," }"):"")+")";if(m.type==="indent-if-break"){let f=[];m.negate&&f.push("negate: true"),m.groupId&&f.push("groupId: ".concat(v(m.groupId)));let h=f.length>0?", { ".concat(f.join(", ")," }"):"";return "indentIfBreak(".concat(c(m.contents)).concat(h,")")}if(m.type==="group"){let f=[];m.break&&m.break!=="propagated"&&f.push("shouldBreak: true"),m.id&&f.push("id: ".concat(v(m.id)));let h=f.length>0?", { ".concat(f.join(", ")," }"):"";return m.expandedStates?"conditionalGroup([".concat(m.expandedStates.map(w=>c(w)).join(","),"]").concat(h,")"):"group(".concat(c(m.contents)).concat(h,")")}if(m.type==="fill")return "fill([".concat(m.parts.map(f=>c(f)).join(", "),"])");if(m.type==="line-suffix")return "lineSuffix("+c(m.contents)+")";if(m.type==="line-suffix-boundary")return "lineSuffixBoundary";if(m.type==="label")return "label(".concat(JSON.stringify(m.label),", ").concat(c(m.contents),")");throw new Error("Unknown doc type "+m.type)}function v(m){if(typeof m!="symbol")return JSON.stringify(String(m));if(m in i)return i[m];let d=String(m).slice(7,-1)||"symbol";for(let p=0;;p++){let f=d+(p>0?" #".concat(p):"");if(!o.has(f))return o.add(f),i[m]="Symbol.for(".concat(JSON.stringify(f),")")}}}n.exports={printDocToDebug:r};}}),Oe=Z({"src/document/index.js"(e,n){re(),n.exports={builders:Ln(),printer:yD(),utils:On(),debug:hD()};}}),Ea={};Ut(Ea,{default:()=>vD});function vD(e){if(typeof e!="string")throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var CD=mt({"node_modules/escape-string-regexp/index.js"(){re();}}),Fa=Z({"node_modules/semver/internal/debug.js"(e,n){re();var t=typeof Tt=="object"&&Tt.env&&Tt.env.NODE_DEBUG&&/\bsemver\b/i.test(Tt.env.NODE_DEBUG)?function(){for(var s=arguments.length,a=new Array(s),r=0;r<s;r++)a[r]=arguments[r];return console.error("SEMVER",...a)}:()=>{};n.exports=t;}}),Aa=Z({"node_modules/semver/internal/constants.js"(e,n){re();var t="2.0.0",s=256,a=Number.MAX_SAFE_INTEGER||9007199254740991,r=16;n.exports={SEMVER_SPEC_VERSION:t,MAX_LENGTH:s,MAX_SAFE_INTEGER:a,MAX_SAFE_COMPONENT_LENGTH:r};}}),ED=Z({"node_modules/semver/internal/re.js"(e,n){re();var{MAX_SAFE_COMPONENT_LENGTH:t}=Aa(),s=Fa();e=n.exports={};var a=e.re=[],r=e.src=[],u=e.t={},i=0,o=(c,v,m)=>{let d=i++;s(c,d,v),u[c]=d,r[d]=v,a[d]=new RegExp(v,m?"g":void 0);};o("NUMERICIDENTIFIER","0|[1-9]\\d*"),o("NUMERICIDENTIFIERLOOSE","[0-9]+"),o("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),o("MAINVERSION","(".concat(r[u.NUMERICIDENTIFIER],")\\.(").concat(r[u.NUMERICIDENTIFIER],")\\.(").concat(r[u.NUMERICIDENTIFIER],")")),o("MAINVERSIONLOOSE","(".concat(r[u.NUMERICIDENTIFIERLOOSE],")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE],")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE],")")),o("PRERELEASEIDENTIFIER","(?:".concat(r[u.NUMERICIDENTIFIER],"|").concat(r[u.NONNUMERICIDENTIFIER],")")),o("PRERELEASEIDENTIFIERLOOSE","(?:".concat(r[u.NUMERICIDENTIFIERLOOSE],"|").concat(r[u.NONNUMERICIDENTIFIER],")")),o("PRERELEASE","(?:-(".concat(r[u.PRERELEASEIDENTIFIER],"(?:\\.").concat(r[u.PRERELEASEIDENTIFIER],")*))")),o("PRERELEASELOOSE","(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE],"(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE],")*))")),o("BUILDIDENTIFIER","[0-9A-Za-z-]+"),o("BUILD","(?:\\+(".concat(r[u.BUILDIDENTIFIER],"(?:\\.").concat(r[u.BUILDIDENTIFIER],")*))")),o("FULLPLAIN","v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE],"?").concat(r[u.BUILD],"?")),o("FULL","^".concat(r[u.FULLPLAIN],"$")),o("LOOSEPLAIN","[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE],"?").concat(r[u.BUILD],"?")),o("LOOSE","^".concat(r[u.LOOSEPLAIN],"$")),o("GTLT","((?:<|>)?=?)"),o("XRANGEIDENTIFIERLOOSE","".concat(r[u.NUMERICIDENTIFIERLOOSE],"|x|X|\\*")),o("XRANGEIDENTIFIER","".concat(r[u.NUMERICIDENTIFIER],"|x|X|\\*")),o("XRANGEPLAIN","[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER],")(?:\\.(").concat(r[u.XRANGEIDENTIFIER],")(?:\\.(").concat(r[u.XRANGEIDENTIFIER],")(?:").concat(r[u.PRERELEASE],")?").concat(r[u.BUILD],"?)?)?")),o("XRANGEPLAINLOOSE","[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE],")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE],")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE],")(?:").concat(r[u.PRERELEASELOOSE],")?").concat(r[u.BUILD],"?)?)?")),o("XRANGE","^".concat(r[u.GTLT],"\\s*").concat(r[u.XRANGEPLAIN],"$")),o("XRANGELOOSE","^".concat(r[u.GTLT],"\\s*").concat(r[u.XRANGEPLAINLOOSE],"$")),o("COERCE","(^|[^\\d])(\\d{1,".concat(t,"})(?:\\.(\\d{1,").concat(t,"}))?(?:\\.(\\d{1,").concat(t,"}))?(?:$|[^\\d])")),o("COERCERTL",r[u.COERCE],!0),o("LONETILDE","(?:~>?)"),o("TILDETRIM","(\\s*)".concat(r[u.LONETILDE],"\\s+"),!0),e.tildeTrimReplace="$1~",o("TILDE","^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN],"$")),o("TILDELOOSE","^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE],"$")),o("LONECARET","(?:\\^)"),o("CARETTRIM","(\\s*)".concat(r[u.LONECARET],"\\s+"),!0),e.caretTrimReplace="$1^",o("CARET","^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN],"$")),o("CARETLOOSE","^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE],"$")),o("COMPARATORLOOSE","^".concat(r[u.GTLT],"\\s*(").concat(r[u.LOOSEPLAIN],")$|^$")),o("COMPARATOR","^".concat(r[u.GTLT],"\\s*(").concat(r[u.FULLPLAIN],")$|^$")),o("COMPARATORTRIM","(\\s*)".concat(r[u.GTLT],"\\s*(").concat(r[u.LOOSEPLAIN],"|").concat(r[u.XRANGEPLAIN],")"),!0),e.comparatorTrimReplace="$1$2$3",o("HYPHENRANGE","^\\s*(".concat(r[u.XRANGEPLAIN],")\\s+-\\s+(").concat(r[u.XRANGEPLAIN],")\\s*$")),o("HYPHENRANGELOOSE","^\\s*(".concat(r[u.XRANGEPLAINLOOSE],")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE],")\\s*$")),o("STAR","(<|>)?=?\\s*\\*"),o("GTE0","^\\s*>=\\s*0\\.0\\.0\\s*$"),o("GTE0PRE","^\\s*>=\\s*0\\.0\\.0-0\\s*$");}}),FD=Z({"node_modules/semver/internal/parse-options.js"(e,n){re();var t=["includePrerelease","loose","rtl"],s=a=>a?typeof a!="object"?{loose:!0}:t.filter(r=>a[r]).reduce((r,u)=>(r[u]=!0,r),{}):{};n.exports=s;}}),AD=Z({"node_modules/semver/internal/identifiers.js"(e,n){re();var t=/^[0-9]+$/,s=(r,u)=>{let i=t.test(r),o=t.test(u);return i&&o&&(r=+r,u=+u),r===u?0:i&&!o?-1:o&&!i?1:r<u?-1:1},a=(r,u)=>s(u,r);n.exports={compareIdentifiers:s,rcompareIdentifiers:a};}}),SD=Z({"node_modules/semver/classes/semver.js"(e,n){re();var t=Fa(),{MAX_LENGTH:s,MAX_SAFE_INTEGER:a}=Aa(),{re:r,t:u}=ED(),i=FD(),{compareIdentifiers:o}=AD(),c=class{constructor(v,m){if(m=i(m),v instanceof c){if(v.loose===!!m.loose&&v.includePrerelease===!!m.includePrerelease)return v;v=v.version;}else if(typeof v!="string")throw new TypeError("Invalid Version: ".concat(v));if(v.length>s)throw new TypeError("version is longer than ".concat(s," characters"));t("SemVer",v,m),this.options=m,this.loose=!!m.loose,this.includePrerelease=!!m.includePrerelease;let d=v.trim().match(m.loose?r[u.LOOSE]:r[u.FULL]);if(!d)throw new TypeError("Invalid Version: ".concat(v));if(this.raw=v,this.major=+d[1],this.minor=+d[2],this.patch=+d[3],this.major>a||this.major<0)throw new TypeError("Invalid major version");if(this.minor>a||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>a||this.patch<0)throw new TypeError("Invalid patch version");d[4]?this.prerelease=d[4].split(".").map(p=>{if(/^[0-9]+$/.test(p)){let f=+p;if(f>=0&&f<a)return f}return p}):this.prerelease=[],this.build=d[5]?d[5].split("."):[],this.format();}format(){return this.version="".concat(this.major,".").concat(this.minor,".").concat(this.patch),this.prerelease.length&&(this.version+="-".concat(this.prerelease.join("."))),this.version}toString(){return this.version}compare(v){if(t("SemVer.compare",this.version,this.options,v),!(v instanceof c)){if(typeof v=="string"&&v===this.version)return 0;v=new c(v,this.options);}return v.version===this.version?0:this.compareMain(v)||this.comparePre(v)}compareMain(v){return v instanceof c||(v=new c(v,this.options)),o(this.major,v.major)||o(this.minor,v.minor)||o(this.patch,v.patch)}comparePre(v){if(v instanceof c||(v=new c(v,this.options)),this.prerelease.length&&!v.prerelease.length)return -1;if(!this.prerelease.length&&v.prerelease.length)return 1;if(!this.prerelease.length&&!v.prerelease.length)return 0;let m=0;do{let d=this.prerelease[m],p=v.prerelease[m];if(t("prerelease compare",m,d,p),d===void 0&&p===void 0)return 0;if(p===void 0)return 1;if(d===void 0)return -1;if(d===p)continue;return o(d,p)}while(++m)}compareBuild(v){v instanceof c||(v=new c(v,this.options));let m=0;do{let d=this.build[m],p=v.build[m];if(t("prerelease compare",m,d,p),d===void 0&&p===void 0)return 0;if(p===void 0)return 1;if(d===void 0)return -1;if(d===p)continue;return o(d,p)}while(++m)}inc(v,m){switch(v){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",m);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",m);break;case"prepatch":this.prerelease.length=0,this.inc("patch",m),this.inc("pre",m);break;case"prerelease":this.prerelease.length===0&&this.inc("patch",m),this.inc("pre",m);break;case"major":(this.minor!==0||this.patch!==0||this.prerelease.length===0)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":(this.patch!==0||this.prerelease.length===0)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case"pre":if(this.prerelease.length===0)this.prerelease=[0];else {let d=this.prerelease.length;for(;--d>=0;)typeof this.prerelease[d]=="number"&&(this.prerelease[d]++,d=-2);d===-1&&this.prerelease.push(0);}m&&(o(this.prerelease[0],m)===0?isNaN(this.prerelease[1])&&(this.prerelease=[m,0]):this.prerelease=[m,0]);break;default:throw new Error("invalid increment argument: ".concat(v))}return this.format(),this.raw=this.version,this}};n.exports=c;}}),qn=Z({"node_modules/semver/functions/compare.js"(e,n){re();var t=SD(),s=(a,r,u)=>new t(a,u).compare(new t(r,u));n.exports=s;}}),xD=Z({"node_modules/semver/functions/lt.js"(e,n){re();var t=qn(),s=(a,r,u)=>t(a,r,u)<0;n.exports=s;}}),bD=Z({"node_modules/semver/functions/gte.js"(e,n){re();var t=qn(),s=(a,r,u)=>t(a,r,u)>=0;n.exports=s;}}),TD=Z({"src/utils/arrayify.js"(e,n){re(),n.exports=(t,s)=>Object.entries(t).map(a=>{let[r,u]=a;return Object.assign({[s]:r},u)});}}),BD=Z({"node_modules/outdent/lib/index.js"(e,n){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.outdent=void 0;function t(){for(var A=[],S=0;S<arguments.length;S++)A[S]=arguments[S];}function s(){return typeof WeakMap<"u"?new WeakMap:a()}function a(){return {add:t,delete:t,get:t,set:t,has:function(A){return !1}}}var r=Object.prototype.hasOwnProperty,u=function(A,S){return r.call(A,S)};function i(A,S){for(var B in S)u(S,B)&&(A[B]=S[B]);return A}var o=/^[ \t]*(?:\r\n|\r|\n)/,c=/(?:\r\n|\r|\n)[ \t]*$/,v=/^(?:[\r\n]|$)/,m=/(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,d=/^[ \t]*[\r\n][ \t\r\n]*$/;function p(A,S,B){var I=0,k=A[0].match(m);k&&(I=k[1].length);var P="(\\r\\n|\\r|\\n).{0,"+I+"}",C=new RegExp(P,"g");S&&(A=A.slice(1));var D=B.newline,g=B.trimLeadingNewline,F=B.trimTrailingNewline,l=typeof D=="string",E=A.length,y=A.map(function(N,x){return N=N.replace(C,"$1"),x===0&&g&&(N=N.replace(o,"")),x===E-1&&F&&(N=N.replace(c,"")),l&&(N=N.replace(/\r\n|\n|\r/g,function(b){return D})),N});return y}function f(A,S){for(var B="",I=0,k=A.length;I<k;I++)B+=A[I],I<k-1&&(B+=S[I]);return B}function h(A){return u(A,"raw")&&u(A,"length")}function w(A){var S=s(),B=s();function I(P){for(var C=[],D=1;D<arguments.length;D++)C[D-1]=arguments[D];if(h(P)){var g=P,F=(C[0]===I||C[0]===T)&&d.test(g[0])&&v.test(g[1]),l=F?B:S,E=l.get(g);if(E||(E=p(g,F,A),l.set(g,E)),C.length===0)return E[0];var y=f(E,F?C.slice(1):C);return y}else return w(i(i({},A),P||{}))}var k=i(I,{string:function(P){return p([P],!1,A)[0]}});return k}var T=w({trimLeadingNewline:!0,trimTrailingNewline:!0});if(e.outdent=T,e.default=T,typeof n<"u")try{n.exports=T,Object.defineProperty(T,"__esModule",{value:!0}),T.default=T,T.outdent=T;}catch{}}}),ND=Z({"src/main/core-options.js"(e,n){re();var{outdent:t}=BD(),s="Config",a="Editor",r="Format",u="Other",i="Output",o="Global",c="Special",v={cursorOffset:{since:"1.4.0",category:c,type:"int",default:-1,range:{start:-1,end:Number.POSITIVE_INFINITY,step:1},description:t(sa||(sa=Pt([`
	      Print (to stderr) where a cursor at the given position would move to after formatting.
	      This option cannot be used with --range-start and --range-end.
	    `]))),cliCategory:a},endOfLine:{since:"1.15.0",category:o,type:"choice",default:[{since:"1.15.0",value:"auto"},{since:"2.0.0",value:"lf"}],description:"Which end of line characters to apply.",choices:[{value:"lf",description:"Line Feed only (\\n), common on Linux and macOS as well as inside git repos"},{value:"crlf",description:"Carriage Return + Line Feed characters (\\r\\n), common on Windows"},{value:"cr",description:"Carriage Return character only (\\r), used very rarely"},{value:"auto",description:t(ia||(ia=Pt([`
	          Maintain existing
	          (mixed values within one file are normalised by looking at what's used after the first line)
	        `])))}]},filepath:{since:"1.4.0",category:c,type:"path",description:"Specify the input filepath. This will be used to do parser inference.",cliName:"stdin-filepath",cliCategory:u,cliDescription:"Path to the file to pretend that stdin comes from."},insertPragma:{since:"1.8.0",category:c,type:"boolean",default:!1,description:"Insert @format pragma into file's first docblock comment.",cliCategory:u},parser:{since:"0.0.10",category:o,type:"choice",default:[{since:"0.0.10",value:"babylon"},{since:"1.13.0",value:void 0}],description:"Which parser to use.",exception:m=>typeof m=="string"||typeof m=="function",choices:[{value:"flow",description:"Flow"},{value:"babel",since:"1.16.0",description:"JavaScript"},{value:"babel-flow",since:"1.16.0",description:"Flow"},{value:"babel-ts",since:"2.0.0",description:"TypeScript"},{value:"typescript",since:"1.4.0",description:"TypeScript"},{value:"acorn",since:"2.6.0",description:"JavaScript"},{value:"espree",since:"2.2.0",description:"JavaScript"},{value:"meriyah",since:"2.2.0",description:"JavaScript"},{value:"css",since:"1.7.1",description:"CSS"},{value:"less",since:"1.7.1",description:"Less"},{value:"scss",since:"1.7.1",description:"SCSS"},{value:"json",since:"1.5.0",description:"JSON"},{value:"json5",since:"1.13.0",description:"JSON5"},{value:"json-stringify",since:"1.13.0",description:"JSON.stringify"},{value:"graphql",since:"1.5.0",description:"GraphQL"},{value:"markdown",since:"1.8.0",description:"Markdown"},{value:"mdx",since:"1.15.0",description:"MDX"},{value:"vue",since:"1.10.0",description:"Vue"},{value:"yaml",since:"1.14.0",description:"YAML"},{value:"glimmer",since:"2.3.0",description:"Ember / Handlebars"},{value:"html",since:"1.15.0",description:"HTML"},{value:"angular",since:"1.15.0",description:"Angular"},{value:"lwc",since:"1.17.0",description:"Lightning Web Components"}]},plugins:{since:"1.10.0",type:"path",array:!0,default:[{value:[]}],category:o,description:"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",exception:m=>typeof m=="string"||typeof m=="object",cliName:"plugin",cliCategory:s},pluginSearchDirs:{since:"1.13.0",type:"path",array:!0,default:[{value:[]}],category:o,description:t(aa||(aa=Pt([`
	      Custom directory that contains prettier plugins in node_modules subdirectory.
	      Overrides default behavior when plugins are searched relatively to the location of Prettier.
	      Multiple values are accepted.
	    `]))),exception:m=>typeof m=="string"||typeof m=="object",cliName:"plugin-search-dir",cliCategory:s},printWidth:{since:"0.0.0",category:o,type:"int",default:80,description:"The line length where Prettier will try wrap.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},rangeEnd:{since:"1.4.0",category:c,type:"int",default:Number.POSITIVE_INFINITY,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:t(oa||(oa=Pt([`
	      Format code ending at a given character offset (exclusive).
	      The range will extend forwards to the end of the selected statement.
	      This option cannot be used with --cursor-offset.
	    `]))),cliCategory:a},rangeStart:{since:"1.4.0",category:c,type:"int",default:0,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:t(la||(la=Pt([`
	      Format code starting at a given character offset.
	      The range will extend backwards to the start of the first line containing the selected statement.
	      This option cannot be used with --cursor-offset.
	    `]))),cliCategory:a},requirePragma:{since:"1.7.0",category:c,type:"boolean",default:!1,description:t(ca||(ca=Pt([`
	      Require either '@prettier' or '@format' to be present in the file's first docblock comment
	      in order for it to be formatted.
	    `]))),cliCategory:u},tabWidth:{type:"int",category:o,default:2,description:"Number of spaces per indentation level.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},useTabs:{since:"1.0.0",category:o,type:"boolean",default:!1,description:"Indent with tabs instead of spaces."},embeddedLanguageFormatting:{since:"2.1.0",category:o,type:"choice",default:[{since:"2.1.0",value:"auto"}],description:"Control how Prettier formats quoted code embedded in the file.",choices:[{value:"auto",description:"Format embedded code if Prettier can automatically identify it."},{value:"off",description:"Never automatically format embedded code."}]}};n.exports={CATEGORY_CONFIG:s,CATEGORY_EDITOR:a,CATEGORY_FORMAT:r,CATEGORY_OTHER:u,CATEGORY_OUTPUT:i,CATEGORY_GLOBAL:o,CATEGORY_SPECIAL:c,options:v};}}),Mn=Z({"src/main/support.js"(e,n){re();var t={compare:qn(),lt:xD(),gte:bD()},s=TD(),a=ya().version,r=ND().options;function u(){let{plugins:o=[],showUnreleased:c=!1,showDeprecated:v=!1,showInternal:m=!1}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},d=a.split("-",1)[0],p=o.flatMap(A=>A.languages||[]).filter(h),f=s(Object.assign({},...o.map(A=>{let{options:S}=A;return S}),r),"name").filter(A=>h(A)&&w(A)).sort((A,S)=>A.name===S.name?0:A.name<S.name?-1:1).map(T).map(A=>{A=Object.assign({},A),Array.isArray(A.default)&&(A.default=A.default.length===1?A.default[0].value:A.default.filter(h).sort((B,I)=>t.compare(I.since,B.since))[0].value),Array.isArray(A.choices)&&(A.choices=A.choices.filter(B=>h(B)&&w(B)),A.name==="parser"&&i(A,p,o));let S=Object.fromEntries(o.filter(B=>B.defaultOptions&&B.defaultOptions[A.name]!==void 0).map(B=>[B.name,B.defaultOptions[A.name]]));return Object.assign(Object.assign({},A),{},{pluginDefaults:S})});return {languages:p,options:f};function h(A){return c||!("since"in A)||A.since&&t.gte(d,A.since)}function w(A){return v||!("deprecated"in A)||A.deprecated&&t.lt(d,A.deprecated)}function T(A){if(m)return A;return kn(A,Yf)}}function i(o,c,v){let m=new Set(o.choices.map(d=>d.value));for(let d of c)if(d.parsers){for(let p of d.parsers)if(!m.has(p)){m.add(p);let f=v.find(w=>w.parsers&&w.parsers[p]),h=d.name;f&&f.name&&(h+=" (plugin: ".concat(f.name,")")),o.choices.push({value:p,description:h});}}}n.exports={getSupportInfo:u};}}),Rn=Z({"src/utils/is-non-empty-array.js"(e,n){re();function t(s){return Array.isArray(s)&&s.length>0}n.exports=t;}}),Nr=Z({"src/utils/text/skip.js"(e,n){re();function t(i){return (o,c,v)=>{let m=v&&v.backwards;if(c===!1)return !1;let{length:d}=o,p=c;for(;p>=0&&p<d;){let f=o.charAt(p);if(i instanceof RegExp){if(!i.test(f))return p}else if(!i.includes(f))return p;m?p--:p++;}return p===-1||p===d?p:!1}}var s=t(/\s/),a=t(" 	"),r=t(",; 	"),u=t(/[^\n\r]/);n.exports={skipWhitespace:s,skipSpaces:a,skipToLineEnd:r,skipEverythingButNewLine:u};}}),Sa=Z({"src/utils/text/skip-inline-comment.js"(e,n){re();function t(s,a){if(a===!1)return !1;if(s.charAt(a)==="/"&&s.charAt(a+1)==="*"){for(let r=a+2;r<s.length;++r)if(s.charAt(r)==="*"&&s.charAt(r+1)==="/")return r+2}return a}n.exports=t;}}),xa=Z({"src/utils/text/skip-trailing-comment.js"(e,n){re();var{skipEverythingButNewLine:t}=Nr();function s(a,r){return r===!1?!1:a.charAt(r)==="/"&&a.charAt(r+1)==="/"?t(a,r):r}n.exports=s;}}),ba=Z({"src/utils/text/skip-newline.js"(e,n){re();function t(s,a,r){let u=r&&r.backwards;if(a===!1)return !1;let i=s.charAt(a);if(u){if(s.charAt(a-1)==="\r"&&i===`
	`)return a-2;if(i===`
	`||i==="\r"||i==="\u2028"||i==="\u2029")return a-1}else {if(i==="\r"&&s.charAt(a+1)===`
	`)return a+2;if(i===`
	`||i==="\r"||i==="\u2028"||i==="\u2029")return a+1}return a}n.exports=t;}}),wD=Z({"src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e,n){re();var t=Sa(),s=ba(),a=xa(),{skipSpaces:r}=Nr();function u(i,o){let c=null,v=o;for(;v!==c;)c=v,v=r(i,v),v=t(i,v),v=a(i,v),v=s(i,v);return v}n.exports=u;}}),Ue=Z({"src/common/util.js"(e,n){re();var{default:t}=(CD(),lt(Ea)),s=it(),{getSupportInfo:a}=Mn(),r=Rn(),u=Ca(),{skipWhitespace:i,skipSpaces:o,skipToLineEnd:c,skipEverythingButNewLine:v}=Nr(),m=Sa(),d=xa(),p=ba(),f=wD(),h=H=>H[H.length-2];function w(H){return (R,Q,ee)=>{let te=ee&&ee.backwards;if(Q===!1)return !1;let{length:oe}=R,W=Q;for(;W>=0&&W<oe;){let X=R.charAt(W);if(H instanceof RegExp){if(!H.test(X))return W}else if(!H.includes(X))return W;te?W--:W++;}return W===-1||W===oe?W:!1}}function T(H,R){let Q=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},ee=o(H,Q.backwards?R-1:R,Q),te=p(H,ee,Q);return ee!==te}function A(H,R,Q){for(let ee=R;ee<Q;++ee)if(H.charAt(ee)===`
	`)return !0;return !1}function S(H,R,Q){let ee=Q(R)-1;ee=o(H,ee,{backwards:!0}),ee=p(H,ee,{backwards:!0}),ee=o(H,ee,{backwards:!0});let te=p(H,ee,{backwards:!0});return ee!==te}function B(H,R){let Q=null,ee=R;for(;ee!==Q;)Q=ee,ee=c(H,ee),ee=m(H,ee),ee=o(H,ee);return ee=d(H,ee),ee=p(H,ee),ee!==!1&&T(H,ee)}function I(H,R,Q){return B(H,Q(R))}function k(H,R,Q){return f(H,Q(R))}function P(H,R,Q){return H.charAt(k(H,R,Q))}function C(H,R){let Q=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return o(H,Q.backwards?R-1:R,Q)!==R}function D(H,R){let Q=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,ee=0;for(let te=Q;te<H.length;++te)H[te]==="	"?ee=ee+R-ee%R:ee++;return ee}function g(H,R){let Q=H.lastIndexOf(`
	`);return Q===-1?0:D(H.slice(Q+1).match(/^[\t ]*/)[0],R)}function F(H,R){let Q={quote:'"',regex:/"/g,escaped:"&quot;"},ee={quote:"'",regex:/'/g,escaped:"&apos;"},te=R==="'"?ee:Q,oe=te===ee?Q:ee,W=te;if(H.includes(te.quote)||H.includes(oe.quote)){let X=(H.match(te.regex)||[]).length,ue=(H.match(oe.regex)||[]).length;W=X>ue?oe:te;}return W}function l(H,R){let Q=H.slice(1,-1),ee=R.parser==="json"||R.parser==="json5"&&R.quoteProps==="preserve"&&!R.singleQuote?'"':R.__isInHtmlAttribute?"'":F(Q,R.singleQuote?"'":'"').quote;return E(Q,ee,!(R.parser==="css"||R.parser==="less"||R.parser==="scss"||R.__embeddedInHtml))}function E(H,R,Q){let ee=R==='"'?"'":'"',te=/\\(.)|(["'])/gs,oe=H.replace(te,(W,X,ue)=>X===ee?X:ue===R?"\\"+ue:ue||(Q&&/^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X)?X:"\\"+X));return R+oe+R}function y(H){return H.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/,"$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/,"$1").replace(/^([+-])?\./,"$10.").replace(/(\.\d+?)0+(?=e|$)/,"$1").replace(/\.(?=e|$)/,"")}function N(H,R){let Q=H.match(new RegExp("(".concat(t(R),")+"),"g"));return Q===null?0:Q.reduce((ee,te)=>Math.max(ee,te.length/R.length),0)}function x(H,R){let Q=H.match(new RegExp("(".concat(t(R),")+"),"g"));if(Q===null)return 0;let ee=new Map,te=0;for(let oe of Q){let W=oe.length/R.length;ee.set(W,!0),W>te&&(te=W);}for(let oe=1;oe<te;oe++)if(!ee.get(oe))return oe;return te+1}function b(H,R){(H.comments||(H.comments=[])).push(R),R.printed=!1,R.nodeDescription=Y(H);}function L(H,R){R.leading=!0,R.trailing=!1,b(H,R);}function M(H,R,Q){R.leading=!1,R.trailing=!1,Q&&(R.marker=Q),b(H,R);}function j(H,R){R.leading=!1,R.trailing=!0,b(H,R);}function $(H,R){let{languages:Q}=a({plugins:R.plugins}),ee=Q.find(te=>{let{name:oe}=te;return oe.toLowerCase()===H})||Q.find(te=>{let{aliases:oe}=te;return Array.isArray(oe)&&oe.includes(H)})||Q.find(te=>{let{extensions:oe}=te;return Array.isArray(oe)&&oe.includes(".".concat(H))});return ee&&ee.parsers[0]}function V(H){return H&&H.type==="front-matter"}function q(H){let R=new WeakMap;return function(Q){return R.has(Q)||R.set(Q,Symbol(H)),R.get(Q)}}function Y(H){let R=H.type||H.kind||"(unknown type)",Q=String(H.name||H.id&&(typeof H.id=="object"?H.id.name:H.id)||H.key&&(typeof H.key=="object"?H.key.name:H.key)||H.value&&(typeof H.value=="object"?"":String(H.value))||H.operator||"");return Q.length>20&&(Q=Q.slice(0,19)+"\u2026"),R+(Q?" "+Q:"")}n.exports={inferParserByLanguage:$,getStringWidth:u,getMaxContinuousCount:N,getMinNotPresentContinuousCount:x,getPenultimate:h,getLast:s,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:f,getNextNonSpaceNonCommentCharacterIndex:k,getNextNonSpaceNonCommentCharacter:P,skip:w,skipWhitespace:i,skipSpaces:o,skipToLineEnd:c,skipEverythingButNewLine:v,skipInlineComment:m,skipTrailingComment:d,skipNewline:p,isNextLineEmptyAfterIndex:B,isNextLineEmpty:I,isPreviousLineEmpty:S,hasNewline:T,hasNewlineInRange:A,hasSpaces:C,getAlignmentSize:D,getIndentSize:g,getPreferredQuote:F,printString:l,printNumber:y,makeString:E,addLeadingComment:L,addDanglingComment:M,addTrailingComment:j,isFrontMatterNode:V,isNonEmptyArray:r,createGroupIdMapper:q};}}),Ta={};Ut(Ta,{basename:()=>Pa,default:()=>Ia,delimiter:()=>Bn,dirname:()=>_a,extname:()=>ka,isAbsolute:()=>Wn,join:()=>Na,normalize:()=>Vn,relative:()=>wa,resolve:()=>Tr,sep:()=>Tn});function Ba(e,n){for(var t=0,s=e.length-1;s>=0;s--){var a=e[s];a==="."?e.splice(s,1):a===".."?(e.splice(s,1),t++):t&&(e.splice(s,1),t--);}if(n)for(;t--;t)e.unshift("..");return e}function Tr(){for(var e="",n=!1,t=arguments.length-1;t>=-1&&!n;t--){var s=t>=0?arguments[t]:"/";if(typeof s!="string")throw new TypeError("Arguments to path.resolve must be strings");if(!s)continue;e=s+"/"+e,n=s.charAt(0)==="/";}return e=Ba($n(e.split("/"),function(a){return !!a}),!n).join("/"),(n?"/":"")+e||"."}function Vn(e){var n=Wn(e),t=La(e,-1)==="/";return e=Ba($n(e.split("/"),function(s){return !!s}),!n).join("/"),!e&&!n&&(e="."),e&&t&&(e+="/"),(n?"/":"")+e}function Wn(e){return e.charAt(0)==="/"}function Na(){var e=Array.prototype.slice.call(arguments,0);return Vn($n(e,function(n,t){if(typeof n!="string")throw new TypeError("Arguments to path.join must be strings");return n}).join("/"))}function wa(e,n){e=Tr(e).substr(1),n=Tr(n).substr(1);function t(c){for(var v=0;v<c.length&&c[v]==="";v++);for(var m=c.length-1;m>=0&&c[m]==="";m--);return v>m?[]:c.slice(v,m-v+1)}for(var s=t(e.split("/")),a=t(n.split("/")),r=Math.min(s.length,a.length),u=r,i=0;i<r;i++)if(s[i]!==a[i]){u=i;break}for(var o=[],i=u;i<s.length;i++)o.push("..");return o=o.concat(a.slice(u)),o.join("/")}function _a(e){var n=wr(e),t=n[0],s=n[1];return !t&&!s?".":(s&&(s=s.substr(0,s.length-1)),t+s)}function Pa(e,n){var t=wr(e)[2];return n&&t.substr(-1*n.length)===n&&(t=t.substr(0,t.length-n.length)),t}function ka(e){return wr(e)[3]}function $n(e,n){if(e.filter)return e.filter(n);for(var t=[],s=0;s<e.length;s++)n(e[s],s,e)&&t.push(e[s]);return t}var Da,wr,Tn,Bn,Ia,La,_D=mt({"node-modules-polyfills:path"(){re(),Da=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,wr=function(e){return Da.exec(e).slice(1)},Tn="/",Bn=":",Ia={extname:ka,basename:Pa,dirname:_a,sep:Tn,delimiter:Bn,relative:wa,join:Na,isAbsolute:Wn,normalize:Vn,resolve:Tr},La="ab".substr(-1)==="b"?function(e,n,t){return e.substr(n,t)}:function(e,n,t){return n<0&&(n=e.length+n),e.substr(n,t)};}}),PD=Z({"node-modules-polyfills-commonjs:path"(e,n){re();var t=(_D(),lt(Ta));if(t&&t.default){n.exports=t.default;for(let s in t)n.exports[s]=t[s];}else t&&(n.exports=t);}}),zt=Z({"src/common/errors.js"(e,n){re();var t=class extends Error{},s=class extends Error{},a=class extends Error{},r=class extends Error{};n.exports={ConfigError:t,DebugError:s,UndefinedParserError:a,ArgExpansionBailout:r};}}),dt={};Ut(dt,{__assign:()=>br,__asyncDelegator:()=>GD,__asyncGenerator:()=>HD,__asyncValues:()=>JD,__await:()=>Jt,__awaiter:()=>qD,__classPrivateFieldGet:()=>KD,__classPrivateFieldSet:()=>YD,__createBinding:()=>RD,__decorate:()=>LD,__exportStar:()=>VD,__extends:()=>kD,__generator:()=>MD,__importDefault:()=>XD,__importStar:()=>zD,__makeTemplateObject:()=>UD,__metadata:()=>OD,__param:()=>jD,__read:()=>ja,__rest:()=>ID,__spread:()=>WD,__spreadArrays:()=>$D,__values:()=>Nn});function kD(e,n){xr(e,n);function t(){this.constructor=e;}e.prototype=n===null?Object.create(n):(t.prototype=n.prototype,new t);}function ID(e,n){var t={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&n.indexOf(s)<0&&(t[s]=e[s]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,s=Object.getOwnPropertySymbols(e);a<s.length;a++)n.indexOf(s[a])<0&&Object.prototype.propertyIsEnumerable.call(e,s[a])&&(t[s[a]]=e[s[a]]);return t}function LD(e,n,t,s){var a=arguments.length,r=a<3?n:s===null?s=Object.getOwnPropertyDescriptor(n,t):s,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")r=Reflect.decorate(e,n,t,s);else for(var i=e.length-1;i>=0;i--)(u=e[i])&&(r=(a<3?u(r):a>3?u(n,t,r):u(n,t))||r);return a>3&&r&&Object.defineProperty(n,t,r),r}function jD(e,n){return function(t,s){n(t,s,e);}}function OD(e,n){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(e,n)}function qD(e,n,t,s){function a(r){return r instanceof t?r:new t(function(u){u(r);})}return new(t||(t=Promise))(function(r,u){function i(v){try{c(s.next(v));}catch(m){u(m);}}function o(v){try{c(s.throw(v));}catch(m){u(m);}}function c(v){v.done?r(v.value):a(v.value).then(i,o);}c((s=s.apply(e,n||[])).next());})}function MD(e,n){var t={label:0,sent:function(){if(r[0]&1)throw r[1];return r[1]},trys:[],ops:[]},s,a,r,u;return u={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(u[Symbol.iterator]=function(){return this}),u;function i(c){return function(v){return o([c,v])}}function o(c){if(s)throw new TypeError("Generator is already executing.");for(;t;)try{if(s=1,a&&(r=c[0]&2?a.return:c[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,c[1])).done)return r;switch(a=0,r&&(c=[c[0]&2,r.value]),c[0]){case 0:case 1:r=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,a=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(r=t.trys,!(r=r.length>0&&r[r.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!r||c[1]>r[0]&&c[1]<r[3])){t.label=c[1];break}if(c[0]===6&&t.label<r[1]){t.label=r[1],r=c;break}if(r&&t.label<r[2]){t.label=r[2],t.ops.push(c);break}r[2]&&t.ops.pop(),t.trys.pop();continue}c=n.call(e,t);}catch(v){c=[6,v],a=0;}finally{s=r=0;}if(c[0]&5)throw c[1];return {value:c[0]?c[1]:void 0,done:!0}}}function RD(e,n,t,s){s===void 0&&(s=t),e[s]=n[t];}function VD(e,n){for(var t in e)t!=="default"&&!n.hasOwnProperty(t)&&(n[t]=e[t]);}function Nn(e){var n=typeof Symbol=="function"&&Symbol.iterator,t=n&&e[n],s=0;if(t)return t.call(e);if(e&&typeof e.length=="number")return {next:function(){return e&&s>=e.length&&(e=void 0),{value:e&&e[s++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function ja(e,n){var t=typeof Symbol=="function"&&e[Symbol.iterator];if(!t)return e;var s=t.call(e),a,r=[],u;try{for(;(n===void 0||n-- >0)&&!(a=s.next()).done;)r.push(a.value);}catch(i){u={error:i};}finally{try{a&&!a.done&&(t=s.return)&&t.call(s);}finally{if(u)throw u.error}}return r}function WD(){for(var e=[],n=0;n<arguments.length;n++)e=e.concat(ja(arguments[n]));return e}function $D(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;for(var s=Array(e),a=0,n=0;n<t;n++)for(var r=arguments[n],u=0,i=r.length;u<i;u++,a++)s[a]=r[u];return s}function Jt(e){return this instanceof Jt?(this.v=e,this):new Jt(e)}function HD(e,n,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s=t.apply(e,n||[]),a,r=[];return a={},u("next"),u("throw"),u("return"),a[Symbol.asyncIterator]=function(){return this},a;function u(d){s[d]&&(a[d]=function(p){return new Promise(function(f,h){r.push([d,p,f,h])>1||i(d,p);})});}function i(d,p){try{o(s[d](p));}catch(f){m(r[0][3],f);}}function o(d){d.value instanceof Jt?Promise.resolve(d.value.v).then(c,v):m(r[0][2],d);}function c(d){i("next",d);}function v(d){i("throw",d);}function m(d,p){d(p),r.shift(),r.length&&i(r[0][0],r[0][1]);}}function GD(e){var n,t;return n={},s("next"),s("throw",function(a){throw a}),s("return"),n[Symbol.iterator]=function(){return this},n;function s(a,r){n[a]=e[a]?function(u){return (t=!t)?{value:Jt(e[a](u)),done:a==="return"}:r?r(u):u}:r;}}function JD(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n=e[Symbol.asyncIterator],t;return n?n.call(e):(e=typeof Nn=="function"?Nn(e):e[Symbol.iterator](),t={},s("next"),s("throw"),s("return"),t[Symbol.asyncIterator]=function(){return this},t);function s(r){t[r]=e[r]&&function(u){return new Promise(function(i,o){u=e[r](u),a(i,o,u.done,u.value);})};}function a(r,u,i,o){Promise.resolve(o).then(function(c){r({value:c,done:i});},u);}}function UD(e,n){return Object.defineProperty?Object.defineProperty(e,"raw",{value:n}):e.raw=n,e}function zD(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)Object.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}function XD(e){return e&&e.__esModule?e:{default:e}}function KD(e,n){if(!n.has(e))throw new TypeError("attempted to get private field on non-instance");return n.get(e)}function YD(e,n,t){if(!n.has(e))throw new TypeError("attempted to set private field on non-instance");return n.set(e,t),t}var xr,br,ht=mt({"node_modules/tslib/tslib.es6.js"(){re(),xr=function(e,n){return xr=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s;}||function(t,s){for(var a in s)s.hasOwnProperty(a)&&(t[a]=s[a]);},xr(e,n)},br=function(){return br=Object.assign||function(n){for(var t,s=1,a=arguments.length;s<a;s++){t=arguments[s];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);}return n},br.apply(this,arguments)};}}),Oa=Z({"node_modules/vnopts/lib/descriptors/api.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.apiDescriptor={key:n=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n)?n:JSON.stringify(n),value(n){if(n===null||typeof n!="object")return JSON.stringify(n);if(Array.isArray(n))return "[".concat(n.map(s=>e.apiDescriptor.value(s)).join(", "),"]");let t=Object.keys(n);return t.length===0?"{}":"{ ".concat(t.map(s=>"".concat(e.apiDescriptor.key(s),": ").concat(e.apiDescriptor.value(n[s]))).join(", ")," }")},pair:n=>{let{key:t,value:s}=n;return e.apiDescriptor.value({[t]:s})}};}}),QD=Z({"node_modules/vnopts/lib/descriptors/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(Oa(),e);}}),_r=Z({"scripts/build/shims/chalk.cjs"(e,n){re();var t=s=>s;t.grey=t,t.red=t,t.bold=t,t.yellow=t,t.blue=t,t.default=t,n.exports=t;}}),qa=Z({"node_modules/vnopts/lib/handlers/deprecated/common.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=_r();e.commonDeprecatedHandler=(t,s,a)=>{let{descriptor:r}=a,u=["".concat(n.default.yellow(typeof t=="string"?r.key(t):r.pair(t))," is deprecated")];return s&&u.push("we now treat it as ".concat(n.default.blue(typeof s=="string"?r.key(s):r.pair(s)))),u.join("; ")+"."};}}),ZD=Z({"node_modules/vnopts/lib/handlers/deprecated/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(qa(),e);}}),em=Z({"node_modules/vnopts/lib/handlers/invalid/common.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=_r();e.commonInvalidHandler=(t,s,a)=>["Invalid ".concat(n.default.red(a.descriptor.key(t))," value."),"Expected ".concat(n.default.blue(a.schemas[t].expected(a)),","),"but received ".concat(n.default.red(a.descriptor.value(s)),".")].join(" ");}}),Ma=Z({"node_modules/vnopts/lib/handlers/invalid/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(em(),e);}}),tm=Z({"node_modules/vnopts/node_modules/leven/index.js"(e,n){re();var t=[],s=[];n.exports=function(a,r){if(a===r)return 0;var u=a;a.length>r.length&&(a=r,r=u);var i=a.length,o=r.length;if(i===0)return o;if(o===0)return i;for(;i>0&&a.charCodeAt(~-i)===r.charCodeAt(~-o);)i--,o--;if(i===0)return o;for(var c=0;c<i&&a.charCodeAt(c)===r.charCodeAt(c);)c++;if(i-=c,o-=c,i===0)return o;for(var v,m,d,p,f=0,h=0;f<i;)s[c+f]=a.charCodeAt(c+f),t[f]=++f;for(;h<o;)for(v=r.charCodeAt(c+h),d=h++,m=h,f=0;f<i;f++)p=v===s[c+f]?d:d+1,d=t[f],m=t[f]=d>m?p>m?m+1:p:p>d?d+1:p;return m};}}),Ra=Z({"node_modules/vnopts/lib/handlers/unknown/leven.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=_r(),t=tm();e.levenUnknownHandler=(s,a,r)=>{let{descriptor:u,logger:i,schemas:o}=r,c=["Ignored unknown option ".concat(n.default.yellow(u.pair({key:s,value:a})),".")],v=Object.keys(o).sort().find(m=>t(s,m)<3);v&&c.push("Did you mean ".concat(n.default.blue(u.key(v)),"?")),i.warn(c.join(" "));};}}),rm=Z({"node_modules/vnopts/lib/handlers/unknown/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(Ra(),e);}}),nm=Z({"node_modules/vnopts/lib/handlers/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(ZD(),e),n.__exportStar(Ma(),e),n.__exportStar(rm(),e);}}),vt=Z({"node_modules/vnopts/lib/schema.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=["default","expected","validate","deprecated","forward","redirect","overlap","preprocess","postprocess"];function t(r,u){let i=new r(u),o=Object.create(i);for(let c of n)c in u&&(o[c]=a(u[c],i,s.prototype[c].length));return o}e.createSchema=t;var s=class{constructor(r){this.name=r.name;}static create(r){return t(this,r)}default(r){}expected(r){return "nothing"}validate(r,u){return !1}deprecated(r,u){return !1}forward(r,u){}redirect(r,u){}overlap(r,u,i){return r}preprocess(r,u){return r}postprocess(r,u){return r}};e.Schema=s;function a(r,u,i){return typeof r=="function"?function(){for(var o=arguments.length,c=new Array(o),v=0;v<o;v++)c[v]=arguments[v];return r(...c.slice(0,i-1),u,...c.slice(i-1))}:()=>r}}}),um=Z({"node_modules/vnopts/lib/schemas/alias.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=vt(),t=class extends n.Schema{constructor(s){super(s),this._sourceName=s.sourceName;}expected(s){return s.schemas[this._sourceName].expected(s)}validate(s,a){return a.schemas[this._sourceName].validate(s,a)}redirect(s,a){return this._sourceName}};e.AliasSchema=t;}}),sm=Z({"node_modules/vnopts/lib/schemas/any.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=vt(),t=class extends n.Schema{expected(){return "anything"}validate(){return !0}};e.AnySchema=t;}}),im=Z({"node_modules/vnopts/lib/schemas/array.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt)),t=vt(),s=class extends t.Schema{constructor(r){var{valueSchema:u,name:i=u.name}=r,o=n.__rest(r,["valueSchema","name"]);super(Object.assign({},o,{name:i})),this._valueSchema=u;}expected(r){return "an array of ".concat(this._valueSchema.expected(r))}validate(r,u){if(!Array.isArray(r))return !1;let i=[];for(let o of r){let c=u.normalizeValidateResult(this._valueSchema.validate(o,u),o);c!==!0&&i.push(c.value);}return i.length===0?!0:{value:i}}deprecated(r,u){let i=[];for(let o of r){let c=u.normalizeDeprecatedResult(this._valueSchema.deprecated(o,u),o);c!==!1&&i.push(...c.map(v=>{let{value:m}=v;return {value:[m]}}));}return i}forward(r,u){let i=[];for(let o of r){let c=u.normalizeForwardResult(this._valueSchema.forward(o,u),o);i.push(...c.map(a));}return i}redirect(r,u){let i=[],o=[];for(let c of r){let v=u.normalizeRedirectResult(this._valueSchema.redirect(c,u),c);"remain"in v&&i.push(v.remain),o.push(...v.redirect.map(a));}return i.length===0?{redirect:o}:{redirect:o,remain:i}}overlap(r,u){return r.concat(u)}};e.ArraySchema=s;function a(r){let{from:u,to:i}=r;return {from:[u],to:i}}}}),am=Z({"node_modules/vnopts/lib/schemas/boolean.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=vt(),t=class extends n.Schema{expected(){return "true or false"}validate(s){return typeof s=="boolean"}};e.BooleanSchema=t;}}),Hn=Z({"node_modules/vnopts/lib/utils.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});function n(p,f){let h=Object.create(null);for(let w of p){let T=w[f];if(h[T])throw new Error("Duplicate ".concat(f," ").concat(JSON.stringify(T)));h[T]=w;}return h}e.recordFromArray=n;function t(p,f){let h=new Map;for(let w of p){let T=w[f];if(h.has(T))throw new Error("Duplicate ".concat(f," ").concat(JSON.stringify(T)));h.set(T,w);}return h}e.mapFromArray=t;function s(){let p=Object.create(null);return f=>{let h=JSON.stringify(f);return p[h]?!0:(p[h]=!0,!1)}}e.createAutoChecklist=s;function a(p,f){let h=[],w=[];for(let T of p)f(T)?h.push(T):w.push(T);return [h,w]}e.partition=a;function r(p){return p===Math.floor(p)}e.isInt=r;function u(p,f){if(p===f)return 0;let h=typeof p,w=typeof f,T=["undefined","object","boolean","number","string"];return h!==w?T.indexOf(h)-T.indexOf(w):h!=="string"?Number(p)-Number(f):p.localeCompare(f)}e.comparePrimitive=u;function i(p){return p===void 0?{}:p}e.normalizeDefaultResult=i;function o(p,f){return p===!0?!0:p===!1?{value:f}:p}e.normalizeValidateResult=o;function c(p,f){let h=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;return p===!1?!1:p===!0?h?!0:[{value:f}]:"value"in p?[p]:p.length===0?!1:p}e.normalizeDeprecatedResult=c;function v(p,f){return typeof p=="string"||"key"in p?{from:f,to:p}:"from"in p?{from:p.from,to:p.to}:{from:f,to:p.to}}e.normalizeTransferResult=v;function m(p,f){return p===void 0?[]:Array.isArray(p)?p.map(h=>v(h,f)):[v(p,f)]}e.normalizeForwardResult=m;function d(p,f){let h=m(typeof p=="object"&&"redirect"in p?p.redirect:p,f);return h.length===0?{remain:f,redirect:h}:typeof p=="object"&&"remain"in p?{remain:p.remain,redirect:h}:{redirect:h}}e.normalizeRedirectResult=d;}}),om=Z({"node_modules/vnopts/lib/schemas/choice.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=vt(),t=Hn(),s=class extends n.Schema{constructor(a){super(a),this._choices=t.mapFromArray(a.choices.map(r=>r&&typeof r=="object"?r:{value:r}),"value");}expected(a){let{descriptor:r}=a,u=Array.from(this._choices.keys()).map(c=>this._choices.get(c)).filter(c=>!c.deprecated).map(c=>c.value).sort(t.comparePrimitive).map(r.value),i=u.slice(0,-2),o=u.slice(-2);return i.concat(o.join(" or ")).join(", ")}validate(a){return this._choices.has(a)}deprecated(a){let r=this._choices.get(a);return r&&r.deprecated?{value:a}:!1}forward(a){let r=this._choices.get(a);return r?r.forward:void 0}redirect(a){let r=this._choices.get(a);return r?r.redirect:void 0}};e.ChoiceSchema=s;}}),Va=Z({"node_modules/vnopts/lib/schemas/number.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=vt(),t=class extends n.Schema{expected(){return "a number"}validate(s,a){return typeof s=="number"}};e.NumberSchema=t;}}),lm=Z({"node_modules/vnopts/lib/schemas/integer.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=Hn(),t=Va(),s=class extends t.NumberSchema{expected(){return "an integer"}validate(a,r){return r.normalizeValidateResult(super.validate(a,r),a)===!0&&n.isInt(a)}};e.IntegerSchema=s;}}),cm=Z({"node_modules/vnopts/lib/schemas/string.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=vt(),t=class extends n.Schema{expected(){return "a string"}validate(s){return typeof s=="string"}};e.StringSchema=t;}}),pm=Z({"node_modules/vnopts/lib/schemas/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(um(),e),n.__exportStar(sm(),e),n.__exportStar(im(),e),n.__exportStar(am(),e),n.__exportStar(om(),e),n.__exportStar(lm(),e),n.__exportStar(Va(),e),n.__exportStar(cm(),e);}}),fm=Z({"node_modules/vnopts/lib/defaults.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=Oa(),t=qa(),s=Ma(),a=Ra();e.defaultDescriptor=n.apiDescriptor,e.defaultUnknownHandler=a.levenUnknownHandler,e.defaultInvalidHandler=s.commonInvalidHandler,e.defaultDeprecatedHandler=t.commonDeprecatedHandler;}}),Dm=Z({"node_modules/vnopts/lib/normalize.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=fm(),t=Hn();e.normalize=(a,r,u)=>new s(r,u).normalize(a);var s=class{constructor(a,r){let{logger:u=console,descriptor:i=n.defaultDescriptor,unknown:o=n.defaultUnknownHandler,invalid:c=n.defaultInvalidHandler,deprecated:v=n.defaultDeprecatedHandler}=r||{};this._utils={descriptor:i,logger:u||{warn:()=>{}},schemas:t.recordFromArray(a,"name"),normalizeDefaultResult:t.normalizeDefaultResult,normalizeDeprecatedResult:t.normalizeDeprecatedResult,normalizeForwardResult:t.normalizeForwardResult,normalizeRedirectResult:t.normalizeRedirectResult,normalizeValidateResult:t.normalizeValidateResult},this._unknownHandler=o,this._invalidHandler=c,this._deprecatedHandler=v,this.cleanHistory();}cleanHistory(){this._hasDeprecationWarned=t.createAutoChecklist();}normalize(a){let r={},u=[a],i=()=>{for(;u.length!==0;){let o=u.shift(),c=this._applyNormalization(o,r);u.push(...c);}};i();for(let o of Object.keys(this._utils.schemas)){let c=this._utils.schemas[o];if(!(o in r)){let v=t.normalizeDefaultResult(c.default(this._utils));"value"in v&&u.push({[o]:v.value});}}i();for(let o of Object.keys(this._utils.schemas)){let c=this._utils.schemas[o];o in r&&(r[o]=c.postprocess(r[o],this._utils));}return r}_applyNormalization(a,r){let u=[],[i,o]=t.partition(Object.keys(a),c=>c in this._utils.schemas);for(let c of i){let v=this._utils.schemas[c],m=v.preprocess(a[c],this._utils),d=t.normalizeValidateResult(v.validate(m,this._utils),m);if(d!==!0){let{value:T}=d,A=this._invalidHandler(c,T,this._utils);throw typeof A=="string"?new Error(A):A}let p=T=>{let{from:A,to:S}=T;u.push(typeof S=="string"?{[S]:A}:{[S.key]:S.value});},f=T=>{let{value:A,redirectTo:S}=T,B=t.normalizeDeprecatedResult(v.deprecated(A,this._utils),m,!0);if(B!==!1)if(B===!0)this._hasDeprecationWarned(c)||this._utils.logger.warn(this._deprecatedHandler(c,S,this._utils));else for(let{value:I}of B){let k={key:c,value:I};if(!this._hasDeprecationWarned(k)){let P=typeof S=="string"?{key:S,value:I}:S;this._utils.logger.warn(this._deprecatedHandler(k,P,this._utils));}}};t.normalizeForwardResult(v.forward(m,this._utils),m).forEach(p);let w=t.normalizeRedirectResult(v.redirect(m,this._utils),m);if(w.redirect.forEach(p),"remain"in w){let T=w.remain;r[c]=c in r?v.overlap(r[c],T,this._utils):T,f({value:T});}for(let{from:T,to:A}of w.redirect)f({value:T,redirectTo:A});}for(let c of o){let v=a[c],m=this._unknownHandler(c,v,this._utils);if(m)for(let d of Object.keys(m)){let p={[d]:m[d]};d in this._utils.schemas?u.push(p):Object.assign(r,p);}}return u}};e.Normalizer=s;}}),mm=Z({"node_modules/vnopts/lib/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=(ht(),lt(dt));n.__exportStar(QD(),e),n.__exportStar(nm(),e),n.__exportStar(pm(),e),n.__exportStar(Dm(),e),n.__exportStar(vt(),e);}}),dm=Z({"src/main/options-normalizer.js"(e,n){re();var t=mm(),s=it(),a={key:d=>d.length===1?"-".concat(d):"--".concat(d),value:d=>t.apiDescriptor.value(d),pair:d=>{let{key:p,value:f}=d;return f===!1?"--no-".concat(p):f===!0?a.key(p):f===""?"".concat(a.key(p)," without an argument"):"".concat(a.key(p),"=").concat(f)}},r=d=>{let{colorsModule:p,levenshteinDistance:f}=d;return class extends t.ChoiceSchema{constructor(w){let{name:T,flags:A}=w;super({name:T,choices:A}),this._flags=[...A].sort();}preprocess(w,T){if(typeof w=="string"&&w.length>0&&!this._flags.includes(w)){let A=this._flags.find(S=>f(S,w)<3);if(A)return T.logger.warn(["Unknown flag ".concat(p.yellow(T.descriptor.value(w)),","),"did you mean ".concat(p.blue(T.descriptor.value(A)),"?")].join(" ")),A}return w}expected(){return "a flag"}}},u;function i(d,p){let{logger:f=!1,isCLI:h=!1,passThrough:w=!1,colorsModule:T=null,levenshteinDistance:A=null}=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},S=w?Array.isArray(w)?(D,g)=>w.includes(D)?{[D]:g}:void 0:(D,g)=>({[D]:g}):(D,g,F)=>{let l=F.schemas,y=kn(l,Qf);return t.levenUnknownHandler(D,g,Object.assign(Object.assign({},F),{},{schemas:y}))},B=h?a:t.apiDescriptor,I=o(p,{isCLI:h,colorsModule:T,levenshteinDistance:A}),k=new t.Normalizer(I,{logger:f,unknown:S,descriptor:B}),P=f!==!1;P&&u&&(k._hasDeprecationWarned=u);let C=k.normalize(d);return P&&(u=k._hasDeprecationWarned),h&&C["plugin-search"]===!1&&(C["plugin-search-dir"]=!1),C}function o(d,p){let{isCLI:f,colorsModule:h,levenshteinDistance:w}=p,T=[];f&&T.push(t.AnySchema.create({name:"_"}));for(let A of d)T.push(c(A,{isCLI:f,optionInfos:d,colorsModule:h,levenshteinDistance:w})),A.alias&&f&&T.push(t.AliasSchema.create({name:A.alias,sourceName:A.name}));return T}function c(d,p){let{isCLI:f,optionInfos:h,colorsModule:w,levenshteinDistance:T}=p,{name:A}=d;if(A==="plugin-search-dir"||A==="pluginSearchDirs")return t.AnySchema.create({name:A,preprocess(k){return k===!1||(k=Array.isArray(k)?k:[k]),k},validate(k){return k===!1?!0:k.every(P=>typeof P=="string")},expected(){return "false or paths to plugin search dir"}});let S={name:A},B,I={};switch(d.type){case"int":B=t.IntegerSchema,f&&(S.preprocess=Number);break;case"string":B=t.StringSchema;break;case"choice":B=t.ChoiceSchema,S.choices=d.choices.map(k=>typeof k=="object"&&k.redirect?Object.assign(Object.assign({},k),{},{redirect:{to:{key:d.name,value:k.redirect}}}):k);break;case"boolean":B=t.BooleanSchema;break;case"flag":B=r({colorsModule:w,levenshteinDistance:T}),S.flags=h.flatMap(k=>[k.alias,k.description&&k.name,k.oppositeDescription&&"no-".concat(k.name)].filter(Boolean));break;case"path":B=t.StringSchema;break;default:throw new Error("Unexpected type ".concat(d.type))}if(d.exception?S.validate=(k,P,C)=>d.exception(k)||P.validate(k,C):S.validate=(k,P,C)=>k===void 0||P.validate(k,C),d.redirect&&(I.redirect=k=>k?{to:{key:d.redirect.option,value:d.redirect.value}}:void 0),d.deprecated&&(I.deprecated=!0),f&&!d.array){let k=S.preprocess||(P=>P);S.preprocess=(P,C,D)=>C.preprocess(k(Array.isArray(P)?s(P):P),D);}return d.array?t.ArraySchema.create(Object.assign(Object.assign(Object.assign({},f?{preprocess:k=>Array.isArray(k)?k:[k]}:{}),I),{},{valueSchema:B.create(S)})):B.create(Object.assign(Object.assign({},S),I))}function v(d,p,f){return i(d,p,f)}function m(d,p,f){return i(d,p,Object.assign({isCLI:!0},f))}n.exports={normalizeApiOptions:v,normalizeCliOptions:m};}}),st=Z({"src/language-js/loc.js"(e,n){re();var t=Rn();function s(o,c){let{ignoreDecorators:v}=c||{};if(!v){let m=o.declaration&&o.declaration.decorators||o.decorators;if(t(m))return s(m[0])}return o.range?o.range[0]:o.start}function a(o){return o.range?o.range[1]:o.end}function r(o,c){let v=s(o);return Number.isInteger(v)&&v===s(c)}function u(o,c){let v=a(o);return Number.isInteger(v)&&v===a(c)}function i(o,c){return r(o,c)&&u(o,c)}n.exports={locStart:s,locEnd:a,hasSameLocStart:r,hasSameLoc:i};}}),gm=Z({"src/main/load-parser.js"(e,n){re(),n.exports=()=>{};}}),ym=Z({"scripts/build/shims/babel-highlight.cjs"(e,n){re();var t=_r(),s={shouldHighlight:()=>!1,getChalk:()=>t};n.exports=s;}}),hm=Z({"node_modules/@babel/code-frame/lib/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.codeFrameColumns=u,e.default=i;var n=ym(),t=!1;function s(o){return {gutter:o.grey,marker:o.red.bold,message:o.red.bold}}var a=/\r\n|[\n\r\u2028\u2029]/;function r(o,c,v){let m=Object.assign({column:0,line:-1},o.start),d=Object.assign({},m,o.end),{linesAbove:p=2,linesBelow:f=3}=v||{},h=m.line,w=m.column,T=d.line,A=d.column,S=Math.max(h-(p+1),0),B=Math.min(c.length,T+f);h===-1&&(S=0),T===-1&&(B=c.length);let I=T-h,k={};if(I)for(let P=0;P<=I;P++){let C=P+h;if(!w)k[C]=!0;else if(P===0){let D=c[C-1].length;k[C]=[w,D-w+1];}else if(P===I)k[C]=[0,A];else {let D=c[C-P].length;k[C]=[0,D];}}else w===A?w?k[h]=[w,0]:k[h]=!0:k[h]=[w,A-w];return {start:S,end:B,markerLines:k}}function u(o,c){let v=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},m=(v.highlightCode||v.forceColor)&&(0, n.shouldHighlight)(v),d=(0, n.getChalk)(v),p=s(d),f=(P,C)=>m?P(C):C,h=o.split(a),{start:w,end:T,markerLines:A}=r(c,h,v),S=c.start&&typeof c.start.column=="number",B=String(T).length,k=(m?(0, n.default)(o,v):o).split(a,T).slice(w,T).map((P,C)=>{let D=w+1+C,g=" ".concat(D).slice(-B),F=" ".concat(g," |"),l=A[D],E=!A[D+1];if(l){let y="";if(Array.isArray(l)){let N=P.slice(0,Math.max(l[0]-1,0)).replace(/[^\t]/g," "),x=l[1]||1;y=[`
	 `,f(p.gutter,F.replace(/\d/g," "))," ",N,f(p.marker,"^").repeat(x)].join(""),E&&v.message&&(y+=" "+f(p.message,v.message));}return [f(p.marker,">"),f(p.gutter,F),P.length>0?" ".concat(P):"",y].join("")}else return " ".concat(f(p.gutter,F)).concat(P.length>0?" ".concat(P):"")}).join(`
	`);return v.message&&!S&&(k="".concat(" ".repeat(B+1)).concat(v.message,`
	`).concat(k)),m?d.reset(k):k}function i(o,c,v){let m=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};if(!t){t=!0;let p="Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";if(Tt.emitWarning)Tt.emitWarning(p,"DeprecationWarning");else {let f=new Error(p);f.name="DeprecationWarning",console.warn(new Error(p));}}return v=Math.max(v,0),u(o,{start:{column:v,line:c}},m)}}}),Gn=Z({"src/main/parser.js"(e,n){re();var {ConfigError:t}=zt(),s=st();gm();var {locStart:r,locEnd:u}=s,i=Object.getOwnPropertyNames,o=Object.getOwnPropertyDescriptor;function c(d){let p={};for(let f of d.plugins)if(!!f.parsers)for(let h of i(f.parsers))Object.defineProperty(p,h,o(f.parsers,h));return p}function v(d){let p=arguments.length>1&&arguments[1]!==void 0?arguments[1]:c(d);if(typeof d.parser=="function")return {parse:d.parser,astFormat:"estree",locStart:r,locEnd:u};if(typeof d.parser=="string"){if(Object.prototype.hasOwnProperty.call(p,d.parser))return p[d.parser];throw new t(`Couldn't resolve parser "`.concat(d.parser,'". Parsers must be explicitly added to the standalone bundle.'))}}function m(d,p){let f=c(p),h=Object.defineProperties({},Object.fromEntries(Object.keys(f).map(T=>[T,{enumerable:!0,get(){return f[T].parse}}]))),w=v(p,f);try{return w.preprocess&&(d=w.preprocess(d,p)),{text:d,ast:w.parse(d,h,p)}}catch(T){let{loc:A}=T;if(A){let{codeFrameColumns:S}=hm();throw T.codeFrame=S(d,A,{highlightCode:!0}),T.message+=`
	`+T.codeFrame,T}throw T.stack}}n.exports={parse:m,resolveParser:v};}}),Wa=Z({"src/main/options.js"(e,n){re();var t=PD(),{UndefinedParserError:s}=zt(),{getSupportInfo:a}=Mn(),r=dm(),{resolveParser:u}=Gn(),i={astFormat:"estree",printer:{},originalText:void 0,locStart:null,locEnd:null};function o(m){let d=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},p=Object.assign({},m),f=a({plugins:m.plugins,showUnreleased:!0,showDeprecated:!0}).options,h=Object.assign(Object.assign({},i),Object.fromEntries(f.filter(B=>B.default!==void 0).map(B=>[B.name,B.default])));if(!p.parser){if(!p.filepath)(d.logger||console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."),p.parser="babel";else if(p.parser=v(p.filepath,p.plugins),!p.parser)throw new s("No parser could be inferred for file: ".concat(p.filepath))}let w=u(r.normalizeApiOptions(p,[f.find(B=>B.name==="parser")],{passThrough:!0,logger:!1}));p.astFormat=w.astFormat,p.locEnd=w.locEnd,p.locStart=w.locStart;let T=c(p);p.printer=T.printers[p.astFormat];let A=Object.fromEntries(f.filter(B=>B.pluginDefaults&&B.pluginDefaults[T.name]!==void 0).map(B=>[B.name,B.pluginDefaults[T.name]])),S=Object.assign(Object.assign({},h),A);for(let[B,I]of Object.entries(S))(p[B]===null||p[B]===void 0)&&(p[B]=I);return p.parser==="json"&&(p.trailingComma="none"),r.normalizeApiOptions(p,f,Object.assign({passThrough:Object.keys(i)},d))}function c(m){let{astFormat:d}=m;if(!d)throw new Error("getPlugin() requires astFormat to be set");let p=m.plugins.find(f=>f.printers&&f.printers[d]);if(!p)throw new Error(`Couldn't find plugin for AST format "`.concat(d,'"'));return p}function v(m,d){let p=t.basename(m).toLowerCase(),h=a({plugins:d}).languages.filter(w=>w.since!==null).find(w=>w.extensions&&w.extensions.some(T=>p.endsWith(T))||w.filenames&&w.filenames.some(T=>T.toLowerCase()===p));return h&&h.parsers[0]}n.exports={normalize:o,hiddenDefaults:i,inferParser:v};}}),vm=Z({"src/main/massage-ast.js"(e,n){re();function t(s,a,r){if(Array.isArray(s))return s.map(c=>t(c,a,r)).filter(Boolean);if(!s||typeof s!="object")return s;let u=a.printer.massageAstNode,i;u&&u.ignoredProperties?i=u.ignoredProperties:i=new Set;let o={};for(let[c,v]of Object.entries(s))!i.has(c)&&typeof v!="function"&&(o[c]=t(v,a,s));if(u){let c=u(s,o,r);if(c===null)return;if(c)return c}return o}n.exports=t;}}),Xt=Z({"scripts/build/shims/assert.cjs"(e,n){re();var t=()=>{};t.ok=t,t.strictEqual=t,n.exports=t;}}),et=Z({"src/main/comments.js"(e,n){re();var t=Xt(),{builders:{line:s,hardline:a,breakParent:r,indent:u,lineSuffix:i,join:o,cursor:c}}=Oe(),{hasNewline:v,skipNewline:m,skipSpaces:d,isPreviousLineEmpty:p,addLeadingComment:f,addDanglingComment:h,addTrailingComment:w}=Ue(),T=new WeakMap;function A(L,M,j){if(!L)return;let{printer:$,locStart:V,locEnd:q}=M;if(j){if($.canAttachComment&&$.canAttachComment(L)){let H;for(H=j.length-1;H>=0&&!(V(j[H])<=V(L)&&q(j[H])<=q(L));--H);j.splice(H+1,0,L);return}}else if(T.has(L))return T.get(L);let Y=$.getCommentChildNodes&&$.getCommentChildNodes(L,M)||typeof L=="object"&&Object.entries(L).filter(H=>{let[R]=H;return R!=="enclosingNode"&&R!=="precedingNode"&&R!=="followingNode"&&R!=="tokens"&&R!=="comments"&&R!=="parent"}).map(H=>{let[,R]=H;return R});if(!!Y){j||(j=[],T.set(L,j));for(let H of Y)A(H,M,j);return j}}function S(L,M,j,$){let{locStart:V,locEnd:q}=j,Y=V(M),H=q(M),R=A(L,j),Q,ee,te=0,oe=R.length;for(;te<oe;){let W=te+oe>>1,X=R[W],ue=V(X),De=q(X);if(ue<=Y&&H<=De)return S(X,M,j,X);if(De<=Y){Q=X,te=W+1;continue}if(H<=ue){ee=X,oe=W;continue}throw new Error("Comment location overlaps with node location")}if($&&$.type==="TemplateLiteral"){let{quasis:W}=$,X=F(W,M,j);Q&&F(W,Q,j)!==X&&(Q=null),ee&&F(W,ee,j)!==X&&(ee=null);}return {enclosingNode:$,precedingNode:Q,followingNode:ee}}var B=()=>!1;function I(L,M,j,$){if(!Array.isArray(L))return;let V=[],{locStart:q,locEnd:Y,printer:{handleComments:H={}}}=$,{avoidAstMutation:R,ownLine:Q=B,endOfLine:ee=B,remaining:te=B}=H,oe=L.map((W,X)=>Object.assign(Object.assign({},S(M,W,$)),{},{comment:W,text:j,options:$,ast:M,isLastComment:L.length-1===X}));for(let[W,X]of oe.entries()){let{comment:ue,precedingNode:De,enclosingNode:ie,followingNode:G,text:z,options:U,ast:le,isLastComment:ge}=X;if(U.parser==="json"||U.parser==="json5"||U.parser==="__js_expression"||U.parser==="__vue_expression"||U.parser==="__vue_ts_expression"){if(q(ue)-q(le)<=0){f(le,ue);continue}if(Y(ue)-Y(le)>=0){w(le,ue);continue}}let Ae;if(R?Ae=[X]:(ue.enclosingNode=ie,ue.precedingNode=De,ue.followingNode=G,Ae=[ue,z,U,le,ge]),P(z,U,oe,W))ue.placement="ownLine",Q(...Ae)||(G?f(G,ue):De?w(De,ue):h(ie||le,ue));else if(C(z,U,oe,W))ue.placement="endOfLine",ee(...Ae)||(De?w(De,ue):G?f(G,ue):h(ie||le,ue));else if(ue.placement="remaining",!te(...Ae))if(De&&G){let Ne=V.length;Ne>0&&V[Ne-1].followingNode!==G&&D(V,z,U),V.push(X);}else De?w(De,ue):G?f(G,ue):h(ie||le,ue);}if(D(V,j,$),!R)for(let W of L)delete W.precedingNode,delete W.enclosingNode,delete W.followingNode;}var k=L=>!/[\S\n\u2028\u2029]/.test(L);function P(L,M,j,$){let{comment:V,precedingNode:q}=j[$],{locStart:Y,locEnd:H}=M,R=Y(V);if(q)for(let Q=$-1;Q>=0;Q--){let{comment:ee,precedingNode:te}=j[Q];if(te!==q||!k(L.slice(H(ee),R)))break;R=Y(ee);}return v(L,R,{backwards:!0})}function C(L,M,j,$){let{comment:V,followingNode:q}=j[$],{locStart:Y,locEnd:H}=M,R=H(V);if(q)for(let Q=$+1;Q<j.length;Q++){let{comment:ee,followingNode:te}=j[Q];if(te!==q||!k(L.slice(R,Y(ee))))break;R=H(ee);}return v(L,R)}function D(L,M,j){let $=L.length;if($===0)return;let{precedingNode:V,followingNode:q,enclosingNode:Y}=L[0],H=j.printer.getGapRegex&&j.printer.getGapRegex(Y)||/^[\s(]*$/,R=j.locStart(q),Q;for(Q=$;Q>0;--Q){let{comment:ee,precedingNode:te,followingNode:oe}=L[Q-1];t.strictEqual(te,V),t.strictEqual(oe,q);let W=M.slice(j.locEnd(ee),R);if(H.test(W))R=j.locStart(ee);else break}for(let[ee,{comment:te}]of L.entries())ee<Q?w(V,te):f(q,te);for(let ee of [V,q])ee.comments&&ee.comments.length>1&&ee.comments.sort((te,oe)=>j.locStart(te)-j.locStart(oe));L.length=0;}function g(L,M){let j=L.getValue();return j.printed=!0,M.printer.printComment(L,M)}function F(L,M,j){let $=j.locStart(M)-1;for(let V=1;V<L.length;++V)if($<j.locStart(L[V]))return V-1;return 0}function l(L,M){let j=L.getValue(),$=[g(L,M)],{printer:V,originalText:q,locStart:Y,locEnd:H}=M;if(V.isBlockComment&&V.isBlockComment(j)){let ee=v(q,H(j))?v(q,Y(j),{backwards:!0})?a:s:" ";$.push(ee);}else $.push(a);let Q=m(q,d(q,H(j)));return Q!==!1&&v(q,Q)&&$.push(a),$}function E(L,M){let j=L.getValue(),$=g(L,M),{printer:V,originalText:q,locStart:Y}=M,H=V.isBlockComment&&V.isBlockComment(j);if(v(q,Y(j),{backwards:!0})){let Q=p(q,j,Y);return i([a,Q?a:"",$])}let R=[" ",$];return H||(R=[i(R),r]),R}function y(L,M,j,$){let V=[],q=L.getValue();return !q||!q.comments||(L.each(()=>{let Y=L.getValue();!Y.leading&&!Y.trailing&&(!$||$(Y))&&V.push(g(L,M));},"comments"),V.length===0)?"":j?o(a,V):u([a,o(a,V)])}function N(L,M,j){let $=L.getValue();if(!$)return {};let V=$.comments||[];j&&(V=V.filter(R=>!j.has(R)));let q=$===M.cursorNode;if(V.length===0){let R=q?c:"";return {leading:R,trailing:R}}let Y=[],H=[];return L.each(()=>{let R=L.getValue();if(j&&j.has(R))return;let{leading:Q,trailing:ee}=R;Q?Y.push(l(L,M)):ee&&H.push(E(L,M));},"comments"),q&&(Y.unshift(c),H.push(c)),{leading:Y,trailing:H}}function x(L,M,j,$){let{leading:V,trailing:q}=N(L,j,$);return !V&&!q?M:[V,M,q]}function b(L){if(!!L)for(let M of L){if(!M.printed)throw new Error('Comment "'+M.value.trim()+'" was not printed. Please report this error!');delete M.printed;}}n.exports={attach:I,printComments:x,printCommentsSeparately:N,printDanglingComments:y,getSortedChildNodes:A,ensureAllCommentsPrinted:b};}}),Cm=Z({"src/common/ast-path.js"(e,n){re();var t=it();function s(u,i){let o=a(u.stack,i);return o===-1?null:u.stack[o]}function a(u,i){for(let o=u.length-1;o>=0;o-=2){let c=u[o];if(c&&!Array.isArray(c)&&--i<0)return o}return -1}var r=class{constructor(u){this.stack=[u];}getName(){let{stack:u}=this,{length:i}=u;return i>1?u[i-2]:null}getValue(){return t(this.stack)}getNode(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return s(this,u)}getParentNode(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return s(this,u+1)}call(u){let{stack:i}=this,{length:o}=i,c=t(i);for(var v=arguments.length,m=new Array(v>1?v-1:0),d=1;d<v;d++)m[d-1]=arguments[d];for(let f of m)c=c[f],i.push(f,c);let p=u(this);return i.length=o,p}callParent(u){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,o=a(this.stack,i+1),c=this.stack.splice(o+1),v=u(this);return this.stack.push(...c),v}each(u){let{stack:i}=this,{length:o}=i,c=t(i);for(var v=arguments.length,m=new Array(v>1?v-1:0),d=1;d<v;d++)m[d-1]=arguments[d];for(let p of m)c=c[p],i.push(p,c);for(let p=0;p<c.length;++p)i.push(p,c[p]),u(this,p,c),i.length-=2;i.length=o;}map(u){let i=[];for(var o=arguments.length,c=new Array(o>1?o-1:0),v=1;v<o;v++)c[v-1]=arguments[v];return this.each((m,d,p)=>{i[d]=u(m,d,p);},...c),i}try(u){let{stack:i}=this,o=[...i];try{return u()}finally{i.length=0,i.push(...o);}}match(){let u=this.stack.length-1,i=null,o=this.stack[u--];for(var c=arguments.length,v=new Array(c),m=0;m<c;m++)v[m]=arguments[m];for(let d of v){if(o===void 0)return !1;let p=null;if(typeof i=="number"&&(p=i,i=this.stack[u--],o=this.stack[u--]),d&&!d(o,i,p))return !1;i=this.stack[u--],o=this.stack[u--];}return !0}findAncestor(u){let i=this.stack.length-1,o=null,c=this.stack[i--];for(;c;){let v=null;if(typeof o=="number"&&(v=o,o=this.stack[i--],c=this.stack[i--]),o!==null&&u(c,o,v))return c;o=this.stack[i--],c=this.stack[i--];}}};n.exports=r;}}),Em=Z({"src/main/multiparser.js"(e,n){re();var{utils:{stripTrailingHardline:t}}=Oe(),{normalize:s}=Wa(),a=et();function r(i,o,c,v){if(c.printer.embed&&c.embeddedLanguageFormatting==="auto")return c.printer.embed(i,o,(m,d,p)=>u(m,d,c,v,p),c)}function u(i,o,c,v){let{stripTrailingHardline:m=!1}=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{},d=s(Object.assign(Object.assign(Object.assign({},c),o),{},{parentParser:c.parser,originalText:i}),{passThrough:!0}),p=Gn().parse(i,d),{ast:f}=p;i=p.text;let h=f.comments;delete f.comments,a.attach(h,f,i,d),d[Symbol.for("comments")]=h||[],d[Symbol.for("tokens")]=f.tokens||[];let w=v(f,d);return a.ensureAllCommentsPrinted(h),m?typeof w=="string"?w.replace(/(?:\r?\n)*$/,""):t(w):w}n.exports={printSubtree:r};}}),Fm=Z({"src/main/ast-to-doc.js"(e,n){re();var t=Cm(),{builders:{hardline:s,addAlignmentToDoc:a},utils:{propagateBreaks:r}}=Oe(),{printComments:u}=et(),i=Em();function o(m,d){let p=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,{printer:f}=d;f.preprocess&&(m=f.preprocess(m,d));let h=new Map,w=new t(m),T=A();return p>0&&(T=a([s,T],p,d.tabWidth)),r(T),T;function A(B,I){return B===void 0||B===w?S(I):Array.isArray(B)?w.call(()=>S(I),...B):w.call(()=>S(I),B)}function S(B){let I=w.getValue(),k=I&&typeof I=="object"&&B===void 0;if(k&&h.has(I))return h.get(I);let P=v(w,d,A,B);return k&&h.set(I,P),P}}function c(m,d){let{originalText:p,[Symbol.for("comments")]:f,locStart:h,locEnd:w}=d,T=h(m),A=w(m),S=new Set;for(let B of f)h(B)>=T&&w(B)<=A&&(B.printed=!0,S.add(B));return {doc:p.slice(T,A),printedComments:S}}function v(m,d,p,f){let h=m.getValue(),{printer:w}=d,T,A;if(w.hasPrettierIgnore&&w.hasPrettierIgnore(m))({doc:T,printedComments:A}=c(h,d));else {if(h)try{T=i.printSubtree(m,p,d,o);}catch(S){if(globalThis.PRETTIER_DEBUG)throw S}T||(T=w.print(m,d,p,f));}return (!w.willPrintOwnComments||!w.willPrintOwnComments(m,d))&&(T=u(m,T,d,A)),T}n.exports=o;}}),Am=Z({"src/main/range-util.js"(e,n){re();var t=Xt(),s=et(),a=f=>{let{parser:h}=f;return h==="json"||h==="json5"||h==="json-stringify"};function r(f,h){let w=[f.node,...f.parentNodes],T=new Set([h.node,...h.parentNodes]);return w.find(A=>v.has(A.type)&&T.has(A))}function u(f){let h=f.length-1;for(;;){let w=f[h];if(w&&(w.type==="Program"||w.type==="File"))h--;else break}return f.slice(0,h+1)}function i(f,h,w){let{locStart:T,locEnd:A}=w,S=f.node,B=h.node;if(S===B)return {startNode:S,endNode:B};let I=T(f.node);for(let P of u(h.parentNodes))if(T(P)>=I)B=P;else break;let k=A(h.node);for(let P of u(f.parentNodes))if(A(P)<=k)S=P;else break;return {startNode:S,endNode:B}}function o(f,h,w,T){let A=arguments.length>4&&arguments[4]!==void 0?arguments[4]:[],S=arguments.length>5?arguments[5]:void 0,{locStart:B,locEnd:I}=w,k=B(f),P=I(f);if(!(h>P||h<k||S==="rangeEnd"&&h===k||S==="rangeStart"&&h===P)){for(let C of s.getSortedChildNodes(f,w)){let D=o(C,h,w,T,[f,...A],S);if(D)return D}if(!T||T(f,A[0]))return {node:f,parentNodes:A}}}function c(f,h){return h!=="DeclareExportDeclaration"&&f!=="TypeParameterDeclaration"&&(f==="Directive"||f==="TypeAlias"||f==="TSExportAssignment"||f.startsWith("Declare")||f.startsWith("TSDeclare")||f.endsWith("Statement")||f.endsWith("Declaration"))}var v=new Set(["ObjectExpression","ArrayExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","UnaryExpression","TemplateLiteral"]),m=new Set(["OperationDefinition","FragmentDefinition","VariableDefinition","TypeExtensionDefinition","ObjectTypeDefinition","FieldDefinition","DirectiveDefinition","EnumTypeDefinition","EnumValueDefinition","InputValueDefinition","InputObjectTypeDefinition","SchemaDefinition","OperationTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","ScalarTypeDefinition"]);function d(f,h,w){if(!h)return !1;switch(f.parser){case"flow":case"babel":case"babel-flow":case"babel-ts":case"typescript":case"acorn":case"espree":case"meriyah":case"__babel_estree":return c(h.type,w&&w.type);case"json":case"json5":case"json-stringify":return v.has(h.type);case"graphql":return m.has(h.kind);case"vue":return h.tag!=="root"}return !1}function p(f,h,w){let{rangeStart:T,rangeEnd:A,locStart:S,locEnd:B}=h;t.ok(A>T);let I=f.slice(T,A).search(/\S/),k=I===-1;if(!k)for(T+=I;A>T&&!/\S/.test(f[A-1]);--A);let P=o(w,T,h,(F,l)=>d(h,F,l),[],"rangeStart"),C=k?P:o(w,A,h,F=>d(h,F),[],"rangeEnd");if(!P||!C)return {rangeStart:0,rangeEnd:0};let D,g;if(a(h)){let F=r(P,C);D=F,g=F;}else ({startNode:D,endNode:g}=i(P,C,h));return {rangeStart:Math.min(S(D),S(g)),rangeEnd:Math.max(B(D),B(g))}}n.exports={calculateRange:p,findNodeAtOffset:o};}}),Sm=Z({"src/main/core.js"(e,n){re();var{diffArrays:t}=aD(),{printer:{printDocToString:s},debug:{printDocToDebug:a}}=Oe(),{getAlignmentSize:r}=Ue(),{guessEndOfLine:u,convertEndOfLineToChars:i,countEndOfLineChars:o,normalizeEndOfLine:c}=jn(),v=Wa().normalize,m=vm(),d=et(),p=Gn(),f=Fm(),h=Am(),w="\uFEFF",T=Symbol("cursor");function A(g,F,l){let E=F.comments;return E&&(delete F.comments,d.attach(E,F,g,l)),l[Symbol.for("comments")]=E||[],l[Symbol.for("tokens")]=F.tokens||[],l.originalText=g,E}function S(g,F){let l=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0;if(!g||g.trim().length===0)return {formatted:"",cursorOffset:-1,comments:[]};let{ast:E,text:y}=p.parse(g,F);if(F.cursorOffset>=0){let L=h.findNodeAtOffset(E,F.cursorOffset,F);L&&L.node&&(F.cursorNode=L.node);}let N=A(y,E,F),x=f(E,F,l),b=s(x,F);if(d.ensureAllCommentsPrinted(N),l>0){let L=b.formatted.trim();b.cursorNodeStart!==void 0&&(b.cursorNodeStart-=b.formatted.indexOf(L)),b.formatted=L+i(F.endOfLine);}if(F.cursorOffset>=0){let L,M,j,$,V;if(F.cursorNode&&b.cursorNodeText?(L=F.locStart(F.cursorNode),M=y.slice(L,F.locEnd(F.cursorNode)),j=F.cursorOffset-L,$=b.cursorNodeStart,V=b.cursorNodeText):(L=0,M=y,j=F.cursorOffset,$=0,V=b.formatted),M===V)return {formatted:b.formatted,cursorOffset:$+j,comments:N};let q=[...M];q.splice(j,0,T);let Y=[...V],H=t(q,Y),R=$;for(let Q of H)if(Q.removed){if(Q.value.includes(T))break}else R+=Q.count;return {formatted:b.formatted,cursorOffset:R,comments:N}}return {formatted:b.formatted,cursorOffset:-1,comments:N}}function B(g,F){let{ast:l,text:E}=p.parse(g,F),{rangeStart:y,rangeEnd:N}=h.calculateRange(E,F,l),x=E.slice(y,N),b=Math.min(y,E.lastIndexOf(`
	`,y)+1),L=E.slice(b,y).match(/^\s*/)[0],M=r(L,F.tabWidth),j=S(x,Object.assign(Object.assign({},F),{},{rangeStart:0,rangeEnd:Number.POSITIVE_INFINITY,cursorOffset:F.cursorOffset>y&&F.cursorOffset<=N?F.cursorOffset-y:-1,endOfLine:"lf"}),M),$=j.formatted.trimEnd(),{cursorOffset:V}=F;V>N?V+=$.length-x.length:j.cursorOffset>=0&&(V=j.cursorOffset+y);let q=E.slice(0,y)+$+E.slice(N);if(F.endOfLine!=="lf"){let Y=i(F.endOfLine);V>=0&&Y===`\r
	`&&(V+=o(q.slice(0,V),`
	`)),q=q.replace(/\n/g,Y);}return {formatted:q,cursorOffset:V,comments:j.comments}}function I(g,F,l){return typeof F!="number"||Number.isNaN(F)||F<0||F>g.length?l:F}function k(g,F){let{cursorOffset:l,rangeStart:E,rangeEnd:y}=F;return l=I(g,l,-1),E=I(g,E,0),y=I(g,y,g.length),Object.assign(Object.assign({},F),{},{cursorOffset:l,rangeStart:E,rangeEnd:y})}function P(g,F){let{cursorOffset:l,rangeStart:E,rangeEnd:y,endOfLine:N}=k(g,F),x=g.charAt(0)===w;if(x&&(g=g.slice(1),l--,E--,y--),N==="auto"&&(N=u(g)),g.includes("\r")){let b=L=>o(g.slice(0,Math.max(L,0)),`\r
	`);l-=b(l),E-=b(E),y-=b(y),g=c(g);}return {hasBOM:x,text:g,options:k(g,Object.assign(Object.assign({},F),{},{cursorOffset:l,rangeStart:E,rangeEnd:y,endOfLine:N}))}}function C(g,F){let l=p.resolveParser(F);return !l.hasPragma||l.hasPragma(g)}function D(g,F){let{hasBOM:l,text:E,options:y}=P(g,v(F));if(y.rangeStart>=y.rangeEnd&&E!==""||y.requirePragma&&!C(E,y))return {formatted:g,cursorOffset:F.cursorOffset,comments:[]};let N;return y.rangeStart>0||y.rangeEnd<E.length?N=B(E,y):(!y.requirePragma&&y.insertPragma&&y.printer.insertPragma&&!C(E,y)&&(E=y.printer.insertPragma(E)),N=S(E,y)),l&&(N.formatted=w+N.formatted,N.cursorOffset>=0&&N.cursorOffset++),N}n.exports={formatWithCursor:D,parse(g,F,l){let{text:E,options:y}=P(g,v(F)),N=p.parse(E,y);return l&&(N.ast=m(N.ast,y)),N},formatAST(g,F){F=v(F);let l=f(g,F);return s(l,F)},formatDoc(g,F){return D(a(g),Object.assign(Object.assign({},F),{},{parser:"__js_expression"})).formatted},printToDoc(g,F){F=v(F);let{ast:l,text:E}=p.parse(g,F);return A(E,l,F),f(l,F)},printDocToString(g,F){return s(g,v(F))}};}}),xm=Z({"src/common/util-shared.js"(e,n){re();var{getMaxContinuousCount:t,getStringWidth:s,getAlignmentSize:a,getIndentSize:r,skip:u,skipWhitespace:i,skipSpaces:o,skipNewline:c,skipToLineEnd:v,skipEverythingButNewLine:m,skipInlineComment:d,skipTrailingComment:p,hasNewline:f,hasNewlineInRange:h,hasSpaces:w,isNextLineEmpty:T,isNextLineEmptyAfterIndex:A,isPreviousLineEmpty:S,getNextNonSpaceNonCommentCharacterIndex:B,makeString:I,addLeadingComment:k,addDanglingComment:P,addTrailingComment:C}=Ue();n.exports={getMaxContinuousCount:t,getStringWidth:s,getAlignmentSize:a,getIndentSize:r,skip:u,skipWhitespace:i,skipSpaces:o,skipNewline:c,skipToLineEnd:v,skipEverythingButNewLine:m,skipInlineComment:d,skipTrailingComment:p,hasNewline:f,hasNewlineInRange:h,hasSpaces:w,isNextLineEmpty:T,isNextLineEmptyAfterIndex:A,isPreviousLineEmpty:S,getNextNonSpaceNonCommentCharacterIndex:B,makeString:I,addLeadingComment:k,addDanglingComment:P,addTrailingComment:C};}}),Bt=Z({"src/utils/create-language.js"(e,n){re(),n.exports=function(t,s){let{languageId:a}=t,r=kn(t,Zf);return Object.assign(Object.assign({linguistLanguageId:a},r),s(t))};}}),bm=Z({"node_modules/esutils/lib/ast.js"(e,n){re(),function(){function t(o){if(o==null)return !1;switch(o.type){case"ArrayExpression":case"AssignmentExpression":case"BinaryExpression":case"CallExpression":case"ConditionalExpression":case"FunctionExpression":case"Identifier":case"Literal":case"LogicalExpression":case"MemberExpression":case"NewExpression":case"ObjectExpression":case"SequenceExpression":case"ThisExpression":case"UnaryExpression":case"UpdateExpression":return !0}return !1}function s(o){if(o==null)return !1;switch(o.type){case"DoWhileStatement":case"ForInStatement":case"ForStatement":case"WhileStatement":return !0}return !1}function a(o){if(o==null)return !1;switch(o.type){case"BlockStatement":case"BreakStatement":case"ContinueStatement":case"DebuggerStatement":case"DoWhileStatement":case"EmptyStatement":case"ExpressionStatement":case"ForInStatement":case"ForStatement":case"IfStatement":case"LabeledStatement":case"ReturnStatement":case"SwitchStatement":case"ThrowStatement":case"TryStatement":case"VariableDeclaration":case"WhileStatement":case"WithStatement":return !0}return !1}function r(o){return a(o)||o!=null&&o.type==="FunctionDeclaration"}function u(o){switch(o.type){case"IfStatement":return o.alternate!=null?o.alternate:o.consequent;case"LabeledStatement":case"ForStatement":case"ForInStatement":case"WhileStatement":case"WithStatement":return o.body}return null}function i(o){var c;if(o.type!=="IfStatement"||o.alternate==null)return !1;c=o.consequent;do{if(c.type==="IfStatement"&&c.alternate==null)return !0;c=u(c);}while(c);return !1}n.exports={isExpression:t,isStatement:a,isIterationStatement:s,isSourceElement:r,isProblematicIfStatement:i,trailingStatement:u};}();}}),$a=Z({"node_modules/esutils/lib/code.js"(e,n){re(),function(){var t,s,a,r,u,i;s={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,NonAsciiIdentifierPart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},t={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/};function o(A){return 48<=A&&A<=57}function c(A){return 48<=A&&A<=57||97<=A&&A<=102||65<=A&&A<=70}function v(A){return A>=48&&A<=55}a=[5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279];function m(A){return A===32||A===9||A===11||A===12||A===160||A>=5760&&a.indexOf(A)>=0}function d(A){return A===10||A===13||A===8232||A===8233}function p(A){if(A<=65535)return String.fromCharCode(A);var S=String.fromCharCode(Math.floor((A-65536)/1024)+55296),B=String.fromCharCode((A-65536)%1024+56320);return S+B}for(r=new Array(128),i=0;i<128;++i)r[i]=i>=97&&i<=122||i>=65&&i<=90||i===36||i===95;for(u=new Array(128),i=0;i<128;++i)u[i]=i>=97&&i<=122||i>=65&&i<=90||i>=48&&i<=57||i===36||i===95;function f(A){return A<128?r[A]:s.NonAsciiIdentifierStart.test(p(A))}function h(A){return A<128?u[A]:s.NonAsciiIdentifierPart.test(p(A))}function w(A){return A<128?r[A]:t.NonAsciiIdentifierStart.test(p(A))}function T(A){return A<128?u[A]:t.NonAsciiIdentifierPart.test(p(A))}n.exports={isDecimalDigit:o,isHexDigit:c,isOctalDigit:v,isWhiteSpace:m,isLineTerminator:d,isIdentifierStartES5:f,isIdentifierPartES5:h,isIdentifierStartES6:w,isIdentifierPartES6:T};}();}}),Tm=Z({"node_modules/esutils/lib/keyword.js"(e,n){re(),function(){var t=$a();function s(f){switch(f){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"let":return !0;default:return !1}}function a(f,h){return !h&&f==="yield"?!1:r(f,h)}function r(f,h){if(h&&s(f))return !0;switch(f.length){case 2:return f==="if"||f==="in"||f==="do";case 3:return f==="var"||f==="for"||f==="new"||f==="try";case 4:return f==="this"||f==="else"||f==="case"||f==="void"||f==="with"||f==="enum";case 5:return f==="while"||f==="break"||f==="catch"||f==="throw"||f==="const"||f==="yield"||f==="class"||f==="super";case 6:return f==="return"||f==="typeof"||f==="delete"||f==="switch"||f==="export"||f==="import";case 7:return f==="default"||f==="finally"||f==="extends";case 8:return f==="function"||f==="continue"||f==="debugger";case 10:return f==="instanceof";default:return !1}}function u(f,h){return f==="null"||f==="true"||f==="false"||a(f,h)}function i(f,h){return f==="null"||f==="true"||f==="false"||r(f,h)}function o(f){return f==="eval"||f==="arguments"}function c(f){var h,w,T;if(f.length===0||(T=f.charCodeAt(0),!t.isIdentifierStartES5(T)))return !1;for(h=1,w=f.length;h<w;++h)if(T=f.charCodeAt(h),!t.isIdentifierPartES5(T))return !1;return !0}function v(f,h){return (f-55296)*1024+(h-56320)+65536}function m(f){var h,w,T,A,S;if(f.length===0)return !1;for(S=t.isIdentifierStartES6,h=0,w=f.length;h<w;++h){if(T=f.charCodeAt(h),55296<=T&&T<=56319){if(++h,h>=w||(A=f.charCodeAt(h),!(56320<=A&&A<=57343)))return !1;T=v(T,A);}if(!S(T))return !1;S=t.isIdentifierPartES6;}return !0}function d(f,h){return c(f)&&!u(f,h)}function p(f,h){return m(f)&&!i(f,h)}n.exports={isKeywordES5:a,isKeywordES6:r,isReservedWordES5:u,isReservedWordES6:i,isRestrictedWord:o,isIdentifierNameES5:c,isIdentifierNameES6:m,isIdentifierES5:d,isIdentifierES6:p};}();}}),Bm=Z({"node_modules/esutils/lib/utils.js"(e){re(),function(){e.ast=bm(),e.code=$a(),e.keyword=Tm();}();}}),It=Z({"src/language-js/utils/is-block-comment.js"(e,n){re();var t=new Set(["Block","CommentBlock","MultiLine"]),s=a=>t.has(a==null?void 0:a.type);n.exports=s;}}),Nm=Z({"src/language-js/utils/is-node-matches.js"(e,n){re();function t(a,r){let u=r.split(".");for(let i=u.length-1;i>=0;i--){let o=u[i];if(i===0)return a.type==="Identifier"&&a.name===o;if(a.type!=="MemberExpression"||a.optional||a.computed||a.property.type!=="Identifier"||a.property.name!==o)return !1;a=a.object;}}function s(a,r){return r.some(u=>t(a,u))}n.exports=s;}}),Ke=Z({"src/language-js/utils/index.js"(e,n){re();var t=Bm().keyword.isIdentifierNameES5,{getLast:s,hasNewline:a,skipWhitespace:r,isNonEmptyArray:u,isNextLineEmptyAfterIndex:i,getStringWidth:o}=Ue(),{locStart:c,locEnd:v,hasSameLocStart:m}=st(),d=It(),p=Nm(),f="(?:(?=.)\\s)",h=new RegExp("^".concat(f,"*:")),w=new RegExp("^".concat(f,"*::"));function T(O){var fe,Te;return ((fe=O.extra)===null||fe===void 0?void 0:fe.parenthesized)&&d((Te=O.trailingComments)===null||Te===void 0?void 0:Te[0])&&h.test(O.trailingComments[0].value)}function A(O){let fe=O==null?void 0:O[0];return d(fe)&&w.test(fe.value)}function S(O,fe){if(!O||typeof O!="object")return !1;if(Array.isArray(O))return O.some($e=>S($e,fe));let Te=fe(O);return typeof Te=="boolean"?Te:Object.values(O).some($e=>S($e,fe))}function B(O){return O.type==="AssignmentExpression"||O.type==="BinaryExpression"||O.type==="LogicalExpression"||O.type==="NGPipeExpression"||O.type==="ConditionalExpression"||ue(O)||De(O)||O.type==="SequenceExpression"||O.type==="TaggedTemplateExpression"||O.type==="BindExpression"||O.type==="UpdateExpression"&&!O.prefix||O.type==="TSAsExpression"||O.type==="TSNonNullExpression"}function I(O){var fe,Te,$e,Je,Ze,ut;return O.expressions?O.expressions[0]:(fe=(Te=($e=(Je=(Ze=(ut=O.left)!==null&&ut!==void 0?ut:O.test)!==null&&Ze!==void 0?Ze:O.callee)!==null&&Je!==void 0?Je:O.object)!==null&&$e!==void 0?$e:O.tag)!==null&&Te!==void 0?Te:O.argument)!==null&&fe!==void 0?fe:O.expression}function k(O,fe){if(fe.expressions)return ["expressions",0];if(fe.left)return ["left"];if(fe.test)return ["test"];if(fe.object)return ["object"];if(fe.callee)return ["callee"];if(fe.tag)return ["tag"];if(fe.argument)return ["argument"];if(fe.expression)return ["expression"];throw new Error("Unexpected node has no left side.")}function P(O){return O=new Set(O),fe=>O.has(fe==null?void 0:fe.type)}var C=P(["Line","CommentLine","SingleLine","HashbangComment","HTMLOpen","HTMLClose"]),D=P(["ExportDefaultDeclaration","ExportDefaultSpecifier","DeclareExportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"]);function g(O){let fe=O.getParentNode();return O.getName()==="declaration"&&D(fe)?fe:null}var F=P(["BooleanLiteral","DirectiveLiteral","Literal","NullLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","RegExpLiteral","StringLiteral","TemplateLiteral","TSTypeLiteral","JSXText"]);function l(O){return O.type==="NumericLiteral"||O.type==="Literal"&&typeof O.value=="number"}function E(O){return O.type==="UnaryExpression"&&(O.operator==="+"||O.operator==="-")&&l(O.argument)}function y(O){return O.type==="StringLiteral"||O.type==="Literal"&&typeof O.value=="string"}var N=P(["ObjectTypeAnnotation","TSTypeLiteral","TSMappedType"]),x=P(["FunctionExpression","ArrowFunctionExpression"]);function b(O){return O.type==="FunctionExpression"||O.type==="ArrowFunctionExpression"&&O.body.type==="BlockStatement"}function L(O){return ue(O)&&O.callee.type==="Identifier"&&["async","inject","fakeAsync","waitForAsync"].includes(O.callee.name)}var M=P(["JSXElement","JSXFragment"]);function j(O,fe){if(O.parentParser!=="markdown"&&O.parentParser!=="mdx")return !1;let Te=fe.getNode();if(!Te.expression||!M(Te.expression))return !1;let $e=fe.getParentNode();return $e.type==="Program"&&$e.body.length===1}function $(O){return O.kind==="get"||O.kind==="set"}function V(O){return $(O)||m(O,O.value)}function q(O){return (O.type==="ObjectTypeProperty"||O.type==="ObjectTypeInternalSlot")&&O.value.type==="FunctionTypeAnnotation"&&!O.static&&!V(O)}function Y(O){return (O.type==="TypeAnnotation"||O.type==="TSTypeAnnotation")&&O.typeAnnotation.type==="FunctionTypeAnnotation"&&!O.static&&!m(O,O.typeAnnotation)}var H=P(["BinaryExpression","LogicalExpression","NGPipeExpression"]);function R(O){return De(O)||O.type==="BindExpression"&&Boolean(O.object)}var Q=new Set(["AnyTypeAnnotation","TSAnyKeyword","NullLiteralTypeAnnotation","TSNullKeyword","ThisTypeAnnotation","TSThisType","NumberTypeAnnotation","TSNumberKeyword","VoidTypeAnnotation","TSVoidKeyword","BooleanTypeAnnotation","TSBooleanKeyword","BigIntTypeAnnotation","TSBigIntKeyword","SymbolTypeAnnotation","TSSymbolKeyword","StringTypeAnnotation","TSStringKeyword","BooleanLiteralTypeAnnotation","StringLiteralTypeAnnotation","BigIntLiteralTypeAnnotation","NumberLiteralTypeAnnotation","TSLiteralType","TSTemplateLiteralType","EmptyTypeAnnotation","MixedTypeAnnotation","TSNeverKeyword","TSObjectKeyword","TSUndefinedKeyword","TSUnknownKeyword"]);function ee(O){return O?!!((O.type==="GenericTypeAnnotation"||O.type==="TSTypeReference")&&!O.typeParameters||Q.has(O.type)):!1}function te(O){let fe=/^(?:before|after)(?:Each|All)$/;return O.callee.type==="Identifier"&&fe.test(O.callee.name)&&O.arguments.length===1}var oe=["it","it.only","it.skip","describe","describe.only","describe.skip","test","test.only","test.skip","test.step","test.describe","test.describe.only","test.describe.parallel","test.describe.parallel.only","test.describe.serial","test.describe.serial.only","skip","xit","xdescribe","xtest","fit","fdescribe","ftest"];function W(O){return p(O,oe)}function X(O,fe){if(O.type!=="CallExpression")return !1;if(O.arguments.length===1){if(L(O)&&fe&&X(fe))return x(O.arguments[0]);if(te(O))return L(O.arguments[0])}else if((O.arguments.length===2||O.arguments.length===3)&&(O.arguments[0].type==="TemplateLiteral"||y(O.arguments[0]))&&W(O.callee))return O.arguments[2]&&!l(O.arguments[2])?!1:(O.arguments.length===2?x(O.arguments[1]):b(O.arguments[1])&&Se(O.arguments[1]).length<=1)||L(O.arguments[1]);return !1}var ue=P(["CallExpression","OptionalCallExpression"]),De=P(["MemberExpression","OptionalMemberExpression"]);function ie(O){let fe="expressions";O.type==="TSTemplateLiteralType"&&(fe="types");let Te=O[fe];return Te.length===0?!1:Te.every($e=>{if(se($e))return !1;if($e.type==="Identifier"||$e.type==="ThisExpression")return !0;if(De($e)){let Je=$e;for(;De(Je);)if(Je.property.type!=="Identifier"&&Je.property.type!=="Literal"&&Je.property.type!=="StringLiteral"&&Je.property.type!=="NumericLiteral"||(Je=Je.object,se(Je)))return !1;return Je.type==="Identifier"||Je.type==="ThisExpression"}return !1})}function G(O,fe){return O==="+"||O==="-"?O+fe:fe}function z(O,fe){let Te=c(fe),$e=r(O,v(fe));return $e!==!1&&O.slice(Te,Te+2)==="/*"&&O.slice($e,$e+2)==="*/"}function U(O,fe){return M(fe)?Re(fe):se(fe,Le.Leading,Te=>a(O,v(Te)))}function le(O,fe){return fe.parser!=="json"&&y(O.key)&&ve(O.key).slice(1,-1)===O.key.value&&(t(O.key.value)&&!(fe.parser==="babel-ts"&&O.type==="ClassProperty"||fe.parser==="typescript"&&O.type==="PropertyDefinition")||ge(O.key.value)&&String(Number(O.key.value))===O.key.value&&(fe.parser==="babel"||fe.parser==="acorn"||fe.parser==="espree"||fe.parser==="meriyah"||fe.parser==="__babel_estree"))}function ge(O){return /^(?:\d+|\d+\.\d+)$/.test(O)}function Ae(O,fe){let Te=/^[fx]?(?:describe|it|test)$/;return fe.type==="TaggedTemplateExpression"&&fe.quasi===O&&fe.tag.type==="MemberExpression"&&fe.tag.property.type==="Identifier"&&fe.tag.property.name==="each"&&(fe.tag.object.type==="Identifier"&&Te.test(fe.tag.object.name)||fe.tag.object.type==="MemberExpression"&&fe.tag.object.property.type==="Identifier"&&(fe.tag.object.property.name==="only"||fe.tag.object.property.name==="skip")&&fe.tag.object.object.type==="Identifier"&&Te.test(fe.tag.object.object.name))}function Ne(O){return O.quasis.some(fe=>fe.value.raw.includes(`
	`))}function ke(O,fe){return (O.type==="TemplateLiteral"&&Ne(O)||O.type==="TaggedTemplateExpression"&&Ne(O.quasi))&&!a(fe,c(O),{backwards:!0})}function ce(O){if(!se(O))return !1;let fe=s(He(O,Le.Dangling));return fe&&!d(fe)}function pe(O){if(O.length<=1)return !1;let fe=0;for(let Te of O)if(x(Te)){if(fe+=1,fe>1)return !0}else if(ue(Te)){for(let $e of Te.arguments)if(x($e))return !0}return !1}function de(O){let fe=O.getValue(),Te=O.getParentNode();return ue(fe)&&ue(Te)&&Te.callee===fe&&fe.arguments.length>Te.arguments.length&&Te.arguments.length>0}function ae(O,fe){if(fe>=2)return !1;let Te=Je=>ae(Je,fe+1),$e=O.type==="Literal"&&"regex"in O&&O.regex.pattern||O.type==="RegExpLiteral"&&O.pattern;return $e&&o($e)>5?!1:O.type==="Literal"||O.type==="BigIntLiteral"||O.type==="DecimalLiteral"||O.type==="BooleanLiteral"||O.type==="NullLiteral"||O.type==="NumericLiteral"||O.type==="RegExpLiteral"||O.type==="StringLiteral"||O.type==="Identifier"||O.type==="ThisExpression"||O.type==="Super"||O.type==="PrivateName"||O.type==="PrivateIdentifier"||O.type==="ArgumentPlaceholder"||O.type==="Import"?!0:O.type==="TemplateLiteral"?O.quasis.every(Je=>!Je.value.raw.includes(`
	`))&&O.expressions.every(Te):O.type==="ObjectExpression"?O.properties.every(Je=>!Je.computed&&(Je.shorthand||Je.value&&Te(Je.value))):O.type==="ArrayExpression"?O.elements.every(Je=>Je===null||Te(Je)):ze(O)?(O.type==="ImportExpression"||ae(O.callee,fe))&&Xe(O).every(Te):De(O)?ae(O.object,fe)&&ae(O.property,fe):O.type==="UnaryExpression"&&(O.operator==="!"||O.operator==="-")?ae(O.argument,fe):O.type==="TSNonNullExpression"?ae(O.expression,fe):!1}function ve(O){var fe,Te;return (fe=(Te=O.extra)===null||Te===void 0?void 0:Te.raw)!==null&&fe!==void 0?fe:O.raw}function K(O){return O}function he(O){return O.filepath&&/\.tsx$/i.test(O.filepath)}function ye(O){let fe=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"es5";return O.trailingComma==="es5"&&fe==="es5"||O.trailingComma==="all"&&(fe==="all"||fe==="es5")}function Ce(O,fe){switch(O=Ee(O),O.type){case"FunctionExpression":case"ClassExpression":case"DoExpression":return fe;case"ObjectExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return Ce(O.object,fe);case"TaggedTemplateExpression":return O.tag.type==="FunctionExpression"?!1:Ce(O.tag,fe);case"CallExpression":case"OptionalCallExpression":return O.callee.type==="FunctionExpression"?!1:Ce(O.callee,fe);case"ConditionalExpression":return Ce(O.test,fe);case"UpdateExpression":return !O.prefix&&Ce(O.argument,fe);case"BindExpression":return O.object&&Ce(O.object,fe);case"SequenceExpression":return Ce(O.expressions[0],fe);case"TSAsExpression":case"TSNonNullExpression":return Ce(O.expression,fe);default:return !1}}var Ie={"==":!0,"!=":!0,"===":!0,"!==":!0},Fe={"*":!0,"/":!0,"%":!0},me={">>":!0,">>>":!0,"<<":!0};function _(O,fe){return !(ne(fe)!==ne(O)||O==="**"||Ie[O]&&Ie[fe]||fe==="%"&&Fe[O]||O==="%"&&Fe[fe]||fe!==O&&Fe[fe]&&Fe[O]||me[O]&&me[fe])}var J=new Map([["|>"],["??"],["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"],["**"]].flatMap((O,fe)=>O.map(Te=>[Te,fe])));function ne(O){return J.get(O)}function Ee(O){for(;O.left;)O=O.left;return O}function We(O){return Boolean(me[O])||O==="|"||O==="^"||O==="&"}function Be(O){var fe;if(O.rest)return !0;let Te=Se(O);return ((fe=s(Te))===null||fe===void 0?void 0:fe.type)==="RestElement"}var Pe=new WeakMap;function Se(O){if(Pe.has(O))return Pe.get(O);let fe=[];return O.this&&fe.push(O.this),Array.isArray(O.parameters)?fe.push(...O.parameters):Array.isArray(O.params)&&fe.push(...O.params),O.rest&&fe.push(O.rest),Pe.set(O,fe),fe}function Qe(O,fe){let Te=O.getValue(),$e=0,Je=Ze=>fe(Ze,$e++);Te.this&&O.call(Je,"this"),Array.isArray(Te.parameters)?O.each(Je,"parameters"):Array.isArray(Te.params)&&O.each(Je,"params"),Te.rest&&O.call(Je,"rest");}var xe=new WeakMap;function Xe(O){if(xe.has(O))return xe.get(O);let fe=O.arguments;return O.type==="ImportExpression"&&(fe=[O.source],O.attributes&&fe.push(O.attributes)),xe.set(O,fe),fe}function _e(O,fe){let Te=O.getValue();Te.type==="ImportExpression"?(O.call($e=>fe($e,0),"source"),Te.attributes&&O.call($e=>fe($e,1),"attributes")):O.each(fe,"arguments");}function je(O){return O.value.trim()==="prettier-ignore"&&!O.unignore}function Re(O){return O&&(O.prettierIgnore||se(O,Le.PrettierIgnore))}function be(O){let fe=O.getValue();return Re(fe)}var Le={Leading:1<<1,Trailing:1<<2,Dangling:1<<3,Block:1<<4,Line:1<<5,PrettierIgnore:1<<6,First:1<<7,Last:1<<8},qe=(O,fe)=>{if(typeof O=="function"&&(fe=O,O=0),O||fe)return (Te,$e,Je)=>!(O&Le.Leading&&!Te.leading||O&Le.Trailing&&!Te.trailing||O&Le.Dangling&&(Te.leading||Te.trailing)||O&Le.Block&&!d(Te)||O&Le.Line&&!C(Te)||O&Le.First&&$e!==0||O&Le.Last&&$e!==Je.length-1||O&Le.PrettierIgnore&&!je(Te)||fe&&!fe(Te))};function se(O,fe,Te){if(!u(O==null?void 0:O.comments))return !1;let $e=qe(fe,Te);return $e?O.comments.some($e):!0}function He(O,fe,Te){if(!Array.isArray(O==null?void 0:O.comments))return [];let $e=qe(fe,Te);return $e?O.comments.filter($e):O.comments}var Me=(O,fe)=>{let{originalText:Te}=fe;return i(Te,v(O))};function ze(O){return ue(O)||O.type==="NewExpression"||O.type==="ImportExpression"}function nt(O){return O&&(O.type==="ObjectProperty"||O.type==="Property"&&!O.method&&O.kind==="init")}function tt(O){return Boolean(O.__isUsingHackPipeline)}var pt=Symbol("ifWithoutBlockAndSameLineComment");n.exports={getFunctionParameters:Se,iterateFunctionParametersPath:Qe,getCallArguments:Xe,iterateCallArgumentsPath:_e,hasRestParameter:Be,getLeftSide:I,getLeftSidePathName:k,getParentExportDeclaration:g,getTypeScriptMappedTypeModifier:G,hasFlowAnnotationComment:A,hasFlowShorthandAnnotationComment:T,hasLeadingOwnLineComment:U,hasNakedLeftSide:B,hasNode:S,hasIgnoreComment:be,hasNodeIgnoreComment:Re,identity:K,isBinaryish:H,isCallLikeExpression:ze,isEnabledHackPipeline:tt,isLineComment:C,isPrettierIgnoreComment:je,isCallExpression:ue,isMemberExpression:De,isExportDeclaration:D,isFlowAnnotationComment:z,isFunctionCompositionArgs:pe,isFunctionNotation:V,isFunctionOrArrowExpression:x,isGetterOrSetter:$,isJestEachTemplateLiteral:Ae,isJsxNode:M,isLiteral:F,isLongCurriedCallExpression:de,isSimpleCallArgument:ae,isMemberish:R,isNumericLiteral:l,isSignedNumericLiteral:E,isObjectProperty:nt,isObjectType:N,isObjectTypePropertyAFunction:q,isSimpleType:ee,isSimpleNumber:ge,isSimpleTemplateLiteral:ie,isStringLiteral:y,isStringPropSafeToUnquote:le,isTemplateOnItsOwnLine:ke,isTestCall:X,isTheOnlyJsxElementInMarkdown:j,isTSXFile:he,isTypeAnnotationAFunction:Y,isNextLineEmpty:Me,needsHardlineAfterDanglingComment:ce,rawText:ve,shouldPrintComma:ye,isBitwiseOperator:We,shouldFlatten:_,startsWithNoLookaheadToken:Ce,getPrecedence:ne,hasComment:se,getComments:He,CommentCheckFlags:Le,markerForIfWithoutBlockAndSameLineComment:pt};}}),Lt=Z({"src/language-js/print/template-literal.js"(e,n){re();var t=it(),{getStringWidth:s,getIndentSize:a}=Ue(),{builders:{join:r,hardline:u,softline:i,group:o,indent:c,align:v,lineSuffixBoundary:m,addAlignmentToDoc:d},printer:{printDocToString:p},utils:{mapDoc:f}}=Oe(),{isBinaryish:h,isJestEachTemplateLiteral:w,isSimpleTemplateLiteral:T,hasComment:A,isMemberExpression:S}=Ke();function B(g,F,l){let E=g.getValue();if(E.type==="TemplateLiteral"&&w(E,g.getParentNode())){let M=I(g,l,F);if(M)return M}let N="expressions";E.type==="TSTemplateLiteralType"&&(N="types");let x=[],b=g.map(F,N),L=T(E);return L&&(b=b.map(M=>p(M,Object.assign(Object.assign({},l),{},{printWidth:Number.POSITIVE_INFINITY})).formatted)),x.push(m,"`"),g.each(M=>{let j=M.getName();if(x.push(F()),j<b.length){let{tabWidth:$}=l,V=M.getValue(),q=a(V.value.raw,$),Y=b[j];if(!L){let R=E[N][j];(A(R)||S(R)||R.type==="ConditionalExpression"||R.type==="SequenceExpression"||R.type==="TSAsExpression"||h(R))&&(Y=[c([i,Y]),i]);}let H=q===0&&V.value.raw.endsWith(`
	`)?v(Number.NEGATIVE_INFINITY,Y):d(Y,q,$);x.push(o(["${",H,m,"}"]));}},"quasis"),x.push("`"),x}function I(g,F,l){let E=g.getNode(),y=E.quasis[0].value.raw.trim().split(/\s*\|\s*/);if(y.length>1||y.some(N=>N.length>0)){F.__inJestEach=!0;let N=g.map(l,"expressions");F.__inJestEach=!1;let x=[],b=N.map(V=>"${"+p(V,Object.assign(Object.assign({},F),{},{printWidth:Number.POSITIVE_INFINITY,endOfLine:"lf"})).formatted+"}"),L=[{hasLineBreak:!1,cells:[]}];for(let V=1;V<E.quasis.length;V++){let q=t(L),Y=b[V-1];q.cells.push(Y),Y.includes(`
	`)&&(q.hasLineBreak=!0),E.quasis[V].value.raw.includes(`
	`)&&L.push({hasLineBreak:!1,cells:[]});}let M=Math.max(y.length,...L.map(V=>V.cells.length)),j=Array.from({length:M}).fill(0),$=[{cells:y},...L.filter(V=>V.cells.length>0)];for(let{cells:V}of $.filter(q=>!q.hasLineBreak))for(let[q,Y]of V.entries())j[q]=Math.max(j[q],s(Y));return x.push(m,"`",c([u,r(u,$.map(V=>r(" | ",V.cells.map((q,Y)=>V.hasLineBreak?q:q+" ".repeat(j[Y]-s(q))))))]),u,"`"),x}}function k(g,F){let l=g.getValue(),E=F();return A(l)&&(E=o([c([i,E]),i])),["${",E,m,"}"]}function P(g,F){return g.map(l=>k(l,F),"expressions")}function C(g,F){return f(g,l=>typeof l=="string"?F?l.replace(/(\\*)`/g,"$1$1\\`"):D(l):l)}function D(g){return g.replace(/([\\`]|\${)/g,"\\$1")}n.exports={printTemplateLiteral:B,printTemplateExpressions:P,escapeTemplateCharacters:C,uncookTemplateElementValue:D};}}),wm=Z({"src/language-js/embed/markdown.js"(e,n){re();var{builders:{indent:t,softline:s,literalline:a,dedentToRoot:r}}=Oe(),{escapeTemplateCharacters:u}=Lt();function i(c,v,m){let p=c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g,(T,A)=>"\\".repeat(A.length/2)+"`"),f=o(p),h=f!=="";h&&(p=p.replace(new RegExp("^".concat(f),"gm"),""));let w=u(m(p,{parser:"markdown",__inJsTemplate:!0},{stripTrailingHardline:!0}),!0);return ["`",h?t([s,w]):[a,r(w)],s,"`"]}function o(c){let v=c.match(/^([^\S\n]*)\S/m);return v===null?"":v[1]}n.exports=i;}}),_m=Z({"src/language-js/embed/css.js"(e,n){re();var{isNonEmptyArray:t}=Ue(),{builders:{indent:s,hardline:a,softline:r},utils:{mapDoc:u,replaceEndOfLine:i,cleanDoc:o}}=Oe(),{printTemplateExpressions:c}=Lt();function v(p,f,h){let w=p.getValue(),T=w.quasis.map(k=>k.value.raw),A=0,S=T.reduce((k,P,C)=>C===0?P:k+"@prettier-placeholder-"+A+++"-id"+P,""),B=h(S,{parser:"scss"},{stripTrailingHardline:!0}),I=c(p,f);return m(B,w,I)}function m(p,f,h){if(f.quasis.length===1&&!f.quasis[0].value.raw.trim())return "``";let T=d(p,h);if(!T)throw new Error("Couldn't insert all the expressions");return ["`",s([a,T]),r,"`"]}function d(p,f){if(!t(f))return p;let h=0,w=u(o(p),T=>typeof T!="string"||!T.includes("@prettier-placeholder")?T:T.split(/@prettier-placeholder-(\d+)-id/).map((A,S)=>S%2===0?i(A):(h++,f[A])));return f.length===h?w:null}n.exports=v;}}),Pm=Z({"src/language-js/embed/graphql.js"(e,n){re();var{builders:{indent:t,join:s,hardline:a}}=Oe(),{escapeTemplateCharacters:r,printTemplateExpressions:u}=Lt();function i(c,v,m){let d=c.getValue(),p=d.quasis.length;if(p===1&&d.quasis[0].value.raw.trim()==="")return "``";let f=u(c,v),h=[];for(let w=0;w<p;w++){let T=d.quasis[w],A=w===0,S=w===p-1,B=T.value.cooked,I=B.split(`
	`),k=I.length,P=f[w],C=k>2&&I[0].trim()===""&&I[1].trim()==="",D=k>2&&I[k-1].trim()===""&&I[k-2].trim()==="",g=I.every(l=>/^\s*(?:#[^\n\r]*)?$/.test(l));if(!S&&/#[^\n\r]*$/.test(I[k-1]))return null;let F=null;g?F=o(I):F=m(B,{parser:"graphql"},{stripTrailingHardline:!0}),F?(F=r(F,!1),!A&&C&&h.push(""),h.push(F),!S&&D&&h.push("")):!A&&!S&&C&&h.push(""),P&&h.push(P);}return ["`",t([a,s(a,h)]),a,"`"]}function o(c){let v=[],m=!1,d=c.map(p=>p.trim());for(let[p,f]of d.entries())f!==""&&(d[p-1]===""&&m?v.push([a,f]):v.push(f),m=!0);return v.length===0?null:s(a,v)}n.exports=i;}}),km=Z({"src/language-js/embed/html.js"(e,n){re();var{builders:{indent:t,line:s,hardline:a,group:r},utils:{mapDoc:u}}=Oe(),{printTemplateExpressions:i,uncookTemplateElementValue:o}=Lt(),c=0;function v(m,d,p,f,h){let{parser:w}=h,T=m.getValue(),A=c;c=c+1>>>0;let S=E=>"PRETTIER_HTML_PLACEHOLDER_".concat(E,"_").concat(A,"_IN_JS"),B=T.quasis.map((E,y,N)=>y===N.length-1?E.value.cooked:E.value.cooked+S(y)).join(""),I=i(m,d);if(I.length===0&&B.trim().length===0)return "``";let k=new RegExp(S("(\\d+)"),"g"),P=0,C=p(B,{parser:w,__onHtmlRoot(E){P=E.children.length;}},{stripTrailingHardline:!0}),D=u(C,E=>{if(typeof E!="string")return E;let y=[],N=E.split(k);for(let x=0;x<N.length;x++){let b=N[x];if(x%2===0){b&&(b=o(b),f.__embeddedInHtml&&(b=b.replace(/<\/(script)\b/gi,"<\\/$1")),y.push(b));continue}let L=Number(b);y.push(I[L]);}return y}),g=/^\s/.test(B)?" ":"",F=/\s$/.test(B)?" ":"",l=f.htmlWhitespaceSensitivity==="ignore"?a:g&&F?s:null;return r(l?["`",t([l,r(D)]),l,"`"]:["`",g,P>1?t(r(D)):r(D),F,"`"])}n.exports=v;}}),Im=Z({"src/language-js/embed.js"(e,n){re();var{hasComment:t,CommentCheckFlags:s,isObjectProperty:a}=Ke(),r=wm(),u=_m(),i=Pm(),o=km();function c(C){if(d(C)||w(C)||T(C)||p(C))return "css";if(B(C))return "graphql";if(k(C))return "html";if(f(C))return "angular";if(m(C))return "markdown"}function v(C,D,g,F){let l=C.getValue();if(l.type!=="TemplateLiteral"||P(l))return;let E=c(C);if(!!E){if(E==="markdown")return r(C,D,g);if(E==="css")return u(C,D,g);if(E==="graphql")return i(C,D,g);if(E==="html"||E==="angular")return o(C,D,g,F,{parser:E})}}function m(C){let D=C.getValue(),g=C.getParentNode();return g&&g.type==="TaggedTemplateExpression"&&D.quasis.length===1&&g.tag.type==="Identifier"&&(g.tag.name==="md"||g.tag.name==="markdown")}function d(C){let D=C.getValue(),g=C.getParentNode(),F=C.getParentNode(1);return F&&D.quasis&&g.type==="JSXExpressionContainer"&&F.type==="JSXElement"&&F.openingElement.name.name==="style"&&F.openingElement.attributes.some(l=>l.name.name==="jsx")||g&&g.type==="TaggedTemplateExpression"&&g.tag.type==="Identifier"&&g.tag.name==="css"||g&&g.type==="TaggedTemplateExpression"&&g.tag.type==="MemberExpression"&&g.tag.object.name==="css"&&(g.tag.property.name==="global"||g.tag.property.name==="resolve")}function p(C){return C.match(D=>D.type==="TemplateLiteral",(D,g)=>D.type==="ArrayExpression"&&g==="elements",(D,g)=>a(D)&&D.key.type==="Identifier"&&D.key.name==="styles"&&g==="value",...h)}function f(C){return C.match(D=>D.type==="TemplateLiteral",(D,g)=>a(D)&&D.key.type==="Identifier"&&D.key.name==="template"&&g==="value",...h)}var h=[(C,D)=>C.type==="ObjectExpression"&&D==="properties",(C,D)=>C.type==="CallExpression"&&C.callee.type==="Identifier"&&C.callee.name==="Component"&&D==="arguments",(C,D)=>C.type==="Decorator"&&D==="expression"];function w(C){let D=C.getParentNode();if(!D||D.type!=="TaggedTemplateExpression")return !1;let g=D.tag.type==="ParenthesizedExpression"?D.tag.expression:D.tag;switch(g.type){case"MemberExpression":return A(g.object)||S(g);case"CallExpression":return A(g.callee)||g.callee.type==="MemberExpression"&&(g.callee.object.type==="MemberExpression"&&(A(g.callee.object.object)||S(g.callee.object))||g.callee.object.type==="CallExpression"&&A(g.callee.object.callee));case"Identifier":return g.name==="css";default:return !1}}function T(C){let D=C.getParentNode(),g=C.getParentNode(1);return g&&D.type==="JSXExpressionContainer"&&g.type==="JSXAttribute"&&g.name.type==="JSXIdentifier"&&g.name.name==="css"}function A(C){return C.type==="Identifier"&&C.name==="styled"}function S(C){return /^[A-Z]/.test(C.object.name)&&C.property.name==="extend"}function B(C){let D=C.getValue(),g=C.getParentNode();return I(D,"GraphQL")||g&&(g.type==="TaggedTemplateExpression"&&(g.tag.type==="MemberExpression"&&g.tag.object.name==="graphql"&&g.tag.property.name==="experimental"||g.tag.type==="Identifier"&&(g.tag.name==="gql"||g.tag.name==="graphql"))||g.type==="CallExpression"&&g.callee.type==="Identifier"&&g.callee.name==="graphql")}function I(C,D){return t(C,s.Block|s.Leading,g=>{let{value:F}=g;return F===" ".concat(D," ")})}function k(C){return I(C.getValue(),"HTML")||C.match(D=>D.type==="TemplateLiteral",(D,g)=>D.type==="TaggedTemplateExpression"&&D.tag.type==="Identifier"&&D.tag.name==="html"&&g==="quasi")}function P(C){let{quasis:D}=C;return D.some(g=>{let{value:{cooked:F}}=g;return F===null})}n.exports=v;}}),Lm=Z({"src/language-js/clean.js"(e,n){re();var t=It(),s=new Set(["range","raw","comments","leadingComments","trailingComments","innerComments","extra","start","end","loc","flags","errors","tokens"]),a=u=>{for(let i of u.quasis)delete i.value;};function r(u,i,o){if(u.type==="Program"&&delete i.sourceType,(u.type==="BigIntLiteral"||u.type==="BigIntLiteralTypeAnnotation")&&i.value&&(i.value=i.value.toLowerCase()),(u.type==="BigIntLiteral"||u.type==="Literal")&&i.bigint&&(i.bigint=i.bigint.toLowerCase()),u.type==="DecimalLiteral"&&(i.value=Number(i.value)),u.type==="Literal"&&i.decimal&&(i.decimal=Number(i.decimal)),u.type==="EmptyStatement"||u.type==="JSXText"||u.type==="JSXExpressionContainer"&&(u.expression.type==="Literal"||u.expression.type==="StringLiteral")&&u.expression.value===" ")return null;if((u.type==="Property"||u.type==="ObjectProperty"||u.type==="MethodDefinition"||u.type==="ClassProperty"||u.type==="ClassMethod"||u.type==="PropertyDefinition"||u.type==="TSDeclareMethod"||u.type==="TSPropertySignature"||u.type==="ObjectTypeProperty")&&typeof u.key=="object"&&u.key&&(u.key.type==="Literal"||u.key.type==="NumericLiteral"||u.key.type==="StringLiteral"||u.key.type==="Identifier")&&delete i.key,u.type==="JSXElement"&&u.openingElement.name.name==="style"&&u.openingElement.attributes.some(m=>m.name.name==="jsx"))for(let{type:m,expression:d}of i.children)m==="JSXExpressionContainer"&&d.type==="TemplateLiteral"&&a(d);u.type==="JSXAttribute"&&u.name.name==="css"&&u.value.type==="JSXExpressionContainer"&&u.value.expression.type==="TemplateLiteral"&&a(i.value.expression),u.type==="JSXAttribute"&&u.value&&u.value.type==="Literal"&&/["']|&quot;|&apos;/.test(u.value.value)&&(i.value.value=i.value.value.replace(/["']|&quot;|&apos;/g,'"'));let c=u.expression||u.callee;if(u.type==="Decorator"&&c.type==="CallExpression"&&c.callee.name==="Component"&&c.arguments.length===1){let m=u.expression.arguments[0].properties;for(let[d,p]of i.expression.arguments[0].properties.entries())switch(m[d].key.name){case"styles":p.value.type==="ArrayExpression"&&a(p.value.elements[0]);break;case"template":p.value.type==="TemplateLiteral"&&a(p.value);break}}if(u.type==="TaggedTemplateExpression"&&(u.tag.type==="MemberExpression"||u.tag.type==="Identifier"&&(u.tag.name==="gql"||u.tag.name==="graphql"||u.tag.name==="css"||u.tag.name==="md"||u.tag.name==="markdown"||u.tag.name==="html")||u.tag.type==="CallExpression")&&a(i.quasi),u.type==="TemplateLiteral"){var v;(((v=u.leadingComments)===null||v===void 0?void 0:v.some(d=>t(d)&&["GraphQL","HTML"].some(p=>d.value===" ".concat(p," "))))||o.type==="CallExpression"&&o.callee.name==="graphql"||!u.leadingComments)&&a(i);}if(u.type==="InterpreterDirective"&&(i.value=i.value.trimEnd()),(u.type==="TSIntersectionType"||u.type==="TSUnionType")&&u.types.length===1)return i.types[0]}r.ignoredProperties=s,n.exports=r;}}),Ha={};Ut(Ha,{EOL:()=>Pn,arch:()=>jm,cpus:()=>Ya,default:()=>ro,endianness:()=>Ga,freemem:()=>Xa,getNetworkInterfaces:()=>to,hostname:()=>Ja,loadavg:()=>Ua,networkInterfaces:()=>eo,platform:()=>Om,release:()=>Za,tmpDir:()=>wn,tmpdir:()=>_n,totalmem:()=>Ka,type:()=>Qa,uptime:()=>za});function Ga(){if(typeof Sr>"u"){var e=new ArrayBuffer(2),n=new Uint8Array(e),t=new Uint16Array(e);if(n[0]=1,n[1]=2,t[0]===258)Sr="BE";else if(t[0]===513)Sr="LE";else throw new Error("unable to figure out endianess")}return Sr}function Ja(){return typeof globalThis.location<"u"?globalThis.location.hostname:""}function Ua(){return []}function za(){return 0}function Xa(){return Number.MAX_VALUE}function Ka(){return Number.MAX_VALUE}function Ya(){return []}function Qa(){return "Browser"}function Za(){return typeof globalThis.navigator<"u"?globalThis.navigator.appVersion:""}function eo(){}function to(){}function jm(){return "javascript"}function Om(){return "browser"}function wn(){return "/tmp"}var Sr,_n,Pn,ro,qm=mt({"node-modules-polyfills:os"(){re(),_n=wn,Pn=`
	`,ro={EOL:Pn,tmpdir:_n,tmpDir:wn,networkInterfaces:eo,getNetworkInterfaces:to,release:Za,type:Qa,cpus:Ya,totalmem:Ka,freemem:Xa,uptime:za,loadavg:Ua,hostname:Ja,endianness:Ga};}}),Mm=Z({"node-modules-polyfills-commonjs:os"(e,n){re();var t=(qm(),lt(Ha));if(t&&t.default){n.exports=t.default;for(let s in t)n.exports[s]=t[s];}else t&&(n.exports=t);}}),Rm=Z({"node_modules/detect-newline/index.js"(e,n){re();var t=s=>{if(typeof s!="string")throw new TypeError("Expected a string");let a=s.match(/(?:\r?\n)/g)||[];if(a.length===0)return;let r=a.filter(i=>i===`\r
	`).length,u=a.length-r;return r>u?`\r
	`:`
	`};n.exports=t,n.exports.graceful=s=>typeof s=="string"&&t(s)||`
	`;}}),Vm=Z({"node_modules/jest-docblock/build/index.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.extract=p,e.parse=h,e.parseWithComments=w,e.print=T,e.strip=f;function n(){let S=Mm();return n=function(){return S},S}function t(){let S=s(Rm());return t=function(){return S},S}function s(S){return S&&S.__esModule?S:{default:S}}var a=/\*\/$/,r=/^\/\*\*/,u=/^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,i=/(^|\s+)\/\/([^\r\n]*)/g,o=/^(\r?\n)+/,c=/(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,v=/(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,m=/(\r?\n|^) *\* ?/g,d=[];function p(S){let B=S.match(u);return B?B[0].trimLeft():""}function f(S){let B=S.match(u);return B&&B[0]?S.substring(B[0].length):S}function h(S){return w(S).pragmas}function w(S){let B=(0, t().default)(S)||n().EOL;S=S.replace(r,"").replace(a,"").replace(m,"$1");let I="";for(;I!==S;)I=S,S=S.replace(c,"".concat(B,"$1 $2").concat(B));S=S.replace(o,"").trimRight();let k=Object.create(null),P=S.replace(v,"").replace(o,"").trimRight(),C;for(;C=v.exec(S);){let D=C[2].replace(i,"");typeof k[C[1]]=="string"||Array.isArray(k[C[1]])?k[C[1]]=d.concat(k[C[1]],D):k[C[1]]=D;}return {comments:P,pragmas:k}}function T(S){let{comments:B="",pragmas:I={}}=S,k=(0, t().default)(B)||n().EOL,P="/**",C=" *",D=" */",g=Object.keys(I),F=g.map(E=>A(E,I[E])).reduce((E,y)=>E.concat(y),[]).map(E=>C+" "+E+k).join("");if(!B){if(g.length===0)return "";if(g.length===1&&!Array.isArray(I[g[0]])){let E=I[g[0]];return "".concat(P," ").concat(A(g[0],E)[0]).concat(D)}}let l=B.split(k).map(E=>"".concat(C," ").concat(E)).join(k)+k;return P+k+(B?l:"")+(B&&g.length?C+k:"")+F+D}function A(S,B){return d.concat(B).map(I=>"@".concat(S," ").concat(I).trim())}}}),Wm=Z({"src/language-js/utils/get-shebang.js"(e,n){re();function t(s){if(!s.startsWith("#!"))return "";let a=s.indexOf(`
	`);return a===-1?s:s.slice(0,a)}n.exports=t;}}),no=Z({"src/language-js/pragma.js"(e,n){re();var{parseWithComments:t,strip:s,extract:a,print:r}=Vm(),{normalizeEndOfLine:u}=jn(),i=Wm();function o(m){let d=i(m);d&&(m=m.slice(d.length+1));let p=a(m),{pragmas:f,comments:h}=t(p);return {shebang:d,text:m,pragmas:f,comments:h}}function c(m){let d=Object.keys(o(m).pragmas);return d.includes("prettier")||d.includes("format")}function v(m){let{shebang:d,text:p,pragmas:f,comments:h}=o(m),w=s(p),T=r({pragmas:Object.assign({format:""},f),comments:h.trimStart()});return (d?"".concat(d,`
	`):"")+u(T)+(w.startsWith(`
	`)?`
	`:`

	`)+w}n.exports={hasPragma:c,insertPragma:v};}}),uo=Z({"src/language-js/comments.js"(e,n){re();var{getLast:t,hasNewline:s,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:a,getNextNonSpaceNonCommentCharacter:r,hasNewlineInRange:u,addLeadingComment:i,addTrailingComment:o,addDanglingComment:c,getNextNonSpaceNonCommentCharacterIndex:v,isNonEmptyArray:m}=Ue(),{getFunctionParameters:d,isPrettierIgnoreComment:p,isJsxNode:f,hasFlowShorthandAnnotationComment:h,hasFlowAnnotationComment:w,hasIgnoreComment:T,isCallLikeExpression:A,getCallArguments:S,isCallExpression:B,isMemberExpression:I,isObjectProperty:k,isLineComment:P,getComments:C,CommentCheckFlags:D,markerForIfWithoutBlockAndSameLineComment:g}=Ke(),{locStart:F,locEnd:l}=st(),E=It();function y(me){return [ve,De,q,j,$,V,Q,Ae,U,ge,Ne,ke,te,ie,G].some(_=>_(me))}function N(me){return [M,De,Y,Ne,j,$,V,Q,ie,z,le,ge,de,G,he].some(_=>_(me))}function x(me){return [ve,j,$,H,ue,te,ge,X,W,K,G,ae].some(_=>_(me))}function b(me,_){let J=(me.body||me.properties).find(ne=>{let{type:Ee}=ne;return Ee!=="EmptyStatement"});J?i(J,_):c(me,_);}function L(me,_){me.type==="BlockStatement"?b(me,_):i(me,_);}function M(me){let{comment:_,followingNode:J}=me;return J&&Ie(_)?(i(J,_),!0):!1}function j(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee,text:We}=me;if((ne==null?void 0:ne.type)!=="IfStatement"||!Ee)return !1;if(r(We,_,l)===")")return o(J,_),!0;if(J===ne.consequent&&Ee===ne.alternate){if(J.type==="BlockStatement")o(J,_);else {let Pe=_.type==="SingleLine"||_.loc.start.line===_.loc.end.line,Se=_.loc.start.line===J.loc.start.line;Pe&&Se?c(J,_,g):c(ne,_);}return !0}return Ee.type==="BlockStatement"?(b(Ee,_),!0):Ee.type==="IfStatement"?(L(Ee.consequent,_),!0):ne.consequent===Ee?(i(Ee,_),!0):!1}function $(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee,text:We}=me;return (ne==null?void 0:ne.type)!=="WhileStatement"||!Ee?!1:r(We,_,l)===")"?(o(J,_),!0):Ee.type==="BlockStatement"?(b(Ee,_),!0):ne.body===Ee?(i(Ee,_),!0):!1}function V(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee}=me;return (ne==null?void 0:ne.type)!=="TryStatement"&&(ne==null?void 0:ne.type)!=="CatchClause"||!Ee?!1:ne.type==="CatchClause"&&J?(o(J,_),!0):Ee.type==="BlockStatement"?(b(Ee,_),!0):Ee.type==="TryStatement"?(L(Ee.finalizer,_),!0):Ee.type==="CatchClause"?(L(Ee.body,_),!0):!1}function q(me){let{comment:_,enclosingNode:J,followingNode:ne}=me;return I(J)&&(ne==null?void 0:ne.type)==="Identifier"?(i(J,_),!0):!1}function Y(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee,text:We}=me,Be=J&&!u(We,l(J),F(_));return (!J||!Be)&&((ne==null?void 0:ne.type)==="ConditionalExpression"||(ne==null?void 0:ne.type)==="TSConditionalType")&&Ee?(i(Ee,_),!0):!1}function H(me){let{comment:_,precedingNode:J,enclosingNode:ne}=me;return k(ne)&&ne.shorthand&&ne.key===J&&ne.value.type==="AssignmentPattern"?(o(ne.value.left,_),!0):!1}var R=new Set(["ClassDeclaration","ClassExpression","DeclareClass","DeclareInterface","InterfaceDeclaration","TSInterfaceDeclaration"]);function Q(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee}=me;if(R.has(ne==null?void 0:ne.type)){if(m(ne.decorators)&&!(Ee&&Ee.type==="Decorator"))return o(t(ne.decorators),_),!0;if(ne.body&&Ee===ne.body)return b(ne.body,_),!0;if(Ee){if(ne.superClass&&Ee===ne.superClass&&J&&(J===ne.id||J===ne.typeParameters))return o(J,_),!0;for(let We of ["implements","extends","mixins"])if(ne[We]&&Ee===ne[We][0])return J&&(J===ne.id||J===ne.typeParameters||J===ne.superClass)?o(J,_):c(ne,_,We),!0}}return !1}var ee=new Set(["ClassMethod","ClassProperty","PropertyDefinition","TSAbstractPropertyDefinition","TSAbstractMethodDefinition","TSDeclareMethod","MethodDefinition"]);function te(me){let{comment:_,precedingNode:J,enclosingNode:ne,text:Ee}=me;return ne&&J&&r(Ee,_,l)==="("&&(ne.type==="Property"||ne.type==="TSDeclareMethod"||ne.type==="TSAbstractMethodDefinition")&&J.type==="Identifier"&&ne.key===J&&r(Ee,J,l)!==":"||(J==null?void 0:J.type)==="Decorator"&&ee.has(ne==null?void 0:ne.type)?(o(J,_),!0):!1}var oe=new Set(["FunctionDeclaration","FunctionExpression","ClassMethod","MethodDefinition","ObjectMethod"]);function W(me){let{comment:_,precedingNode:J,enclosingNode:ne,text:Ee}=me;return r(Ee,_,l)!=="("?!1:J&&oe.has(ne==null?void 0:ne.type)?(o(J,_),!0):!1}function X(me){let{comment:_,enclosingNode:J,text:ne}=me;if((J==null?void 0:J.type)!=="ArrowFunctionExpression")return !1;let Ee=v(ne,_,l);return Ee!==!1&&ne.slice(Ee,Ee+2)==="=>"?(c(J,_),!0):!1}function ue(me){let{comment:_,enclosingNode:J,text:ne}=me;return r(ne,_,l)!==")"?!1:J&&(ye(J)&&d(J).length===0||A(J)&&S(J).length===0)?(c(J,_),!0):((J==null?void 0:J.type)==="MethodDefinition"||(J==null?void 0:J.type)==="TSAbstractMethodDefinition")&&d(J.value).length===0?(c(J.value,_),!0):!1}function De(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee,text:We}=me;if((J==null?void 0:J.type)==="FunctionTypeParam"&&(ne==null?void 0:ne.type)==="FunctionTypeAnnotation"&&(Ee==null?void 0:Ee.type)!=="FunctionTypeParam"||((J==null?void 0:J.type)==="Identifier"||(J==null?void 0:J.type)==="AssignmentPattern")&&ne&&ye(ne)&&r(We,_,l)===")")return o(J,_),!0;if((ne==null?void 0:ne.type)==="FunctionDeclaration"&&(Ee==null?void 0:Ee.type)==="BlockStatement"){let Be=(()=>{let Pe=d(ne);if(Pe.length>0)return a(We,l(t(Pe)));let Se=a(We,l(ne.id));return Se!==!1&&a(We,Se+1)})();if(F(_)>Be)return b(Ee,_),!0}return !1}function ie(me){let{comment:_,enclosingNode:J}=me;return (J==null?void 0:J.type)==="LabeledStatement"?(i(J,_),!0):!1}function G(me){let{comment:_,enclosingNode:J}=me;return ((J==null?void 0:J.type)==="ContinueStatement"||(J==null?void 0:J.type)==="BreakStatement")&&!J.label?(o(J,_),!0):!1}function z(me){let{comment:_,precedingNode:J,enclosingNode:ne}=me;return B(ne)&&J&&ne.callee===J&&ne.arguments.length>0?(i(ne.arguments[0],_),!0):!1}function U(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee}=me;return (ne==null?void 0:ne.type)==="UnionTypeAnnotation"||(ne==null?void 0:ne.type)==="TSUnionType"?(p(_)&&(Ee.prettierIgnore=!0,_.unignore=!0),J?(o(J,_),!0):!1):(((Ee==null?void 0:Ee.type)==="UnionTypeAnnotation"||(Ee==null?void 0:Ee.type)==="TSUnionType")&&p(_)&&(Ee.types[0].prettierIgnore=!0,_.unignore=!0),!1)}function le(me){let{comment:_,enclosingNode:J}=me;return k(J)?(i(J,_),!0):!1}function ge(me){let{comment:_,enclosingNode:J,followingNode:ne,ast:Ee,isLastComment:We}=me;return Ee&&Ee.body&&Ee.body.length===0?(We?c(Ee,_):i(Ee,_),!0):(J==null?void 0:J.type)==="Program"&&(J==null?void 0:J.body.length)===0&&!m(J.directives)?(We?c(J,_):i(J,_),!0):(ne==null?void 0:ne.type)==="Program"&&(ne==null?void 0:ne.body.length)===0&&(J==null?void 0:J.type)==="ModuleExpression"?(c(ne,_),!0):!1}function Ae(me){let{comment:_,enclosingNode:J}=me;return (J==null?void 0:J.type)==="ForInStatement"||(J==null?void 0:J.type)==="ForOfStatement"?(i(J,_),!0):!1}function Ne(me){let{comment:_,precedingNode:J,enclosingNode:ne,text:Ee}=me;if((ne==null?void 0:ne.type)==="ImportSpecifier"||(ne==null?void 0:ne.type)==="ExportSpecifier")return i(ne,_),!0;let We=(J==null?void 0:J.type)==="ImportSpecifier"&&(ne==null?void 0:ne.type)==="ImportDeclaration",Be=(J==null?void 0:J.type)==="ExportSpecifier"&&(ne==null?void 0:ne.type)==="ExportNamedDeclaration";return (We||Be)&&s(Ee,l(_))?(o(J,_),!0):!1}function ke(me){let{comment:_,enclosingNode:J}=me;return (J==null?void 0:J.type)==="AssignmentPattern"?(i(J,_),!0):!1}var ce=new Set(["VariableDeclarator","AssignmentExpression","TypeAlias","TSTypeAliasDeclaration"]),pe=new Set(["ObjectExpression","ArrayExpression","TemplateLiteral","TaggedTemplateExpression","ObjectTypeAnnotation","TSTypeLiteral"]);function de(me){let{comment:_,enclosingNode:J,followingNode:ne}=me;return ce.has(J==null?void 0:J.type)&&ne&&(pe.has(ne.type)||E(_))?(i(ne,_),!0):!1}function ae(me){let{comment:_,enclosingNode:J,followingNode:ne,text:Ee}=me;return !ne&&((J==null?void 0:J.type)==="TSMethodSignature"||(J==null?void 0:J.type)==="TSDeclareFunction"||(J==null?void 0:J.type)==="TSAbstractMethodDefinition")&&r(Ee,_,l)===";"?(o(J,_),!0):!1}function ve(me){let{comment:_,enclosingNode:J,followingNode:ne}=me;if(p(_)&&(J==null?void 0:J.type)==="TSMappedType"&&(ne==null?void 0:ne.type)==="TSTypeParameter"&&ne.constraint)return J.prettierIgnore=!0,_.unignore=!0,!0}function K(me){let{comment:_,precedingNode:J,enclosingNode:ne,followingNode:Ee}=me;return (ne==null?void 0:ne.type)!=="TSMappedType"?!1:(Ee==null?void 0:Ee.type)==="TSTypeParameter"&&Ee.name?(i(Ee.name,_),!0):(J==null?void 0:J.type)==="TSTypeParameter"&&J.constraint?(o(J.constraint,_),!0):!1}function he(me){let{comment:_,enclosingNode:J,followingNode:ne}=me;return !J||J.type!=="SwitchCase"||J.test?!1:(ne.type==="BlockStatement"&&P(_)?b(ne,_):c(J,_),!0)}function ye(me){return me.type==="ArrowFunctionExpression"||me.type==="FunctionExpression"||me.type==="FunctionDeclaration"||me.type==="ObjectMethod"||me.type==="ClassMethod"||me.type==="TSDeclareFunction"||me.type==="TSCallSignatureDeclaration"||me.type==="TSConstructSignatureDeclaration"||me.type==="TSMethodSignature"||me.type==="TSConstructorType"||me.type==="TSFunctionType"||me.type==="TSDeclareMethod"}function Ce(me,_){if((_.parser==="typescript"||_.parser==="flow"||_.parser==="acorn"||_.parser==="espree"||_.parser==="meriyah"||_.parser==="__babel_estree")&&me.type==="MethodDefinition"&&me.value&&me.value.type==="FunctionExpression"&&d(me.value).length===0&&!me.value.returnType&&!m(me.value.typeParameters)&&me.value.body)return [...me.decorators||[],me.key,me.value.body]}function Ie(me){return E(me)&&me.value[0]==="*"&&/@type\b/.test(me.value)}function Fe(me){let _=me.getValue(),J=me.getParentNode(),ne=Ee=>w(C(Ee,D.Leading))||w(C(Ee,D.Trailing));return (_&&(f(_)||h(_)||B(J)&&ne(_))||J&&(J.type==="JSXSpreadAttribute"||J.type==="JSXSpreadChild"||J.type==="UnionTypeAnnotation"||J.type==="TSUnionType"||(J.type==="ClassDeclaration"||J.type==="ClassExpression")&&J.superClass===_))&&(!T(me)||J.type==="UnionTypeAnnotation"||J.type==="TSUnionType")}n.exports={handleOwnLineComment:y,handleEndOfLineComment:N,handleRemainingComment:x,isTypeCastComment:Ie,getCommentChildNodes:Ce,willPrintOwnComments:Fe};}}),jt=Z({"src/language-js/needs-parens.js"(e,n){re();var t=it(),s=Rn(),{getFunctionParameters:a,getLeftSidePathName:r,hasFlowShorthandAnnotationComment:u,hasNakedLeftSide:i,hasNode:o,isBitwiseOperator:c,startsWithNoLookaheadToken:v,shouldFlatten:m,getPrecedence:d,isCallExpression:p,isMemberExpression:f,isObjectProperty:h}=Ke();function w(P,C){let D=P.getParentNode();if(!D)return !1;let g=P.getName(),F=P.getNode();if(C.__isInHtmlInterpolation&&!C.bracketSpacing&&B(F)&&I(P))return !0;if(T(F))return !1;if(C.parser!=="flow"&&u(P.getValue()))return !0;if(F.type==="Identifier")return !!(F.extra&&F.extra.parenthesized&&/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(F.name)||g==="left"&&F.name==="async"&&D.type==="ForOfStatement"&&!D.await);switch(D.type){case"ParenthesizedExpression":return !1;case"ClassDeclaration":case"ClassExpression":{if(g==="superClass"&&(F.type==="ArrowFunctionExpression"||F.type==="AssignmentExpression"||F.type==="AwaitExpression"||F.type==="BinaryExpression"||F.type==="ConditionalExpression"||F.type==="LogicalExpression"||F.type==="NewExpression"||F.type==="ObjectExpression"||F.type==="SequenceExpression"||F.type==="TaggedTemplateExpression"||F.type==="UnaryExpression"||F.type==="UpdateExpression"||F.type==="YieldExpression"||F.type==="TSNonNullExpression"))return !0;break}case"ExportDefaultDeclaration":return k(P,C)||F.type==="SequenceExpression";case"Decorator":{if(g==="expression"){let l=!1,E=!1,y=F;for(;y;)switch(y.type){case"MemberExpression":E=!0,y=y.object;break;case"CallExpression":if(E||l)return C.parser!=="typescript";l=!0,y=y.callee;break;case"Identifier":return !1;case"TaggedTemplateExpression":return C.parser!=="typescript";default:return !0}return !0}break}case"ExpressionStatement":{if(v(F,!0))return !0;break}case"ArrowFunctionExpression":{if(g==="body"&&F.type!=="SequenceExpression"&&v(F,!1))return !0;break}}switch(F.type){case"UpdateExpression":if(D.type==="UnaryExpression")return F.prefix&&(F.operator==="++"&&D.operator==="+"||F.operator==="--"&&D.operator==="-");case"UnaryExpression":switch(D.type){case"UnaryExpression":return F.operator===D.operator&&(F.operator==="+"||F.operator==="-");case"BindExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return g==="object";case"TaggedTemplateExpression":return !0;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return g==="callee";case"BinaryExpression":return g==="left"&&D.operator==="**";case"TSNonNullExpression":return !0;default:return !1}case"BinaryExpression":{if(D.type==="UpdateExpression"||F.operator==="in"&&A(P))return !0;if(F.operator==="|>"&&F.extra&&F.extra.parenthesized){let l=P.getParentNode(1);if(l.type==="BinaryExpression"&&l.operator==="|>")return !0}}case"TSTypeAssertion":case"TSAsExpression":case"LogicalExpression":switch(D.type){case"TSAsExpression":return F.type!=="TSAsExpression";case"ConditionalExpression":return F.type==="TSAsExpression";case"CallExpression":case"NewExpression":case"OptionalCallExpression":return g==="callee";case"ClassExpression":case"ClassDeclaration":return g==="superClass";case"TSTypeAssertion":case"TaggedTemplateExpression":case"UnaryExpression":case"JSXSpreadAttribute":case"SpreadElement":case"SpreadProperty":case"BindExpression":case"AwaitExpression":case"TSNonNullExpression":case"UpdateExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return g==="object";case"AssignmentExpression":case"AssignmentPattern":return g==="left"&&(F.type==="TSTypeAssertion"||F.type==="TSAsExpression");case"LogicalExpression":if(F.type==="LogicalExpression")return D.operator!==F.operator;case"BinaryExpression":{let{operator:l,type:E}=F;if(!l&&E!=="TSTypeAssertion")return !0;let y=d(l),N=D.operator,x=d(N);return x>y||g==="right"&&x===y||x===y&&!m(N,l)?!0:x<y&&l==="%"?N==="+"||N==="-":!!c(N)}default:return !1}case"SequenceExpression":switch(D.type){case"ReturnStatement":return !1;case"ForStatement":return !1;case"ExpressionStatement":return g!=="expression";case"ArrowFunctionExpression":return g!=="body";default:return !0}case"YieldExpression":if(D.type==="UnaryExpression"||D.type==="AwaitExpression"||D.type==="TSAsExpression"||D.type==="TSNonNullExpression")return !0;case"AwaitExpression":switch(D.type){case"TaggedTemplateExpression":case"UnaryExpression":case"LogicalExpression":case"SpreadElement":case"SpreadProperty":case"TSAsExpression":case"TSNonNullExpression":case"BindExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return g==="object";case"NewExpression":case"CallExpression":case"OptionalCallExpression":return g==="callee";case"ConditionalExpression":return g==="test";case"BinaryExpression":return !(!F.argument&&D.operator==="|>");default:return !1}case"TSConditionalType":if(g==="extendsType"&&D.type==="TSConditionalType")return !0;case"TSFunctionType":case"TSConstructorType":if(g==="checkType"&&D.type==="TSConditionalType")return !0;case"TSUnionType":case"TSIntersectionType":if((D.type==="TSUnionType"||D.type==="TSIntersectionType")&&D.types.length>1&&(!F.types||F.types.length>1))return !0;case"TSInferType":if(F.type==="TSInferType"&&D.type==="TSRestType")return !1;case"TSTypeOperator":return D.type==="TSArrayType"||D.type==="TSOptionalType"||D.type==="TSRestType"||g==="objectType"&&D.type==="TSIndexedAccessType"||D.type==="TSTypeOperator"||D.type==="TSTypeAnnotation"&&P.getParentNode(1).type.startsWith("TSJSDoc");case"ArrayTypeAnnotation":return D.type==="NullableTypeAnnotation";case"IntersectionTypeAnnotation":case"UnionTypeAnnotation":return D.type==="ArrayTypeAnnotation"||D.type==="NullableTypeAnnotation"||D.type==="IntersectionTypeAnnotation"||D.type==="UnionTypeAnnotation"||g==="objectType"&&(D.type==="IndexedAccessType"||D.type==="OptionalIndexedAccessType");case"NullableTypeAnnotation":return D.type==="ArrayTypeAnnotation"||g==="objectType"&&(D.type==="IndexedAccessType"||D.type==="OptionalIndexedAccessType");case"FunctionTypeAnnotation":{let l=D.type==="NullableTypeAnnotation"?P.getParentNode(1):D;return l.type==="UnionTypeAnnotation"||l.type==="IntersectionTypeAnnotation"||l.type==="ArrayTypeAnnotation"||g==="objectType"&&(l.type==="IndexedAccessType"||l.type==="OptionalIndexedAccessType")||l.type==="NullableTypeAnnotation"||D.type==="FunctionTypeParam"&&D.name===null&&a(F).some(E=>E.typeAnnotation&&E.typeAnnotation.type==="NullableTypeAnnotation")}case"OptionalIndexedAccessType":return g==="objectType"&&D.type==="IndexedAccessType";case"TypeofTypeAnnotation":return g==="objectType"&&(D.type==="IndexedAccessType"||D.type==="OptionalIndexedAccessType");case"StringLiteral":case"NumericLiteral":case"Literal":if(typeof F.value=="string"&&D.type==="ExpressionStatement"&&!D.directive){let l=P.getParentNode(1);return l.type==="Program"||l.type==="BlockStatement"}return g==="object"&&D.type==="MemberExpression"&&typeof F.value=="number";case"AssignmentExpression":{let l=P.getParentNode(1);return g==="body"&&D.type==="ArrowFunctionExpression"?!0:g==="key"&&(D.type==="ClassProperty"||D.type==="PropertyDefinition")&&D.computed||(g==="init"||g==="update")&&D.type==="ForStatement"?!1:D.type==="ExpressionStatement"?F.left.type==="ObjectPattern":!(g==="key"&&D.type==="TSPropertySignature"||D.type==="AssignmentExpression"||D.type==="SequenceExpression"&&l&&l.type==="ForStatement"&&(l.init===D||l.update===D)||g==="value"&&D.type==="Property"&&l&&l.type==="ObjectPattern"&&l.properties.includes(D)||D.type==="NGChainedExpression")}case"ConditionalExpression":switch(D.type){case"TaggedTemplateExpression":case"UnaryExpression":case"SpreadElement":case"SpreadProperty":case"BinaryExpression":case"LogicalExpression":case"NGPipeExpression":case"ExportDefaultDeclaration":case"AwaitExpression":case"JSXSpreadAttribute":case"TSTypeAssertion":case"TypeCastExpression":case"TSAsExpression":case"TSNonNullExpression":return !0;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return g==="callee";case"ConditionalExpression":return g==="test";case"MemberExpression":case"OptionalMemberExpression":return g==="object";default:return !1}case"FunctionExpression":switch(D.type){case"NewExpression":case"CallExpression":case"OptionalCallExpression":return g==="callee";case"TaggedTemplateExpression":return !0;default:return !1}case"ArrowFunctionExpression":switch(D.type){case"BinaryExpression":return D.operator!=="|>"||F.extra&&F.extra.parenthesized;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return g==="callee";case"MemberExpression":case"OptionalMemberExpression":return g==="object";case"TSAsExpression":case"TSNonNullExpression":case"BindExpression":case"TaggedTemplateExpression":case"UnaryExpression":case"LogicalExpression":case"AwaitExpression":case"TSTypeAssertion":return !0;case"ConditionalExpression":return g==="test";default:return !1}case"ClassExpression":if(s(F.decorators))return !0;switch(D.type){case"NewExpression":return g==="callee";default:return !1}case"OptionalMemberExpression":case"OptionalCallExpression":{let l=P.getParentNode(1);if(g==="object"&&D.type==="MemberExpression"||g==="callee"&&(D.type==="CallExpression"||D.type==="NewExpression")||D.type==="TSNonNullExpression"&&l.type==="MemberExpression"&&l.object===D)return !0}case"CallExpression":case"MemberExpression":case"TaggedTemplateExpression":case"TSNonNullExpression":if(g==="callee"&&(D.type==="BindExpression"||D.type==="NewExpression")){let l=F;for(;l;)switch(l.type){case"CallExpression":case"OptionalCallExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":case"BindExpression":l=l.object;break;case"TaggedTemplateExpression":l=l.tag;break;case"TSNonNullExpression":l=l.expression;break;default:return !1}}return !1;case"BindExpression":return g==="callee"&&(D.type==="BindExpression"||D.type==="NewExpression")||g==="object"&&f(D);case"NGPipeExpression":return !(D.type==="NGRoot"||D.type==="NGMicrosyntaxExpression"||D.type==="ObjectProperty"&&!(F.extra&&F.extra.parenthesized)||D.type==="ArrayExpression"||p(D)&&D.arguments[g]===F||g==="right"&&D.type==="NGPipeExpression"||g==="property"&&D.type==="MemberExpression"||D.type==="AssignmentExpression");case"JSXFragment":case"JSXElement":return g==="callee"||g==="left"&&D.type==="BinaryExpression"&&D.operator==="<"||D.type!=="ArrayExpression"&&D.type!=="ArrowFunctionExpression"&&D.type!=="AssignmentExpression"&&D.type!=="AssignmentPattern"&&D.type!=="BinaryExpression"&&D.type!=="NewExpression"&&D.type!=="ConditionalExpression"&&D.type!=="ExpressionStatement"&&D.type!=="JsExpressionRoot"&&D.type!=="JSXAttribute"&&D.type!=="JSXElement"&&D.type!=="JSXExpressionContainer"&&D.type!=="JSXFragment"&&D.type!=="LogicalExpression"&&!p(D)&&!h(D)&&D.type!=="ReturnStatement"&&D.type!=="ThrowStatement"&&D.type!=="TypeCastExpression"&&D.type!=="VariableDeclarator"&&D.type!=="YieldExpression";case"TypeAnnotation":return g==="returnType"&&D.type==="ArrowFunctionExpression"&&S(F)}return !1}function T(P){return P.type==="BlockStatement"||P.type==="BreakStatement"||P.type==="ClassBody"||P.type==="ClassDeclaration"||P.type==="ClassMethod"||P.type==="ClassProperty"||P.type==="PropertyDefinition"||P.type==="ClassPrivateProperty"||P.type==="ContinueStatement"||P.type==="DebuggerStatement"||P.type==="DeclareClass"||P.type==="DeclareExportAllDeclaration"||P.type==="DeclareExportDeclaration"||P.type==="DeclareFunction"||P.type==="DeclareInterface"||P.type==="DeclareModule"||P.type==="DeclareModuleExports"||P.type==="DeclareVariable"||P.type==="DoWhileStatement"||P.type==="EnumDeclaration"||P.type==="ExportAllDeclaration"||P.type==="ExportDefaultDeclaration"||P.type==="ExportNamedDeclaration"||P.type==="ExpressionStatement"||P.type==="ForInStatement"||P.type==="ForOfStatement"||P.type==="ForStatement"||P.type==="FunctionDeclaration"||P.type==="IfStatement"||P.type==="ImportDeclaration"||P.type==="InterfaceDeclaration"||P.type==="LabeledStatement"||P.type==="MethodDefinition"||P.type==="ReturnStatement"||P.type==="SwitchStatement"||P.type==="ThrowStatement"||P.type==="TryStatement"||P.type==="TSDeclareFunction"||P.type==="TSEnumDeclaration"||P.type==="TSImportEqualsDeclaration"||P.type==="TSInterfaceDeclaration"||P.type==="TSModuleDeclaration"||P.type==="TSNamespaceExportDeclaration"||P.type==="TypeAlias"||P.type==="VariableDeclaration"||P.type==="WhileStatement"||P.type==="WithStatement"}function A(P){let C=0,D=P.getValue();for(;D;){let g=P.getParentNode(C++);if(g&&g.type==="ForStatement"&&g.init===D)return !0;D=g;}return !1}function S(P){return o(P,C=>C.type==="ObjectTypeAnnotation"&&o(C,D=>D.type==="FunctionTypeAnnotation"||void 0)||void 0)}function B(P){switch(P.type){case"ObjectExpression":return !0;default:return !1}}function I(P){let C=P.getValue(),D=P.getParentNode(),g=P.getName();switch(D.type){case"NGPipeExpression":if(typeof g=="number"&&D.arguments[g]===C&&D.arguments.length-1===g)return P.callParent(I);break;case"ObjectProperty":if(g==="value"){let F=P.getParentNode(1);return t(F.properties)===D}break;case"BinaryExpression":case"LogicalExpression":if(g==="right")return P.callParent(I);break;case"ConditionalExpression":if(g==="alternate")return P.callParent(I);break;case"UnaryExpression":if(D.prefix)return P.callParent(I);break}return !1}function k(P,C){let D=P.getValue(),g=P.getParentNode();return D.type==="FunctionExpression"||D.type==="ClassExpression"?g.type==="ExportDefaultDeclaration"||!w(P,C):!i(D)||g.type!=="ExportDefaultDeclaration"&&w(P,C)?!1:P.call(F=>k(F,C),...r(P,D))}n.exports=w;}}),so=Z({"src/language-js/print-preprocess.js"(e,n){re();function t(s,a){switch(a.parser){case"json":case"json5":case"json-stringify":case"__js_expression":case"__vue_expression":case"__vue_ts_expression":return Object.assign(Object.assign({},s),{},{type:a.parser.startsWith("__")?"JsExpressionRoot":"JsonRoot",node:s,comments:[],rootMarker:a.rootMarker});default:return s}}n.exports=t;}}),$m=Z({"src/language-js/print/html-binding.js"(e,n){re();var{builders:{join:t,line:s,group:a,softline:r,indent:u}}=Oe();function i(c,v,m){let d=c.getValue();if(v.__onHtmlBindingRoot&&c.getName()===null&&v.__onHtmlBindingRoot(d,v),d.type==="File"){if(v.__isVueForBindingLeft)return c.call(p=>{let f=t([",",s],p.map(m,"params")),{params:h}=p.getValue();return h.length===1?f:["(",u([r,a(f)]),r,")"]},"program","body",0);if(v.__isVueBindings)return c.call(p=>t([",",s],p.map(m,"params")),"program","body",0)}}function o(c){switch(c.type){case"MemberExpression":switch(c.property.type){case"Identifier":case"NumericLiteral":case"StringLiteral":return o(c.object)}return !1;case"Identifier":return !0;default:return !1}}n.exports={isVueEventBindingExpression:o,printHtmlBinding:i};}}),Jn=Z({"src/language-js/print/binaryish.js"(e,n){re();var{printComments:t}=et(),{getLast:s}=Ue(),{builders:{join:a,line:r,softline:u,group:i,indent:o,align:c,ifBreak:v,indentIfBreak:m},utils:{cleanDoc:d,getDocParts:p,isConcat:f}}=Oe(),{hasLeadingOwnLineComment:h,isBinaryish:w,isJsxNode:T,shouldFlatten:A,hasComment:S,CommentCheckFlags:B,isCallExpression:I,isMemberExpression:k,isObjectProperty:P,isEnabledHackPipeline:C}=Ke(),D=0;function g(E,y,N){let x=E.getValue(),b=E.getParentNode(),L=E.getParentNode(1),M=x!==b.body&&(b.type==="IfStatement"||b.type==="WhileStatement"||b.type==="SwitchStatement"||b.type==="DoWhileStatement"),j=C(y)&&x.operator==="|>",$=F(E,N,y,!1,M);if(M)return $;if(j)return i($);if(I(b)&&b.callee===x||b.type==="UnaryExpression"||k(b)&&!b.computed)return i([o([u,...$]),u]);let V=b.type==="ReturnStatement"||b.type==="ThrowStatement"||b.type==="JSXExpressionContainer"&&L.type==="JSXAttribute"||x.operator!=="|"&&b.type==="JsExpressionRoot"||x.type!=="NGPipeExpression"&&(b.type==="NGRoot"&&y.parser==="__ng_binding"||b.type==="NGMicrosyntaxExpression"&&L.type==="NGMicrosyntax"&&L.body.length===1)||x===b.body&&b.type==="ArrowFunctionExpression"||x!==b.body&&b.type==="ForStatement"||b.type==="ConditionalExpression"&&L.type!=="ReturnStatement"&&L.type!=="ThrowStatement"&&!I(L)||b.type==="TemplateLiteral",q=b.type==="AssignmentExpression"||b.type==="VariableDeclarator"||b.type==="ClassProperty"||b.type==="PropertyDefinition"||b.type==="TSAbstractPropertyDefinition"||b.type==="ClassPrivateProperty"||P(b),Y=w(x.left)&&A(x.operator,x.left.operator);if(V||l(x)&&!Y||!l(x)&&q)return i($);if($.length===0)return "";let H=T(x.right),R=$.findIndex(X=>typeof X!="string"&&!Array.isArray(X)&&X.type==="group"),Q=$.slice(0,R===-1?1:R+1),ee=$.slice(Q.length,H?-1:void 0),te=Symbol("logicalChain-"+ ++D),oe=i([...Q,o(ee)],{id:te});if(!H)return oe;let W=s($);return i([oe,m(W,{groupId:te})])}function F(E,y,N,x,b){let L=E.getValue();if(!w(L))return [i(y())];let M=[];A(L.operator,L.left.operator)?M=E.call(ee=>F(ee,y,N,!0,b),"left"):M.push(i(y("left")));let j=l(L),$=(L.operator==="|>"||L.type==="NGPipeExpression"||L.operator==="|"&&N.parser==="__vue_expression")&&!h(N.originalText,L.right),V=L.type==="NGPipeExpression"?"|":L.operator,q=L.type==="NGPipeExpression"&&L.arguments.length>0?i(o([u,": ",a([u,":",v(" ")],E.map(y,"arguments").map(ee=>c(2,i(ee))))])):"",Y;if(j)Y=[V," ",y("right"),q];else {let te=C(N)&&V==="|>"?E.call(oe=>F(oe,y,N,!0,b),"right"):y("right");Y=[$?r:"",V,$?" ":r,te,q];}let H=E.getParentNode(),R=S(L.left,B.Trailing|B.Line),Q=R||!(b&&L.type==="LogicalExpression")&&H.type!==L.type&&L.left.type!==L.type&&L.right.type!==L.type;if(M.push($?"":" ",Q?i(Y,{shouldBreak:R}):Y),x&&S(L)){let ee=d(t(E,M,N));return f(ee)||ee.type==="fill"?p(ee):[ee]}return M}function l(E){return E.type!=="LogicalExpression"?!1:!!(E.right.type==="ObjectExpression"&&E.right.properties.length>0||E.right.type==="ArrayExpression"&&E.right.elements.length>0||T(E.right))}n.exports={printBinaryishExpression:g,shouldInlineLogicalExpression:l};}}),Hm=Z({"src/language-js/print/angular.js"(e,n){re();var{builders:{join:t,line:s,group:a}}=Oe(),{hasNode:r,hasComment:u,getComments:i}=Ke(),{printBinaryishExpression:o}=Jn();function c(d,p,f){let h=d.getValue();if(!!h.type.startsWith("NG"))switch(h.type){case"NGRoot":return [f("node"),u(h.node)?" //"+i(h.node)[0].value.trimEnd():""];case"NGPipeExpression":return o(d,p,f);case"NGChainedExpression":return a(t([";",s],d.map(w=>m(w)?f():["(",f(),")"],"expressions")));case"NGEmptyExpression":return "";case"NGQuotedExpression":return [h.prefix,": ",h.value.trim()];case"NGMicrosyntax":return d.map((w,T)=>[T===0?"":v(w.getValue(),T,h)?" ":[";",s],f()],"body");case"NGMicrosyntaxKey":return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h.name)?h.name:JSON.stringify(h.name);case"NGMicrosyntaxExpression":return [f("expression"),h.alias===null?"":[" as ",f("alias")]];case"NGMicrosyntaxKeyedExpression":{let w=d.getName(),T=d.getParentNode(),A=v(h,w,T)||(w===1&&(h.key.name==="then"||h.key.name==="else")||w===2&&h.key.name==="else"&&T.body[w-1].type==="NGMicrosyntaxKeyedExpression"&&T.body[w-1].key.name==="then")&&T.body[0].type==="NGMicrosyntaxExpression";return [f("key"),A?" ":": ",f("expression")]}case"NGMicrosyntaxLet":return ["let ",f("key"),h.value===null?"":[" = ",f("value")]];case"NGMicrosyntaxAs":return [f("key")," as ",f("alias")];default:throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h.type),"."))}}function v(d,p,f){return d.type==="NGMicrosyntaxKeyedExpression"&&d.key.name==="of"&&p===1&&f.body[0].type==="NGMicrosyntaxLet"&&f.body[0].value===null}function m(d){return r(d.getValue(),p=>{switch(p.type){case void 0:return !1;case"CallExpression":case"OptionalCallExpression":case"AssignmentExpression":return !0}})}n.exports={printAngular:c};}}),Gm=Z({"src/language-js/print/jsx.js"(e,n){re();var{printComments:t,printDanglingComments:s}=et(),{builders:{line:a,hardline:r,softline:u,group:i,indent:o,conditionalGroup:c,fill:v,ifBreak:m,lineSuffixBoundary:d,join:p},utils:{willBreak:f}}=Oe(),{getLast:h,getPreferredQuote:w}=Ue(),{isJsxNode:T,rawText:A,isLiteral:S,isCallExpression:B,isStringLiteral:I,isBinaryish:k,hasComment:P,CommentCheckFlags:C,hasNodeIgnoreComment:D}=Ke(),g=jt(),{willPrintOwnComments:F}=uo(),l=ie=>ie===""||ie===a||ie===r||ie===u;function E(ie,G,z){let U=ie.getValue();if(U.type==="JSXElement"&&W(U))return [z("openingElement"),z("closingElement")];let le=U.type==="JSXElement"?z("openingElement"):z("openingFragment"),ge=U.type==="JSXElement"?z("closingElement"):z("closingFragment");if(U.children.length===1&&U.children[0].type==="JSXExpressionContainer"&&(U.children[0].expression.type==="TemplateLiteral"||U.children[0].expression.type==="TaggedTemplateExpression"))return [le,...ie.map(z,"children"),ge];U.children=U.children.map(Fe=>ue(Fe)?{type:"JSXText",value:" ",raw:" "}:Fe);let Ae=U.children.some(T),Ne=U.children.filter(Fe=>Fe.type==="JSXExpressionContainer").length>1,ke=U.type==="JSXElement"&&U.openingElement.attributes.length>1,ce=f(le)||Ae||ke||Ne,pe=ie.getParentNode().rootMarker==="mdx",de=G.singleQuote?"{' '}":'{" "}',ae=pe?" ":m([de,u]," "),ve=U.openingElement&&U.openingElement.name&&U.openingElement.name.name==="fbt",K=y(ie,G,z,ae,ve),he=U.children.some(Fe=>X(Fe));for(let Fe=K.length-2;Fe>=0;Fe--){let me=K[Fe]===""&&K[Fe+1]==="",_=K[Fe]===r&&K[Fe+1]===""&&K[Fe+2]===r,J=(K[Fe]===u||K[Fe]===r)&&K[Fe+1]===""&&K[Fe+2]===ae,ne=K[Fe]===ae&&K[Fe+1]===""&&(K[Fe+2]===u||K[Fe+2]===r),Ee=K[Fe]===ae&&K[Fe+1]===""&&K[Fe+2]===ae,We=K[Fe]===u&&K[Fe+1]===""&&K[Fe+2]===r||K[Fe]===r&&K[Fe+1]===""&&K[Fe+2]===u;_&&he||me||J||Ee||We?K.splice(Fe,2):ne&&K.splice(Fe+1,2);}for(;K.length>0&&l(h(K));)K.pop();for(;K.length>1&&l(K[0])&&l(K[1]);)K.shift(),K.shift();let ye=[];for(let[Fe,me]of K.entries()){if(me===ae){if(Fe===1&&K[Fe-1]===""){if(K.length===2){ye.push(de);continue}ye.push([de,r]);continue}else if(Fe===K.length-1){ye.push(de);continue}else if(K[Fe-1]===""&&K[Fe-2]===r){ye.push(de);continue}}ye.push(me),f(me)&&(ce=!0);}let Ce=he?v(ye):i(ye,{shouldBreak:!0});if(pe)return Ce;let Ie=i([le,o([r,Ce]),r,ge]);return ce?Ie:c([i([le,...K,ge]),Ie])}function y(ie,G,z,U,le){let ge=[];return ie.each((Ae,Ne,ke)=>{let ce=Ae.getValue();if(S(ce)){let pe=A(ce);if(X(ce)){let de=pe.split(ee);if(de[0]===""){if(ge.push(""),de.shift(),/\n/.test(de[0])){let ve=ke[Ne+1];ge.push(x(le,de[1],ce,ve));}else ge.push(U);de.shift();}let ae;if(h(de)===""&&(de.pop(),ae=de.pop()),de.length===0)return;for(let[ve,K]of de.entries())ve%2===1?ge.push(a):ge.push(K);if(ae!==void 0)if(/\n/.test(ae)){let ve=ke[Ne+1];ge.push(x(le,h(ge),ce,ve));}else ge.push(U);else {let ve=ke[Ne+1];ge.push(N(le,h(ge),ce,ve));}}else /\n/.test(pe)?pe.match(/\n/g).length>1&&ge.push("",r):ge.push("",U);}else {let pe=z();ge.push(pe);let de=ke[Ne+1];if(de&&X(de)){let ve=oe(A(de)).split(ee)[0];ge.push(N(le,ve,ce,de));}else ge.push(r);}},"children"),ge}function N(ie,G,z,U){return ie?"":z.type==="JSXElement"&&!z.closingElement||U&&U.type==="JSXElement"&&!U.closingElement?G.length===1?u:r:u}function x(ie,G,z,U){return ie?r:G.length===1?z.type==="JSXElement"&&!z.closingElement||U&&U.type==="JSXElement"&&!U.closingElement?r:u:r}function b(ie,G,z){let U=ie.getParentNode();if(!U||{ArrayExpression:!0,JSXAttribute:!0,JSXElement:!0,JSXExpressionContainer:!0,JSXFragment:!0,ExpressionStatement:!0,CallExpression:!0,OptionalCallExpression:!0,ConditionalExpression:!0,JsExpressionRoot:!0}[U.type])return G;let ge=ie.match(void 0,Ne=>Ne.type==="ArrowFunctionExpression",B,Ne=>Ne.type==="JSXExpressionContainer"),Ae=g(ie,z);return i([Ae?"":m("("),o([u,G]),u,Ae?"":m(")")],{shouldBreak:ge})}function L(ie,G,z){let U=ie.getValue(),le=[];if(le.push(z("name")),U.value){let ge;if(I(U.value)){let Ne=A(U.value).slice(1,-1).replace(/&apos;/g,"'").replace(/&quot;/g,'"'),{escaped:ke,quote:ce,regex:pe}=w(Ne,G.jsxSingleQuote?"'":'"');Ne=Ne.replace(pe,ke),ge=[ce,Ne,ce];}else ge=z("value");le.push("=",ge);}return le}function M(ie,G,z){let U=ie.getValue(),le=(ge,Ae)=>ge.type==="JSXEmptyExpression"||!P(ge)&&(ge.type==="ArrayExpression"||ge.type==="ObjectExpression"||ge.type==="ArrowFunctionExpression"||ge.type==="AwaitExpression"&&(le(ge.argument,ge)||ge.argument.type==="JSXElement")||B(ge)||ge.type==="FunctionExpression"||ge.type==="TemplateLiteral"||ge.type==="TaggedTemplateExpression"||ge.type==="DoExpression"||T(Ae)&&(ge.type==="ConditionalExpression"||k(ge)));return le(U.expression,ie.getParentNode(0))?i(["{",z("expression"),d,"}"]):i(["{",o([u,z("expression")]),u,d,"}"])}function j(ie,G,z){let U=ie.getValue(),le=U.name&&P(U.name)||U.typeParameters&&P(U.typeParameters);if(U.selfClosing&&U.attributes.length===0&&!le)return ["<",z("name"),z("typeParameters")," />"];if(U.attributes&&U.attributes.length===1&&U.attributes[0].value&&I(U.attributes[0].value)&&!U.attributes[0].value.value.includes(`
	`)&&!le&&!P(U.attributes[0]))return i(["<",z("name"),z("typeParameters")," ",...ie.map(z,"attributes"),U.selfClosing?" />":">"]);let ge=U.attributes.length>0&&P(h(U.attributes),C.Trailing),Ae=U.attributes.length===0&&!le||(G.bracketSameLine||G.jsxBracketSameLine)&&(!le||U.attributes.length>0)&&!ge,Ne=U.attributes&&U.attributes.some(ce=>ce.value&&I(ce.value)&&ce.value.value.includes(`
	`)),ke=G.singleAttributePerLine&&U.attributes.length>1?r:a;return i(["<",z("name"),z("typeParameters"),o(ie.map(()=>[ke,z()],"attributes")),U.selfClosing?a:Ae?">":u,U.selfClosing?"/>":Ae?"":">"],{shouldBreak:Ne})}function $(ie,G,z){let U=ie.getValue(),le=[];le.push("</");let ge=z("name");return P(U.name,C.Leading|C.Line)?le.push(o([r,ge]),r):P(U.name,C.Leading|C.Block)?le.push(" ",ge):le.push(ge),le.push(">"),le}function V(ie,G){let z=ie.getValue(),U=P(z),le=P(z,C.Line),ge=z.type==="JSXOpeningFragment";return [ge?"<":"</",o([le?r:U&&!ge?" ":"",s(ie,G,!0)]),le?r:"",">"]}function q(ie,G,z){let U=t(ie,E(ie,G,z),G);return b(ie,U,G)}function Y(ie,G){let z=ie.getValue(),U=P(z,C.Line);return [s(ie,G,!U),U?r:""]}function H(ie,G,z){let U=ie.getValue();return ["{",ie.call(le=>{let ge=["...",z()],Ae=le.getValue();return !P(Ae)||!F(le)?ge:[o([u,t(le,ge,G)]),u]},U.type==="JSXSpreadAttribute"?"argument":"expression"),"}"]}function R(ie,G,z){let U=ie.getValue();if(!!U.type.startsWith("JSX"))switch(U.type){case"JSXAttribute":return L(ie,G,z);case"JSXIdentifier":return String(U.name);case"JSXNamespacedName":return p(":",[z("namespace"),z("name")]);case"JSXMemberExpression":return p(".",[z("object"),z("property")]);case"JSXSpreadAttribute":return H(ie,G,z);case"JSXSpreadChild":return H(ie,G,z);case"JSXExpressionContainer":return M(ie,G,z);case"JSXFragment":case"JSXElement":return q(ie,G,z);case"JSXOpeningElement":return j(ie,G,z);case"JSXClosingElement":return $(ie,G,z);case"JSXOpeningFragment":case"JSXClosingFragment":return V(ie,G);case"JSXEmptyExpression":return Y(ie,G);case"JSXText":throw new Error("JSXTest should be handled by JSXElement");default:throw new Error("Unknown JSX node type: ".concat(JSON.stringify(U.type),"."))}}var Q=` 
	\r	`,ee=new RegExp("(["+Q+"]+)"),te=new RegExp("[^"+Q+"]"),oe=ie=>ie.replace(new RegExp("(?:^"+ee.source+"|"+ee.source+"$)"),"");function W(ie){if(ie.children.length===0)return !0;if(ie.children.length>1)return !1;let G=ie.children[0];return S(G)&&!X(G)}function X(ie){return S(ie)&&(te.test(A(ie))||!/\n/.test(A(ie)))}function ue(ie){return ie.type==="JSXExpressionContainer"&&S(ie.expression)&&ie.expression.value===" "&&!P(ie.expression)}function De(ie){let G=ie.getValue(),z=ie.getParentNode();if(!z||!G||!T(G)||!T(z))return !1;let U=z.children.indexOf(G),le=null;for(let ge=U;ge>0;ge--){let Ae=z.children[ge-1];if(!(Ae.type==="JSXText"&&!X(Ae))){le=Ae;break}}return le&&le.type==="JSXExpressionContainer"&&le.expression.type==="JSXEmptyExpression"&&D(le.expression)}n.exports={hasJsxIgnoreComment:De,printJsx:R};}}),ct=Z({"src/language-js/print/misc.js"(e,n){re();var{isNonEmptyArray:t}=Ue(),{builders:{indent:s,join:a,line:r}}=Oe(),{isFlowAnnotationComment:u}=Ke();function i(h){let w=h.getValue();return !w.optional||w.type==="Identifier"&&w===h.getParentNode().key?"":w.type==="OptionalCallExpression"||w.type==="OptionalMemberExpression"&&w.computed?"?.":"?"}function o(h){return h.getValue().definite||h.match(void 0,(w,T)=>T==="id"&&w.type==="VariableDeclarator"&&w.definite)?"!":""}function c(h,w,T){let A=h.getValue();return A.typeArguments?T("typeArguments"):A.typeParameters?T("typeParameters"):""}function v(h,w,T){let A=h.getValue();if(!A.typeAnnotation)return "";let S=h.getParentNode(),B=S.type==="DeclareFunction"&&S.id===A;return u(w.originalText,A.typeAnnotation)?[" /*: ",T("typeAnnotation")," */"]:[B?"":": ",T("typeAnnotation")]}function m(h,w,T){return ["::",T("callee")]}function d(h,w,T){let A=h.getValue();return t(A.modifiers)?[a(" ",h.map(T,"modifiers"))," "]:""}function p(h,w,T){return h.type==="EmptyStatement"?";":h.type==="BlockStatement"||T?[" ",w]:s([r,w])}function f(h,w,T){return ["...",T("argument"),v(h,w,T)]}n.exports={printOptionalToken:i,printDefiniteToken:o,printFunctionTypeParameters:c,printBindExpressionCallee:m,printTypeScriptModifiers:d,printTypeAnnotation:v,printRestSpread:f,adjustClause:p};}}),Kt=Z({"src/language-js/print/array.js"(e,n){re();var{printDanglingComments:t}=et(),{builders:{line:s,softline:a,hardline:r,group:u,indent:i,ifBreak:o,fill:c}}=Oe(),{getLast:v,hasNewline:m}=Ue(),{shouldPrintComma:d,hasComment:p,CommentCheckFlags:f,isNextLineEmpty:h,isNumericLiteral:w,isSignedNumericLiteral:T}=Ke(),{locStart:A}=st(),{printOptionalToken:S,printTypeAnnotation:B}=ct();function I(D,g,F){let l=D.getValue(),E=[],y=l.type==="TupleExpression"?"#[":"[",N="]";if(l.elements.length===0)p(l,f.Dangling)?E.push(u([y,t(D,g),a,N])):E.push(y,N);else {let x=v(l.elements),b=!(x&&x.type==="RestElement"),L=x===null,M=Symbol("array"),j=!g.__inJestEach&&l.elements.length>1&&l.elements.every((q,Y,H)=>{let R=q&&q.type;if(R!=="ArrayExpression"&&R!=="ObjectExpression")return !1;let Q=H[Y+1];if(Q&&R!==Q.type)return !1;let ee=R==="ArrayExpression"?"elements":"properties";return q[ee]&&q[ee].length>1}),$=k(l,g),V=b?L?",":d(g)?$?o(",","",{groupId:M}):o(","):"":"";E.push(u([y,i([a,$?C(D,g,F,V):[P(D,g,"elements",F),V],t(D,g,!0)]),a,N],{shouldBreak:j,id:M}));}return E.push(S(D),B(D,g,F)),E}function k(D,g){return D.elements.length>1&&D.elements.every(F=>F&&(w(F)||T(F)&&!p(F.argument))&&!p(F,f.Trailing|f.Line,l=>!m(g.originalText,A(l),{backwards:!0})))}function P(D,g,F,l){let E=[],y=[];return D.each(N=>{E.push(y,u(l())),y=[",",s],N.getValue()&&h(N.getValue(),g)&&y.push(a);},F),E}function C(D,g,F,l){let E=[];return D.each((y,N,x)=>{let b=N===x.length-1;E.push([F(),b?l:","]),b||E.push(h(y.getValue(),g)?[r,r]:p(x[N+1],f.Leading|f.Line)?r:s);},"elements"),c(E)}n.exports={printArray:I,printArrayItems:P,isConciselyPrintedArray:k};}}),io=Z({"src/language-js/print/call-arguments.js"(e,n){re();var{printDanglingComments:t}=et(),{getLast:s,getPenultimate:a}=Ue(),{getFunctionParameters:r,hasComment:u,CommentCheckFlags:i,isFunctionCompositionArgs:o,isJsxNode:c,isLongCurriedCallExpression:v,shouldPrintComma:m,getCallArguments:d,iterateCallArgumentsPath:p,isNextLineEmpty:f,isCallExpression:h,isStringLiteral:w,isObjectProperty:T}=Ke(),{builders:{line:A,hardline:S,softline:B,group:I,indent:k,conditionalGroup:P,ifBreak:C,breakParent:D},utils:{willBreak:g}}=Oe(),{ArgExpansionBailout:F}=zt(),{isConciselyPrintedArray:l}=Kt();function E(j,$,V){let q=j.getValue(),Y=q.type==="ImportExpression",H=d(q);if(H.length===0)return ["(",t(j,$,!0),")"];if(b(H))return ["(",V(["arguments",0]),", ",V(["arguments",1]),")"];let R=!1,Q=!1,ee=H.length-1,te=[];p(j,(ie,G)=>{let z=ie.getNode(),U=[V()];G===ee||(f(z,$)?(G===0&&(Q=!0),R=!0,U.push(",",S,S)):U.push(",",A)),te.push(U);});let oe=!(Y||q.callee&&q.callee.type==="Import")&&m($,"all")?",":"";function W(){return I(["(",k([A,...te]),oe,A,")"],{shouldBreak:!0})}if(R||j.getParentNode().type!=="Decorator"&&o(H))return W();let X=x(H),ue=N(H,$);if(X||ue){if(X?te.slice(1).some(g):te.slice(0,-1).some(g))return W();let ie=[];try{j.try(()=>{p(j,(G,z)=>{X&&z===0&&(ie=[[V([],{expandFirstArg:!0}),te.length>1?",":"",Q?S:A,Q?S:""],...te.slice(1)]),ue&&z===ee&&(ie=[...te.slice(0,-1),V([],{expandLastArg:!0})]);});});}catch(G){if(G instanceof F)return W();throw G}return [te.some(g)?D:"",P([["(",...ie,")"],X?["(",I(ie[0],{shouldBreak:!0}),...ie.slice(1),")"]:["(",...te.slice(0,-1),I(s(ie),{shouldBreak:!0}),")"],W()])]}let De=["(",k([B,...te]),C(oe),B,")"];return v(j)?De:I(De,{shouldBreak:te.some(g)||R})}function y(j){let $=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;return j.type==="ObjectExpression"&&(j.properties.length>0||u(j))||j.type==="ArrayExpression"&&(j.elements.length>0||u(j))||j.type==="TSTypeAssertion"&&y(j.expression)||j.type==="TSAsExpression"&&y(j.expression)||j.type==="FunctionExpression"||j.type==="ArrowFunctionExpression"&&(!j.returnType||!j.returnType.typeAnnotation||j.returnType.typeAnnotation.type!=="TSTypeReference"||L(j.body))&&(j.body.type==="BlockStatement"||j.body.type==="ArrowFunctionExpression"&&y(j.body,!0)||j.body.type==="ObjectExpression"||j.body.type==="ArrayExpression"||!$&&(h(j.body)||j.body.type==="ConditionalExpression")||c(j.body))||j.type==="DoExpression"||j.type==="ModuleExpression"}function N(j,$){let V=s(j),q=a(j);return !u(V,i.Leading)&&!u(V,i.Trailing)&&y(V)&&(!q||q.type!==V.type)&&(j.length!==2||q.type!=="ArrowFunctionExpression"||V.type!=="ArrayExpression")&&!(j.length>1&&V.type==="ArrayExpression"&&l(V,$))}function x(j){if(j.length!==2)return !1;let[$,V]=j;return $.type==="ModuleExpression"&&M(V)?!0:!u($)&&($.type==="FunctionExpression"||$.type==="ArrowFunctionExpression"&&$.body.type==="BlockStatement")&&V.type!=="FunctionExpression"&&V.type!=="ArrowFunctionExpression"&&V.type!=="ConditionalExpression"&&!y(V)}function b(j){return j.length===2&&j[0].type==="ArrowFunctionExpression"&&r(j[0]).length===0&&j[0].body.type==="BlockStatement"&&j[1].type==="ArrayExpression"&&!j.some($=>u($))}function L(j){return j.type==="BlockStatement"&&(j.body.some($=>$.type!=="EmptyStatement")||u(j,i.Dangling))}function M(j){return j.type==="ObjectExpression"&&j.properties.length===1&&T(j.properties[0])&&j.properties[0].key.type==="Identifier"&&j.properties[0].key.name==="type"&&w(j.properties[0].value)&&j.properties[0].value.value==="module"}n.exports=E;}}),ao=Z({"src/language-js/print/member.js"(e,n){re();var{builders:{softline:t,group:s,indent:a,label:r}}=Oe(),{isNumericLiteral:u,isMemberExpression:i,isCallExpression:o}=Ke(),{printOptionalToken:c}=ct();function v(d,p,f){let h=d.getValue(),w=d.getParentNode(),T,A=0;do T=d.getParentNode(A),A++;while(T&&(i(T)||T.type==="TSNonNullExpression"));let S=f("object"),B=m(d,p,f),I=T&&(T.type==="NewExpression"||T.type==="BindExpression"||T.type==="AssignmentExpression"&&T.left.type!=="Identifier")||h.computed||h.object.type==="Identifier"&&h.property.type==="Identifier"&&!i(w)||(w.type==="AssignmentExpression"||w.type==="VariableDeclarator")&&(o(h.object)&&h.object.arguments.length>0||h.object.type==="TSNonNullExpression"&&o(h.object.expression)&&h.object.expression.arguments.length>0||S.label==="member-chain");return r(S.label==="member-chain"?"member-chain":"member",[S,I?B:s(a([t,B]))])}function m(d,p,f){let h=f("property"),w=d.getValue(),T=c(d);return w.computed?!w.property||u(w.property)?[T,"[",h,"]"]:s([T,"[",a([t,h]),t,"]"]):[T,".",h]}n.exports={printMemberExpression:v,printMemberLookup:m};}}),Jm=Z({"src/language-js/print/member-chain.js"(e,n){re();var{printComments:t}=et(),{getLast:s,isNextLineEmptyAfterIndex:a,getNextNonSpaceNonCommentCharacterIndex:r}=Ue(),u=jt(),{isCallExpression:i,isMemberExpression:o,isFunctionOrArrowExpression:c,isLongCurriedCallExpression:v,isMemberish:m,isNumericLiteral:d,isSimpleCallArgument:p,hasComment:f,CommentCheckFlags:h,isNextLineEmpty:w}=Ke(),{locEnd:T}=st(),{builders:{join:A,hardline:S,group:B,indent:I,conditionalGroup:k,breakParent:P,label:C},utils:{willBreak:D}}=Oe(),g=io(),{printMemberLookup:F}=ao(),{printOptionalToken:l,printFunctionTypeParameters:E,printBindExpressionCallee:y}=ct();function N(x,b,L){let M=x.getParentNode(),j=!M||M.type==="ExpressionStatement",$=[];function V(de){let{originalText:ae}=b,ve=r(ae,de,T);return ae.charAt(ve)===")"?ve!==!1&&a(ae,ve+1):w(de,b)}function q(de){let ae=de.getValue();i(ae)&&(m(ae.callee)||i(ae.callee))?($.unshift({node:ae,printed:[t(de,[l(de),E(de,b,L),g(de,b,L)],b),V(ae)?S:""]}),de.call(ve=>q(ve),"callee")):m(ae)?($.unshift({node:ae,needsParens:u(de,b),printed:t(de,o(ae)?F(de,b,L):y(de,b,L),b)}),de.call(ve=>q(ve),"object")):ae.type==="TSNonNullExpression"?($.unshift({node:ae,printed:t(de,"!",b)}),de.call(ve=>q(ve),"expression")):$.unshift({node:ae,printed:L()});}let Y=x.getValue();$.unshift({node:Y,printed:[l(x),E(x,b,L),g(x,b,L)]}),Y.callee&&x.call(de=>q(de),"callee");let H=[],R=[$[0]],Q=1;for(;Q<$.length&&($[Q].node.type==="TSNonNullExpression"||i($[Q].node)||o($[Q].node)&&$[Q].node.computed&&d($[Q].node.property));++Q)R.push($[Q]);if(!i($[0].node))for(;Q+1<$.length&&(m($[Q].node)&&m($[Q+1].node));++Q)R.push($[Q]);H.push(R),R=[];let ee=!1;for(;Q<$.length;++Q){if(ee&&m($[Q].node)){if($[Q].node.computed&&d($[Q].node.property)){R.push($[Q]);continue}H.push(R),R=[],ee=!1;}(i($[Q].node)||$[Q].node.type==="ImportExpression")&&(ee=!0),R.push($[Q]),f($[Q].node,h.Trailing)&&(H.push(R),R=[],ee=!1);}R.length>0&&H.push(R);function te(de){return /^[A-Z]|^[$_]+$/.test(de)}function oe(de){return de.length<=b.tabWidth}function W(de){let ae=de[1].length>0&&de[1][0].node.computed;if(de[0].length===1){let K=de[0][0].node;return K.type==="ThisExpression"||K.type==="Identifier"&&(te(K.name)||j&&oe(K.name)||ae)}let ve=s(de[0]).node;return o(ve)&&ve.property.type==="Identifier"&&(te(ve.property.name)||ae)}let X=H.length>=2&&!f(H[1][0].node)&&W(H);function ue(de){let ae=de.map(ve=>ve.printed);return de.length>0&&s(de).needsParens?["(",...ae,")"]:ae}function De(de){return de.length===0?"":I(B([S,A(S,de.map(ue))]))}let ie=H.map(ue),G=ie,z=X?3:2,U=H.flat(),le=U.slice(1,-1).some(de=>f(de.node,h.Leading))||U.slice(0,-1).some(de=>f(de.node,h.Trailing))||H[z]&&f(H[z][0].node,h.Leading);if(H.length<=z&&!le)return v(x)?G:B(G);let ge=s(H[X?1:0]).node,Ae=!i(ge)&&V(ge),Ne=[ue(H[0]),X?H.slice(1,2).map(ue):"",Ae?S:"",De(H.slice(X?2:1))],ke=$.map(de=>{let{node:ae}=de;return ae}).filter(i);function ce(){let de=s(s(H)).node,ae=s(ie);return i(de)&&D(ae)&&ke.slice(0,-1).some(ve=>ve.arguments.some(c))}let pe;return le||ke.length>2&&ke.some(de=>!de.arguments.every(ae=>p(ae,0)))||ie.slice(0,-1).some(D)||ce()?pe=B(Ne):pe=[D(G)||Ae?P:"",k([G,Ne])],C("member-chain",pe)}n.exports=N;}}),oo=Z({"src/language-js/print/call-expression.js"(e,n){re();var{builders:{join:t,group:s}}=Oe(),a=jt(),{getCallArguments:r,hasFlowAnnotationComment:u,isCallExpression:i,isMemberish:o,isStringLiteral:c,isTemplateOnItsOwnLine:v,isTestCall:m,iterateCallArgumentsPath:d}=Ke(),p=Jm(),f=io(),{printOptionalToken:h,printFunctionTypeParameters:w}=ct();function T(S,B,I){let k=S.getValue(),P=S.getParentNode(),C=k.type==="NewExpression",D=k.type==="ImportExpression",g=h(S),F=r(k);if(F.length>0&&(!D&&!C&&A(k,P)||F.length===1&&v(F[0],B.originalText)||!C&&m(k,P))){let y=[];return d(S,()=>{y.push(I());}),[C?"new ":"",I("callee"),g,w(S,B,I),"(",t(", ",y),")"]}let l=(B.parser==="babel"||B.parser==="babel-flow")&&k.callee&&k.callee.type==="Identifier"&&u(k.callee.trailingComments);if(l&&(k.callee.trailingComments[0].printed=!0),!D&&!C&&o(k.callee)&&!S.call(y=>a(y,B),"callee"))return p(S,B,I);let E=[C?"new ":"",D?"import":I("callee"),g,l?"/*:: ".concat(k.callee.trailingComments[0].value.slice(2).trim()," */"):"",w(S,B,I),f(S,B,I)];return D||i(k.callee)?s(E):E}function A(S,B){if(S.callee.type!=="Identifier")return !1;if(S.callee.name==="require")return !0;if(S.callee.name==="define"){let I=r(S);return B.type==="ExpressionStatement"&&(I.length===1||I.length===2&&I[0].type==="ArrayExpression"||I.length===3&&c(I[0])&&I[1].type==="ArrayExpression")}return !1}n.exports={printCallExpression:T};}}),Yt=Z({"src/language-js/print/assignment.js"(e,n){re();var{isNonEmptyArray:t,getStringWidth:s}=Ue(),{builders:{line:a,group:r,indent:u,indentIfBreak:i,lineSuffixBoundary:o},utils:{cleanDoc:c,willBreak:v,canBreak:m}}=Oe(),{hasLeadingOwnLineComment:d,isBinaryish:p,isStringLiteral:f,isLiteral:h,isNumericLiteral:w,isCallExpression:T,isMemberExpression:A,getCallArguments:S,rawText:B,hasComment:I,isSignedNumericLiteral:k,isObjectProperty:P}=Ke(),{shouldInlineLogicalExpression:C}=Jn(),{printCallExpression:D}=oo();function g(W,X,ue,De,ie,G){let z=E(W,X,ue,De,G),U=ue(G,{assignmentLayout:z});switch(z){case"break-after-operator":return r([r(De),ie,r(u([a,U]))]);case"never-break-after-operator":return r([r(De),ie," ",U]);case"fluid":{let le=Symbol("assignment");return r([r(De),ie,r(u(a),{id:le}),o,i(U,{groupId:le})])}case"break-lhs":return r([De,ie," ",r(U)]);case"chain":return [r(De),ie,a,U];case"chain-tail":return [r(De),ie,u([a,U])];case"chain-tail-arrow-chain":return [r(De),ie,U];case"only-left":return De}}function F(W,X,ue){let De=W.getValue();return g(W,X,ue,ue("left"),[" ",De.operator],"right")}function l(W,X,ue){return g(W,X,ue,ue("id")," =","init")}function E(W,X,ue,De,ie){let G=W.getValue(),z=G[ie];if(!z)return "only-left";let U=!x(z);if(W.match(x,b,Ne=>!U||Ne.type!=="ExpressionStatement"&&Ne.type!=="VariableDeclaration"))return U?z.type==="ArrowFunctionExpression"&&z.body.type==="ArrowFunctionExpression"?"chain-tail-arrow-chain":"chain-tail":"chain";if(!U&&x(z.right)||d(X.originalText,z))return "break-after-operator";if(z.type==="CallExpression"&&z.callee.name==="require"||X.parser==="json5"||X.parser==="json")return "never-break-after-operator";if(N(G)||L(G)||$(G)||V(G)&&m(De))return "break-lhs";let Ae=ee(G,De,X);return W.call(()=>y(W,X,ue,Ae),ie)?"break-after-operator":Ae||z.type==="TemplateLiteral"||z.type==="TaggedTemplateExpression"||z.type==="BooleanLiteral"||w(z)||z.type==="ClassExpression"?"never-break-after-operator":"fluid"}function y(W,X,ue,De){let ie=W.getValue();if(p(ie)&&!C(ie))return !0;switch(ie.type){case"StringLiteralTypeAnnotation":case"SequenceExpression":return !0;case"ConditionalExpression":{let{test:U}=ie;return p(U)&&!C(U)}case"ClassExpression":return t(ie.decorators)}if(De)return !1;let G=ie,z=[];for(;;)if(G.type==="UnaryExpression")G=G.argument,z.push("argument");else if(G.type==="TSNonNullExpression")G=G.expression,z.push("expression");else break;return !!(f(G)||W.call(()=>H(W,X,ue),...z))}function N(W){if(b(W)){let X=W.left||W.id;return X.type==="ObjectPattern"&&X.properties.length>2&&X.properties.some(ue=>P(ue)&&(!ue.shorthand||ue.value&&ue.value.type==="AssignmentPattern"))}return !1}function x(W){return W.type==="AssignmentExpression"}function b(W){return x(W)||W.type==="VariableDeclarator"}function L(W){let X=M(W);if(t(X)){let ue=W.type==="TSTypeAliasDeclaration"?"constraint":"bound";if(X.length>1&&X.some(De=>De[ue]||De.default))return !0}return !1}function M(W){return j(W)&&W.typeParameters&&W.typeParameters.params?W.typeParameters.params:null}function j(W){return W.type==="TSTypeAliasDeclaration"||W.type==="TypeAlias"}function $(W){if(W.type!=="VariableDeclarator")return !1;let{typeAnnotation:X}=W.id;if(!X||!X.typeAnnotation)return !1;let ue=q(X.typeAnnotation);return t(ue)&&ue.length>1&&ue.some(De=>t(q(De))||De.type==="TSConditionalType")}function V(W){return W.type==="VariableDeclarator"&&W.init&&W.init.type==="ArrowFunctionExpression"}function q(W){return Y(W)&&W.typeParameters&&W.typeParameters.params?W.typeParameters.params:null}function Y(W){return W.type==="TSTypeReference"||W.type==="GenericTypeAnnotation"}function H(W,X,ue){let De=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1,ie=W.getValue(),G=()=>H(W,X,ue,!0);if(ie.type==="TSNonNullExpression")return W.call(G,"expression");if(T(ie)){if(D(W,X,ue).label==="member-chain")return !1;let U=S(ie);return !(U.length===0||U.length===1&&Q(U[0],X))||te(ie,ue)?!1:W.call(G,"callee")}return A(ie)?W.call(G,"object"):De&&(ie.type==="Identifier"||ie.type==="ThisExpression")}var R=.25;function Q(W,X){let{printWidth:ue}=X;if(I(W))return !1;let De=ue*R;if(W.type==="ThisExpression"||W.type==="Identifier"&&W.name.length<=De||k(W)&&!I(W.argument))return !0;let ie=W.type==="Literal"&&"regex"in W&&W.regex.pattern||W.type==="RegExpLiteral"&&W.pattern;return ie?ie.length<=De:f(W)?B(W).length<=De:W.type==="TemplateLiteral"?W.expressions.length===0&&W.quasis[0].value.raw.length<=De&&!W.quasis[0].value.raw.includes(`
	`):h(W)}function ee(W,X,ue){if(!P(W))return !1;X=c(X);let De=3;return typeof X=="string"&&s(X)<ue.tabWidth+De}function te(W,X){let ue=oe(W);if(t(ue)){if(ue.length>1)return !0;if(ue.length===1){let ie=ue[0];if(ie.type==="TSUnionType"||ie.type==="UnionTypeAnnotation"||ie.type==="TSIntersectionType"||ie.type==="IntersectionTypeAnnotation"||ie.type==="TSTypeLiteral"||ie.type==="ObjectTypeAnnotation")return !0}let De=W.typeParameters?"typeParameters":"typeArguments";if(v(X(De)))return !0}return !1}function oe(W){return W.typeParameters&&W.typeParameters.params||W.typeArguments&&W.typeArguments.params}n.exports={printVariableDeclarator:l,printAssignmentExpression:F,printAssignment:g,isArrowFunctionVariableDeclarator:V};}}),Pr=Z({"src/language-js/print/function-parameters.js"(e,n){re();var{getNextNonSpaceNonCommentCharacter:t}=Ue(),{printDanglingComments:s}=et(),{builders:{line:a,hardline:r,softline:u,group:i,indent:o,ifBreak:c},utils:{removeLines:v,willBreak:m}}=Oe(),{getFunctionParameters:d,iterateFunctionParametersPath:p,isSimpleType:f,isTestCall:h,isTypeAnnotationAFunction:w,isObjectType:T,isObjectTypePropertyAFunction:A,hasRestParameter:S,shouldPrintComma:B,hasComment:I,isNextLineEmpty:k}=Ke(),{locEnd:P}=st(),{ArgExpansionBailout:C}=zt(),{printFunctionTypeParameters:D}=ct();function g(y,N,x,b,L){let M=y.getValue(),j=d(M),$=L?D(y,x,N):"";if(j.length===0)return [$,"(",s(y,x,!0,ee=>t(x.originalText,ee,P)===")"),")"];let V=y.getParentNode(),q=h(V),Y=F(M),H=[];if(p(y,(ee,te)=>{let oe=te===j.length-1;oe&&M.rest&&H.push("..."),H.push(N()),!oe&&(H.push(","),q||Y?H.push(" "):k(j[te],x)?H.push(r,r):H.push(a));}),b){if(m($)||m(H))throw new C;return i([v($),"(",v(H),")"])}let R=j.every(ee=>!ee.decorators);return Y&&R?[$,"(",...H,")"]:q?[$,"(",...H,")"]:(A(V)||w(V)||V.type==="TypeAlias"||V.type==="UnionTypeAnnotation"||V.type==="TSUnionType"||V.type==="IntersectionTypeAnnotation"||V.type==="FunctionTypeAnnotation"&&V.returnType===M)&&j.length===1&&j[0].name===null&&M.this!==j[0]&&j[0].typeAnnotation&&M.typeParameters===null&&f(j[0].typeAnnotation)&&!M.rest?x.arrowParens==="always"?["(",...H,")"]:H:[$,"(",o([u,...H]),c(!S(M)&&B(x,"all")?",":""),u,")"]}function F(y){if(!y)return !1;let N=d(y);if(N.length!==1)return !1;let[x]=N;return !I(x)&&(x.type==="ObjectPattern"||x.type==="ArrayPattern"||x.type==="Identifier"&&x.typeAnnotation&&(x.typeAnnotation.type==="TypeAnnotation"||x.typeAnnotation.type==="TSTypeAnnotation")&&T(x.typeAnnotation.typeAnnotation)||x.type==="FunctionTypeParam"&&T(x.typeAnnotation)||x.type==="AssignmentPattern"&&(x.left.type==="ObjectPattern"||x.left.type==="ArrayPattern")&&(x.right.type==="Identifier"||x.right.type==="ObjectExpression"&&x.right.properties.length===0||x.right.type==="ArrayExpression"&&x.right.elements.length===0))}function l(y){let N;return y.returnType?(N=y.returnType,N.typeAnnotation&&(N=N.typeAnnotation)):y.typeAnnotation&&(N=y.typeAnnotation),N}function E(y,N){let x=l(y);if(!x)return !1;let b=y.typeParameters&&y.typeParameters.params;if(b){if(b.length>1)return !1;if(b.length===1){let L=b[0];if(L.constraint||L.default)return !1}}return d(y).length===1&&(T(x)||m(N))}n.exports={printFunctionParameters:g,shouldHugFunctionParameters:F,shouldGroupFunctionParameters:E};}}),kr=Z({"src/language-js/print/type-annotation.js"(e,n){re();var{printComments:t,printDanglingComments:s}=et(),{isNonEmptyArray:a}=Ue(),{builders:{group:r,join:u,line:i,softline:o,indent:c,align:v,ifBreak:m}}=Oe(),d=jt(),{locStart:p}=st(),{isSimpleType:f,isObjectType:h,hasLeadingOwnLineComment:w,isObjectTypePropertyAFunction:T,shouldPrintComma:A}=Ke(),{printAssignment:S}=Yt(),{printFunctionParameters:B,shouldGroupFunctionParameters:I}=Pr(),{printArrayItems:k}=Kt();function P(x){if(f(x)||h(x))return !0;if(x.type==="UnionTypeAnnotation"||x.type==="TSUnionType"){let b=x.types.filter(M=>M.type==="VoidTypeAnnotation"||M.type==="TSVoidKeyword"||M.type==="NullLiteralTypeAnnotation"||M.type==="TSNullKeyword").length,L=x.types.some(M=>M.type==="ObjectTypeAnnotation"||M.type==="TSTypeLiteral"||M.type==="GenericTypeAnnotation"||M.type==="TSTypeReference");if(x.types.length-1===b&&L)return !0}return !1}function C(x,b,L){let M=b.semi?";":"",j=x.getValue(),$=[];return $.push("opaque type ",L("id"),L("typeParameters")),j.supertype&&$.push(": ",L("supertype")),j.impltype&&$.push(" = ",L("impltype")),$.push(M),$}function D(x,b,L){let M=b.semi?";":"",j=x.getValue(),$=[];j.declare&&$.push("declare "),$.push("type ",L("id"),L("typeParameters"));let V=j.type==="TSTypeAliasDeclaration"?"typeAnnotation":"right";return [S(x,b,L,$," =",V),M]}function g(x,b,L){let M=x.getValue(),j=x.map(L,"types"),$=[],V=!1;for(let q=0;q<j.length;++q)q===0?$.push(j[q]):h(M.types[q-1])&&h(M.types[q])?$.push([" & ",V?c(j[q]):j[q]]):!h(M.types[q-1])&&!h(M.types[q])?$.push(c([" &",i,j[q]])):(q>1&&(V=!0),$.push(" & ",q>1?c(j[q]):j[q]));return r($)}function F(x,b,L){let M=x.getValue(),j=x.getParentNode(),$=j.type!=="TypeParameterInstantiation"&&j.type!=="TSTypeParameterInstantiation"&&j.type!=="GenericTypeAnnotation"&&j.type!=="TSTypeReference"&&j.type!=="TSTypeAssertion"&&j.type!=="TupleTypeAnnotation"&&j.type!=="TSTupleType"&&!(j.type==="FunctionTypeParam"&&!j.name&&x.getParentNode(1).this!==j)&&!((j.type==="TypeAlias"||j.type==="VariableDeclarator"||j.type==="TSTypeAliasDeclaration")&&w(b.originalText,M)),V=P(M),q=x.map(R=>{let Q=L();return V||(Q=v(2,Q)),t(R,Q,b)},"types");if(V)return u(" | ",q);let Y=$&&!w(b.originalText,M),H=[m([Y?i:"","| "]),u([i,"| "],q)];return d(x,b)?r([c(H),o]):j.type==="TupleTypeAnnotation"&&j.types.length>1||j.type==="TSTupleType"&&j.elementTypes.length>1?r([c([m(["(",o]),H]),o,m(")")]):r($?c(H):H)}function l(x,b,L){let M=x.getValue(),j=[],$=x.getParentNode(0),V=x.getParentNode(1),q=x.getParentNode(2),Y=M.type==="TSFunctionType"||!(($.type==="ObjectTypeProperty"||$.type==="ObjectTypeInternalSlot")&&!$.variance&&!$.optional&&p($)===p(M)||$.type==="ObjectTypeCallProperty"||q&&q.type==="DeclareFunction"),H=Y&&($.type==="TypeAnnotation"||$.type==="TSTypeAnnotation"),R=H&&Y&&($.type==="TypeAnnotation"||$.type==="TSTypeAnnotation")&&V.type==="ArrowFunctionExpression";T($)&&(Y=!0,H=!0),R&&j.push("(");let Q=B(x,L,b,!1,!0),ee=M.returnType||M.predicate||M.typeAnnotation?[Y?" => ":": ",L("returnType"),L("predicate"),L("typeAnnotation")]:"",te=I(M,ee);return j.push(te?r(Q):Q),ee&&j.push(ee),R&&j.push(")"),r(j)}function E(x,b,L){let M=x.getValue(),j=M.type==="TSTupleType"?"elementTypes":"types",$=M[j],V=a($),q=V?o:"";return r(["[",c([q,k(x,b,j,L)]),m(V&&A(b,"all")?",":""),s(x,b,!0),q,"]"])}function y(x,b,L){let M=x.getValue(),j=M.type==="OptionalIndexedAccessType"&&M.optional?"?.[":"[";return [L("objectType"),j,L("indexType"),"]"]}function N(x,b,L){let M=x.getValue();return [M.postfix?"":L,b("typeAnnotation"),M.postfix?L:""]}n.exports={printOpaqueType:C,printTypeAlias:D,printIntersectionType:g,printUnionType:F,printFunctionType:l,printTupleType:E,printIndexedAccessType:y,shouldHugType:P,printJSDocType:N};}}),Ir=Z({"src/language-js/print/type-parameters.js"(e,n){re();var{printDanglingComments:t}=et(),{builders:{join:s,line:a,hardline:r,softline:u,group:i,indent:o,ifBreak:c}}=Oe(),{isTestCall:v,hasComment:m,CommentCheckFlags:d,isTSXFile:p,shouldPrintComma:f,getFunctionParameters:h,isObjectType:w}=Ke(),{createGroupIdMapper:T}=Ue(),{shouldHugType:A}=kr(),{isArrowFunctionVariableDeclarator:S}=Yt(),B=T("typeParameters");function I(C,D,g,F){let l=C.getValue();if(!l[F])return "";if(!Array.isArray(l[F]))return g(F);let E=C.getNode(2),y=E&&v(E);if(!C.match(L=>!(L[F].length===1&&w(L[F][0])),void 0,(L,M)=>M==="typeAnnotation",L=>L.type==="Identifier",S)&&(y||l[F].length===0||l[F].length===1&&(l[F][0].type==="NullableTypeAnnotation"||A(l[F][0]))))return ["<",s(", ",C.map(g,F)),k(C,D),">"];let b=l.type==="TSTypeParameterInstantiation"?"":h(l).length===1&&p(D)&&!l[F][0].constraint&&C.getParentNode().type==="ArrowFunctionExpression"?",":f(D,"all")?c(","):"";return i(["<",o([u,s([",",a],C.map(g,F))]),b,u,">"],{id:B(l)})}function k(C,D){let g=C.getValue();if(!m(g,d.Dangling))return "";let F=!m(g,d.Line),l=t(C,D,F);return F?l:[l,r]}function P(C,D,g){let F=C.getValue(),l=[],E=C.getParentNode();return E.type==="TSMappedType"?(l.push("[",g("name")),F.constraint&&l.push(" in ",g("constraint")),E.nameType&&l.push(" as ",C.callParent(()=>g("nameType"))),l.push("]"),l):(F.variance&&l.push(g("variance")),F.in&&l.push("in "),F.out&&l.push("out "),l.push(g("name")),F.bound&&l.push(": ",g("bound")),F.constraint&&l.push(" extends ",g("constraint")),F.default&&l.push(" = ",g("default")),l)}n.exports={printTypeParameter:P,printTypeParameters:I,getTypeParametersGroupId:B};}}),Qt=Z({"src/language-js/print/property.js"(e,n){re();var{printComments:t}=et(),{printString:s,printNumber:a}=Ue(),{isNumericLiteral:r,isSimpleNumber:u,isStringLiteral:i,isStringPropSafeToUnquote:o,rawText:c}=Ke(),{printAssignment:v}=Yt(),m=new WeakMap;function d(f,h,w){let T=f.getNode();if(T.computed)return ["[",w("key"),"]"];let A=f.getParentNode(),{key:S}=T;if(T.type==="ClassPrivateProperty"&&S.type==="Identifier")return ["#",w("key")];if(h.quoteProps==="consistent"&&!m.has(A)){let B=(A.properties||A.body||A.members).some(I=>!I.computed&&I.key&&i(I.key)&&!o(I,h));m.set(A,B);}if((S.type==="Identifier"||r(S)&&u(a(c(S)))&&String(S.value)===a(c(S))&&!(h.parser==="typescript"||h.parser==="babel-ts"))&&(h.parser==="json"||h.quoteProps==="consistent"&&m.get(A))){let B=s(JSON.stringify(S.type==="Identifier"?S.name:S.value.toString()),h);return f.call(I=>t(I,B,h),"key")}return o(T,h)&&(h.quoteProps==="as-needed"||h.quoteProps==="consistent"&&!m.get(A))?f.call(B=>t(B,/^\d/.test(S.value)?a(S.value):S.value,h),"key"):w("key")}function p(f,h,w){return f.getValue().shorthand?w("value"):v(f,h,w,d(f,h,w),":","value")}n.exports={printProperty:p,printPropertyKey:d};}}),Lr=Z({"src/language-js/print/function.js"(e,n){re();var t=Xt(),{printDanglingComments:s,printCommentsSeparately:a}=et(),r=it(),{getNextNonSpaceNonCommentCharacterIndex:u}=Ue(),{builders:{line:i,softline:o,group:c,indent:v,ifBreak:m,hardline:d,join:p,indentIfBreak:f},utils:{removeLines:h,willBreak:w}}=Oe(),{ArgExpansionBailout:T}=zt(),{getFunctionParameters:A,hasLeadingOwnLineComment:S,isFlowAnnotationComment:B,isJsxNode:I,isTemplateOnItsOwnLine:k,shouldPrintComma:P,startsWithNoLookaheadToken:C,isBinaryish:D,isLineComment:g,hasComment:F,getComments:l,CommentCheckFlags:E,isCallLikeExpression:y,isCallExpression:N,getCallArguments:x,hasNakedLeftSide:b,getLeftSide:L}=Ke(),{locEnd:M}=st(),{printFunctionParameters:j,shouldGroupFunctionParameters:$}=Pr(),{printPropertyKey:V}=Qt(),{printFunctionTypeParameters:q}=ct();function Y(z,U,le,ge){let Ae=z.getValue(),Ne=!1;if((Ae.type==="FunctionDeclaration"||Ae.type==="FunctionExpression")&&ge&&ge.expandLastArg){let ae=z.getParentNode();N(ae)&&x(ae).length>1&&(Ne=!0);}let ke=[];Ae.type==="TSDeclareFunction"&&Ae.declare&&ke.push("declare "),Ae.async&&ke.push("async "),Ae.generator?ke.push("function* "):ke.push("function "),Ae.id&&ke.push(U("id"));let ce=j(z,U,le,Ne),pe=X(z,U,le),de=$(Ae,pe);return ke.push(q(z,le,U),c([de?c(ce):ce,pe]),Ae.body?" ":"",U("body")),le.semi&&(Ae.declare||!Ae.body)&&ke.push(";"),ke}function H(z,U,le){let ge=z.getNode(),{kind:Ae}=ge,Ne=ge.value||ge,ke=[];return !Ae||Ae==="init"||Ae==="method"||Ae==="constructor"?Ne.async&&ke.push("async "):(t.ok(Ae==="get"||Ae==="set"),ke.push(Ae," ")),Ne.generator&&ke.push("*"),ke.push(V(z,U,le),ge.optional||ge.key.optional?"?":""),ge===Ne?ke.push(R(z,U,le)):Ne.type==="FunctionExpression"?ke.push(z.call(ce=>R(ce,U,le),"value")):ke.push(le("value")),ke}function R(z,U,le){let ge=z.getNode(),Ae=j(z,le,U),Ne=X(z,le,U),ke=$(ge,Ne),ce=[q(z,U,le),c([ke?c(Ae):Ae,Ne])];return ge.body?ce.push(" ",le("body")):ce.push(U.semi?";":""),ce}function Q(z,U,le,ge){let Ae=z.getValue(),Ne=[];if(Ae.async&&Ne.push("async "),W(z,U))Ne.push(le(["params",0]));else {let ce=ge&&(ge.expandLastArg||ge.expandFirstArg),pe=X(z,le,U);if(ce){if(w(pe))throw new T;pe=c(h(pe));}Ne.push(c([j(z,le,U,ce,!0),pe]));}let ke=s(z,U,!0,ce=>{let pe=u(U.originalText,ce,M);return pe!==!1&&U.originalText.slice(pe,pe+2)==="=>"});return ke&&Ne.push(" ",ke),Ne}function ee(z,U,le,ge,Ae,Ne){let ke=z.getName(),ce=z.getParentNode(),pe=y(ce)&&ke==="callee",de=Boolean(U&&U.assignmentLayout),ae=Ne.body.type!=="BlockStatement"&&Ne.body.type!=="ObjectExpression"&&Ne.body.type!=="SequenceExpression",ve=pe&&ae||U&&U.assignmentLayout==="chain-tail-arrow-chain",K=Symbol("arrow-chain");return Ne.body.type==="SequenceExpression"&&(Ae=c(["(",v([o,Ae]),o,")"])),c([c(v([pe||de?o:"",c(p([" =>",i],le),{shouldBreak:ge})]),{id:K,shouldBreak:ve})," =>",f(ae?v([i,Ae]):[" ",Ae],{groupId:K}),pe?m(o,"",{groupId:K}):""])}function te(z,U,le,ge){let Ae=z.getValue(),Ne=[],ke=[],ce=!1;if(function K(){let he=Q(z,U,le,ge);if(Ne.length===0)Ne.push(he);else {let{leading:ye,trailing:Ce}=a(z,U);Ne.push([ye,he]),ke.unshift(Ce);}ce=ce||Ae.returnType&&A(Ae).length>0||Ae.typeParameters||A(Ae).some(ye=>ye.type!=="Identifier"),Ae.body.type!=="ArrowFunctionExpression"||ge&&ge.expandLastArg?ke.unshift(le("body",ge)):(Ae=Ae.body,z.call(K,"body"));}(),Ne.length>1)return ee(z,ge,Ne,ce,ke,Ae);let pe=Ne;if(pe.push(" =>"),!S(U.originalText,Ae.body)&&(Ae.body.type==="ArrayExpression"||Ae.body.type==="ObjectExpression"||Ae.body.type==="BlockStatement"||I(Ae.body)||k(Ae.body,U.originalText)||Ae.body.type==="ArrowFunctionExpression"||Ae.body.type==="DoExpression"))return c([...pe," ",ke]);if(Ae.body.type==="SequenceExpression")return c([...pe,c([" (",v([o,ke]),o,")"])]);let de=(ge&&ge.expandLastArg||z.getParentNode().type==="JSXExpressionContainer")&&!F(Ae),ae=ge&&ge.expandLastArg&&P(U,"all"),ve=Ae.body.type==="ConditionalExpression"&&!C(Ae.body,!1);return c([...pe,c([v([i,ve?m("","("):"",ke,ve?m("",")"):""]),de?[m(ae?",":""),o]:""])])}function oe(z){let U=A(z);return U.length===1&&!z.typeParameters&&!F(z,E.Dangling)&&U[0].type==="Identifier"&&!U[0].typeAnnotation&&!F(U[0])&&!U[0].optional&&!z.predicate&&!z.returnType}function W(z,U){if(U.arrowParens==="always")return !1;if(U.arrowParens==="avoid"){let le=z.getValue();return oe(le)}return !1}function X(z,U,le){let ge=z.getValue(),Ae=U("returnType");if(ge.returnType&&B(le.originalText,ge.returnType))return [" /*: ",Ae," */"];let Ne=[Ae];return ge.returnType&&ge.returnType.typeAnnotation&&Ne.unshift(": "),ge.predicate&&Ne.push(ge.returnType?" ":": ",U("predicate")),Ne}function ue(z,U,le){let ge=z.getValue(),Ae=U.semi?";":"",Ne=[];ge.argument&&(G(U,ge.argument)?Ne.push([" (",v([d,le("argument")]),d,")"]):D(ge.argument)||ge.argument.type==="SequenceExpression"?Ne.push(c([m(" ("," "),v([o,le("argument")]),o,m(")")])):Ne.push(" ",le("argument")));let ke=l(ge),ce=r(ke),pe=ce&&g(ce);return pe&&Ne.push(Ae),F(ge,E.Dangling)&&Ne.push(" ",s(z,U,!0)),pe||Ne.push(Ae),Ne}function De(z,U,le){return ["return",ue(z,U,le)]}function ie(z,U,le){return ["throw",ue(z,U,le)]}function G(z,U){if(S(z.originalText,U))return !0;if(b(U)){let le=U,ge;for(;ge=L(le);)if(le=ge,S(z.originalText,le))return !0}return !1}n.exports={printFunction:Y,printArrowFunction:te,printMethod:H,printReturnStatement:De,printThrowStatement:ie,printMethodInternal:R,shouldPrintParamsWithoutParens:W};}}),Un=Z({"src/language-js/print/decorators.js"(e,n){re();var{isNonEmptyArray:t,hasNewline:s}=Ue(),{builders:{line:a,hardline:r,join:u,breakParent:i,group:o}}=Oe(),{locStart:c,locEnd:v}=st(),{getParentExportDeclaration:m}=Ke();function d(T,A,S){let B=T.getValue();return o([u(a,T.map(S,"decorators")),h(B,A)?r:a])}function p(T,A,S){return [u(r,T.map(S,"declaration","decorators")),r]}function f(T,A,S){let B=T.getValue(),{decorators:I}=B;if(!t(I)||w(T.getParentNode()))return;let k=B.type==="ClassExpression"||B.type==="ClassDeclaration"||h(B,A);return [m(T)?r:k?i:"",u(a,T.map(S,"decorators")),a]}function h(T,A){return T.decorators.some(S=>s(A.originalText,v(S)))}function w(T){if(T.type!=="ExportDefaultDeclaration"&&T.type!=="ExportNamedDeclaration"&&T.type!=="DeclareExportDeclaration")return !1;let A=T.declaration&&T.declaration.decorators;return t(A)&&c(T,{ignoreDecorators:!0})>c(A[0])}n.exports={printDecorators:f,printClassMemberDecorators:d,printDecoratorsBeforeExport:p,hasDecoratorsBeforeExport:w};}}),Zt=Z({"src/language-js/print/class.js"(e,n){re();var{isNonEmptyArray:t,createGroupIdMapper:s}=Ue(),{printComments:a,printDanglingComments:r}=et(),{builders:{join:u,line:i,hardline:o,softline:c,group:v,indent:m,ifBreak:d}}=Oe(),{hasComment:p,CommentCheckFlags:f}=Ke(),{getTypeParametersGroupId:h}=Ir(),{printMethod:w}=Lr(),{printOptionalToken:T,printTypeAnnotation:A,printDefiniteToken:S}=ct(),{printPropertyKey:B}=Qt(),{printAssignment:I}=Yt(),{printClassMemberDecorators:k}=Un();function P(x,b,L){let M=x.getValue(),j=[];M.declare&&j.push("declare "),M.abstract&&j.push("abstract "),j.push("class");let $=M.id&&p(M.id,f.Trailing)||M.typeParameters&&p(M.typeParameters,f.Trailing)||M.superClass&&p(M.superClass)||t(M.extends)||t(M.mixins)||t(M.implements),V=[],q=[];if(M.id&&V.push(" ",L("id")),V.push(L("typeParameters")),M.superClass){let Y=[E(x,b,L),L("superTypeParameters")],H=x.call(R=>["extends ",a(R,Y,b)],"superClass");$?q.push(i,v(H)):q.push(" ",H);}else q.push(l(x,b,L,"extends"));if(q.push(l(x,b,L,"mixins"),l(x,b,L,"implements")),$){let Y;F(M)?Y=[...V,m(q)]:Y=m([...V,q]),j.push(v(Y,{id:C(M)}));}else j.push(...V,...q);return j.push(" ",L("body")),j}var C=s("heritageGroup");function D(x){return d(o,"",{groupId:C(x)})}function g(x){return ["superClass","extends","mixins","implements"].filter(b=>Boolean(x[b])).length>1}function F(x){return x.typeParameters&&!p(x.typeParameters,f.Trailing|f.Line)&&!g(x)}function l(x,b,L,M){let j=x.getValue();if(!t(j[M]))return "";let $=r(x,b,!0,V=>{let{marker:q}=V;return q===M});return [F(j)?d(" ",i,{groupId:h(j.typeParameters)}):i,$,$&&o,M,v(m([i,u([",",i],x.map(L,M))]))]}function E(x,b,L){let M=L("superClass");return x.getParentNode().type==="AssignmentExpression"?v(d(["(",m([c,M]),c,")"],M)):M}function y(x,b,L){let M=x.getValue(),j=[];return t(M.decorators)&&j.push(k(x,b,L)),M.accessibility&&j.push(M.accessibility+" "),M.readonly&&j.push("readonly "),M.declare&&j.push("declare "),M.static&&j.push("static "),(M.type==="TSAbstractMethodDefinition"||M.abstract)&&j.push("abstract "),M.override&&j.push("override "),j.push(w(x,b,L)),j}function N(x,b,L){let M=x.getValue(),j=[],$=b.semi?";":"";return t(M.decorators)&&j.push(k(x,b,L)),M.accessibility&&j.push(M.accessibility+" "),M.declare&&j.push("declare "),M.static&&j.push("static "),(M.type==="TSAbstractPropertyDefinition"||M.abstract)&&j.push("abstract "),M.override&&j.push("override "),M.readonly&&j.push("readonly "),M.variance&&j.push(L("variance")),M.type==="ClassAccessorProperty"&&j.push("accessor "),j.push(B(x,b,L),T(x),S(x),A(x,b,L)),[I(x,b,L,j," =","value"),$]}n.exports={printClass:P,printClassMethod:y,printClassProperty:N,printHardlineAfterHeritage:D};}}),lo=Z({"src/language-js/print/interface.js"(e,n){re();var{isNonEmptyArray:t}=Ue(),{builders:{join:s,line:a,group:r,indent:u,ifBreak:i}}=Oe(),{hasComment:o,identity:c,CommentCheckFlags:v}=Ke(),{getTypeParametersGroupId:m}=Ir(),{printTypeScriptModifiers:d}=ct();function p(f,h,w){let T=f.getValue(),A=[];T.declare&&A.push("declare "),T.type==="TSInterfaceDeclaration"&&A.push(T.abstract?"abstract ":"",d(f,h,w)),A.push("interface");let S=[],B=[];T.type!=="InterfaceTypeAnnotation"&&S.push(" ",w("id"),w("typeParameters"));let I=T.typeParameters&&!o(T.typeParameters,v.Trailing|v.Line);return t(T.extends)&&B.push(I?i(" ",a,{groupId:m(T.typeParameters)}):a,"extends ",(T.extends.length===1?c:u)(s([",",a],f.map(w,"extends")))),T.id&&o(T.id,v.Trailing)||t(T.extends)?I?A.push(r([...S,u(B)])):A.push(r(u([...S,...B]))):A.push(...S,...B),A.push(" ",w("body")),r(A)}n.exports={printInterface:p};}}),co=Z({"src/language-js/print/module.js"(e,n){re();var{isNonEmptyArray:t}=Ue(),{builders:{softline:s,group:a,indent:r,join:u,line:i,ifBreak:o,hardline:c}}=Oe(),{printDanglingComments:v}=et(),{hasComment:m,CommentCheckFlags:d,shouldPrintComma:p,needsHardlineAfterDanglingComment:f,isStringLiteral:h,rawText:w}=Ke(),{locStart:T,hasSameLoc:A}=st(),{hasDecoratorsBeforeExport:S,printDecoratorsBeforeExport:B}=Un();function I(N,x,b){let L=N.getValue(),M=x.semi?";":"",j=[],{importKind:$}=L;return j.push("import"),$&&$!=="value"&&j.push(" ",$),j.push(g(N,x,b),D(N,x,b),l(N,x,b),M),j}function k(N,x,b){let L=N.getValue(),M=[];S(L)&&M.push(B(N,x,b));let{type:j,exportKind:$,declaration:V}=L;return M.push("export"),(L.default||j==="ExportDefaultDeclaration")&&M.push(" default"),m(L,d.Dangling)&&(M.push(" ",v(N,x,!0)),f(L)&&M.push(c)),V?M.push(" ",b("declaration")):M.push($==="type"?" type":"",g(N,x,b),D(N,x,b),l(N,x,b)),C(L,x)&&M.push(";"),M}function P(N,x,b){let L=N.getValue(),M=x.semi?";":"",j=[],{exportKind:$,exported:V}=L;return j.push("export"),$==="type"&&j.push(" type"),j.push(" *"),V&&j.push(" as ",b("exported")),j.push(D(N,x,b),l(N,x,b),M),j}function C(N,x){if(!x.semi)return !1;let{type:b,declaration:L}=N,M=N.default||b==="ExportDefaultDeclaration";if(!L)return !0;let{type:j}=L;return !!(M&&j!=="ClassDeclaration"&&j!=="FunctionDeclaration"&&j!=="TSInterfaceDeclaration"&&j!=="DeclareClass"&&j!=="DeclareFunction"&&j!=="TSDeclareFunction"&&j!=="EnumDeclaration")}function D(N,x,b){let L=N.getValue();if(!L.source)return "";let M=[];return F(L,x)||M.push(" from"),M.push(" ",b("source")),M}function g(N,x,b){let L=N.getValue();if(F(L,x))return "";let M=[" "];if(t(L.specifiers)){let j=[],$=[];N.each(()=>{let V=N.getValue().type;if(V==="ExportNamespaceSpecifier"||V==="ExportDefaultSpecifier"||V==="ImportNamespaceSpecifier"||V==="ImportDefaultSpecifier")j.push(b());else if(V==="ExportSpecifier"||V==="ImportSpecifier")$.push(b());else throw new Error("Unknown specifier type ".concat(JSON.stringify(V)))},"specifiers"),M.push(u(", ",j)),$.length>0&&(j.length>0&&M.push(", "),$.length>1||j.length>0||L.specifiers.some(q=>m(q))?M.push(a(["{",r([x.bracketSpacing?i:s,u([",",i],$)]),o(p(x)?",":""),x.bracketSpacing?i:s,"}"])):M.push(["{",x.bracketSpacing?" ":"",...$,x.bracketSpacing?" ":"","}"]));}else M.push("{}");return M}function F(N,x){let{type:b,importKind:L,source:M,specifiers:j}=N;return b!=="ImportDeclaration"||t(j)||L==="type"?!1:!/{\s*}/.test(x.originalText.slice(T(N),T(M)))}function l(N,x,b){let L=N.getNode();return t(L.assertions)?[" assert {",x.bracketSpacing?" ":"",u(", ",N.map(b,"assertions")),x.bracketSpacing?" ":"","}"]:""}function E(N,x,b){let L=N.getNode(),{type:M}=L,j=[],$=M==="ImportSpecifier"?L.importKind:L.exportKind;$&&$!=="value"&&j.push($," ");let V=M.startsWith("Import"),q=V?"imported":"local",Y=V?"local":"exported",H=L[q],R=L[Y],Q="",ee="";return M==="ExportNamespaceSpecifier"||M==="ImportNamespaceSpecifier"?Q="*":H&&(Q=b(q)),R&&!y(L)&&(ee=b(Y)),j.push(Q,Q&&ee?" as ":"",ee),j}function y(N){if(N.type!=="ImportSpecifier"&&N.type!=="ExportSpecifier")return !1;let{local:x,[N.type==="ImportSpecifier"?"imported":"exported"]:b}=N;if(x.type!==b.type||!A(x,b))return !1;if(h(x))return x.value===b.value&&w(x)===w(b);switch(x.type){case"Identifier":return x.name===b.name;default:return !1}}n.exports={printImportDeclaration:I,printExportDeclaration:k,printExportAllDeclaration:P,printModuleSpecifier:E};}}),zn=Z({"src/language-js/print/object.js"(e,n){re();var{printDanglingComments:t}=et(),{builders:{line:s,softline:a,group:r,indent:u,ifBreak:i,hardline:o}}=Oe(),{getLast:c,hasNewlineInRange:v,hasNewline:m,isNonEmptyArray:d}=Ue(),{shouldPrintComma:p,hasComment:f,getComments:h,CommentCheckFlags:w,isNextLineEmpty:T}=Ke(),{locStart:A,locEnd:S}=st(),{printOptionalToken:B,printTypeAnnotation:I}=ct(),{shouldHugFunctionParameters:k}=Pr(),{shouldHugType:P}=kr(),{printHardlineAfterHeritage:C}=Zt();function D(g,F,l){let E=F.semi?";":"",y=g.getValue(),N;y.type==="TSTypeLiteral"?N="members":y.type==="TSInterfaceBody"?N="body":N="properties";let x=y.type==="ObjectTypeAnnotation",b=[N];x&&b.push("indexers","callProperties","internalSlots");let L=b.map(W=>y[W][0]).sort((W,X)=>A(W)-A(X))[0],M=g.getParentNode(0),j=x&&M&&(M.type==="InterfaceDeclaration"||M.type==="DeclareInterface"||M.type==="DeclareClass")&&g.getName()==="body",$=y.type==="TSInterfaceBody"||j||y.type==="ObjectPattern"&&M.type!=="FunctionDeclaration"&&M.type!=="FunctionExpression"&&M.type!=="ArrowFunctionExpression"&&M.type!=="ObjectMethod"&&M.type!=="ClassMethod"&&M.type!=="ClassPrivateMethod"&&M.type!=="AssignmentPattern"&&M.type!=="CatchClause"&&y.properties.some(W=>W.value&&(W.value.type==="ObjectPattern"||W.value.type==="ArrayPattern"))||y.type!=="ObjectPattern"&&L&&v(F.originalText,A(y),A(L)),V=j?";":y.type==="TSInterfaceBody"||y.type==="TSTypeLiteral"?i(E,";"):",",q=y.type==="RecordExpression"?"#{":y.exact?"{|":"{",Y=y.exact?"|}":"}",H=[];for(let W of b)g.each(X=>{let ue=X.getValue();H.push({node:ue,printed:l(),loc:A(ue)});},W);b.length>1&&H.sort((W,X)=>W.loc-X.loc);let R=[],Q=H.map(W=>{let X=[...R,r(W.printed)];return R=[V,s],(W.node.type==="TSPropertySignature"||W.node.type==="TSMethodSignature"||W.node.type==="TSConstructSignatureDeclaration")&&f(W.node,w.PrettierIgnore)&&R.shift(),T(W.node,F)&&R.push(o),X});if(y.inexact){let W;if(f(y,w.Dangling)){let X=f(y,w.Line);W=[t(g,F,!0),X||m(F.originalText,S(c(h(y))))?o:s,"..."];}else W=["..."];Q.push([...R,...W]);}let ee=c(y[N]),te=!(y.inexact||ee&&ee.type==="RestElement"||ee&&(ee.type==="TSPropertySignature"||ee.type==="TSCallSignatureDeclaration"||ee.type==="TSMethodSignature"||ee.type==="TSConstructSignatureDeclaration")&&f(ee,w.PrettierIgnore)),oe;if(Q.length===0){if(!f(y,w.Dangling))return [q,Y,I(g,F,l)];oe=r([q,t(g,F),a,Y,B(g),I(g,F,l)]);}else oe=[j&&d(y.properties)?C(M):"",q,u([F.bracketSpacing?s:a,...Q]),i(te&&(V!==","||p(F))?V:""),F.bracketSpacing?s:a,Y,B(g),I(g,F,l)];return g.match(W=>W.type==="ObjectPattern"&&!W.decorators,(W,X,ue)=>k(W)&&(X==="params"||X==="parameters"||X==="this"||X==="rest")&&ue===0)||g.match(P,(W,X)=>X==="typeAnnotation",(W,X)=>X==="typeAnnotation",(W,X,ue)=>k(W)&&(X==="params"||X==="parameters"||X==="this"||X==="rest")&&ue===0)||!$&&g.match(W=>W.type==="ObjectPattern",W=>W.type==="AssignmentExpression"||W.type==="VariableDeclarator")?oe:r(oe,{shouldBreak:$})}n.exports={printObject:D};}}),Um=Z({"src/language-js/print/flow.js"(e,n){re();var t=Xt(),{printDanglingComments:s}=et(),{printString:a,printNumber:r}=Ue(),{builders:{hardline:u,softline:i,group:o,indent:c}}=Oe(),{getParentExportDeclaration:v,isFunctionNotation:m,isGetterOrSetter:d,rawText:p,shouldPrintComma:f}=Ke(),{locStart:h,locEnd:w}=st(),{printClass:T}=Zt(),{printOpaqueType:A,printTypeAlias:S,printIntersectionType:B,printUnionType:I,printFunctionType:k,printTupleType:P,printIndexedAccessType:C}=kr(),{printInterface:D}=lo(),{printTypeParameter:g,printTypeParameters:F}=Ir(),{printExportDeclaration:l,printExportAllDeclaration:E}=co(),{printArrayItems:y}=Kt(),{printObject:N}=zn(),{printPropertyKey:x}=Qt(),{printOptionalToken:b,printTypeAnnotation:L,printRestSpread:M}=ct();function j(V,q,Y){let H=V.getValue(),R=q.semi?";":"",Q=[];switch(H.type){case"DeclareClass":return $(V,T(V,q,Y));case"DeclareFunction":return $(V,["function ",Y("id"),H.predicate?" ":"",Y("predicate"),R]);case"DeclareModule":return $(V,["module ",Y("id")," ",Y("body")]);case"DeclareModuleExports":return $(V,["module.exports",": ",Y("typeAnnotation"),R]);case"DeclareVariable":return $(V,["var ",Y("id"),R]);case"DeclareOpaqueType":return $(V,A(V,q,Y));case"DeclareInterface":return $(V,D(V,q,Y));case"DeclareTypeAlias":return $(V,S(V,q,Y));case"DeclareExportDeclaration":return $(V,l(V,q,Y));case"DeclareExportAllDeclaration":return $(V,E(V,q,Y));case"OpaqueType":return A(V,q,Y);case"TypeAlias":return S(V,q,Y);case"IntersectionTypeAnnotation":return B(V,q,Y);case"UnionTypeAnnotation":return I(V,q,Y);case"FunctionTypeAnnotation":return k(V,q,Y);case"TupleTypeAnnotation":return P(V,q,Y);case"GenericTypeAnnotation":return [Y("id"),F(V,q,Y,"typeParameters")];case"IndexedAccessType":case"OptionalIndexedAccessType":return C(V,q,Y);case"TypeAnnotation":return Y("typeAnnotation");case"TypeParameter":return g(V,q,Y);case"TypeofTypeAnnotation":return ["typeof ",Y("argument")];case"ExistsTypeAnnotation":return "*";case"EmptyTypeAnnotation":return "empty";case"MixedTypeAnnotation":return "mixed";case"ArrayTypeAnnotation":return [Y("elementType"),"[]"];case"BooleanLiteralTypeAnnotation":return String(H.value);case"EnumDeclaration":return ["enum ",Y("id")," ",Y("body")];case"EnumBooleanBody":case"EnumNumberBody":case"EnumStringBody":case"EnumSymbolBody":{if(H.type==="EnumSymbolBody"||H.explicitType){let ee=null;switch(H.type){case"EnumBooleanBody":ee="boolean";break;case"EnumNumberBody":ee="number";break;case"EnumStringBody":ee="string";break;case"EnumSymbolBody":ee="symbol";break}Q.push("of ",ee," ");}if(H.members.length===0&&!H.hasUnknownMembers)Q.push(o(["{",s(V,q),i,"}"]));else {let ee=H.members.length>0?[u,y(V,q,"members",Y),H.hasUnknownMembers||f(q)?",":""]:[];Q.push(o(["{",c([...ee,...H.hasUnknownMembers?[u,"..."]:[]]),s(V,q,!0),u,"}"]));}return Q}case"EnumBooleanMember":case"EnumNumberMember":case"EnumStringMember":return [Y("id")," = ",typeof H.init=="object"?Y("init"):String(H.init)];case"EnumDefaultedMember":return Y("id");case"FunctionTypeParam":{let ee=H.name?Y("name"):V.getParentNode().this===H?"this":"";return [ee,b(V),ee?": ":"",Y("typeAnnotation")]}case"InterfaceDeclaration":case"InterfaceTypeAnnotation":return D(V,q,Y);case"ClassImplements":case"InterfaceExtends":return [Y("id"),Y("typeParameters")];case"NullableTypeAnnotation":return ["?",Y("typeAnnotation")];case"Variance":{let{kind:ee}=H;return t.ok(ee==="plus"||ee==="minus"),ee==="plus"?"+":"-"}case"ObjectTypeCallProperty":return H.static&&Q.push("static "),Q.push(Y("value")),Q;case"ObjectTypeIndexer":return [H.static?"static ":"",H.variance?Y("variance"):"","[",Y("id"),H.id?": ":"",Y("key"),"]: ",Y("value")];case"ObjectTypeProperty":{let ee="";return H.proto?ee="proto ":H.static&&(ee="static "),[ee,d(H)?H.kind+" ":"",H.variance?Y("variance"):"",x(V,q,Y),b(V),m(H)?"":": ",Y("value")]}case"ObjectTypeAnnotation":return N(V,q,Y);case"ObjectTypeInternalSlot":return [H.static?"static ":"","[[",Y("id"),"]]",b(V),H.method?"":": ",Y("value")];case"ObjectTypeSpreadProperty":return M(V,q,Y);case"QualifiedTypeofIdentifier":case"QualifiedTypeIdentifier":return [Y("qualification"),".",Y("id")];case"StringLiteralTypeAnnotation":return a(p(H),q);case"NumberLiteralTypeAnnotation":t.strictEqual(typeof H.value,"number");case"BigIntLiteralTypeAnnotation":return H.extra?r(H.extra.raw):r(H.raw);case"TypeCastExpression":return ["(",Y("expression"),L(V,q,Y),")"];case"TypeParameterDeclaration":case"TypeParameterInstantiation":{let ee=F(V,q,Y,"params");if(q.parser==="flow"){let te=h(H),oe=w(H),W=q.originalText.lastIndexOf("/*",te),X=q.originalText.indexOf("*/",oe);if(W!==-1&&X!==-1){let ue=q.originalText.slice(W+2,X).trim();if(ue.startsWith("::")&&!ue.includes("/*")&&!ue.includes("*/"))return ["/*:: ",ee," */"]}}return ee}case"InferredPredicate":return "%checks";case"DeclaredPredicate":return ["%checks(",Y("value"),")"];case"AnyTypeAnnotation":return "any";case"BooleanTypeAnnotation":return "boolean";case"BigIntTypeAnnotation":return "bigint";case"NullLiteralTypeAnnotation":return "null";case"NumberTypeAnnotation":return "number";case"SymbolTypeAnnotation":return "symbol";case"StringTypeAnnotation":return "string";case"VoidTypeAnnotation":return "void";case"ThisTypeAnnotation":return "this";case"Node":case"Printable":case"SourceLocation":case"Position":case"Statement":case"Function":case"Pattern":case"Expression":case"Declaration":case"Specifier":case"NamedSpecifier":case"Comment":case"MemberTypeAnnotation":case"Type":throw new Error("unprintable type: "+JSON.stringify(H.type))}}function $(V,q){let Y=v(V);return Y?(t.strictEqual(Y.type,"DeclareExportDeclaration"),q):["declare ",q]}n.exports={printFlow:j};}}),zm=Z({"src/language-js/utils/is-ts-keyword-type.js"(e,n){re();function t(s){let{type:a}=s;return a.startsWith("TS")&&a.endsWith("Keyword")}n.exports=t;}}),po=Z({"src/language-js/print/ternary.js"(e,n){re();var{hasNewlineInRange:t}=Ue(),{isJsxNode:s,getComments:a,isCallExpression:r,isMemberExpression:u}=Ke(),{locStart:i,locEnd:o}=st(),c=It(),{builders:{line:v,softline:m,group:d,indent:p,align:f,ifBreak:h,dedent:w,breakParent:T}}=Oe();function A(P){let C=[P];for(let D=0;D<C.length;D++){let g=C[D];for(let F of ["test","consequent","alternate"]){let l=g[F];if(s(l))return !0;l.type==="ConditionalExpression"&&C.push(l);}}return !1}function S(P,C,D){let g=P.getValue(),F=g.type==="ConditionalExpression",l=F?"alternate":"falseType",E=P.getParentNode(),y=F?D("test"):[D("checkType")," ","extends"," ",D("extendsType")];return E.type===g.type&&E[l]===g?f(2,y):y}var B=new Map([["AssignmentExpression","right"],["VariableDeclarator","init"],["ReturnStatement","argument"],["ThrowStatement","argument"],["UnaryExpression","argument"],["YieldExpression","argument"]]);function I(P){let C=P.getValue();if(C.type!=="ConditionalExpression")return !1;let D,g=C;for(let F=0;!D;F++){let l=P.getParentNode(F);if(r(l)&&l.callee===g||u(l)&&l.object===g||l.type==="TSNonNullExpression"&&l.expression===g){g=l;continue}l.type==="NewExpression"&&l.callee===g||l.type==="TSAsExpression"&&l.expression===g?(D=P.getParentNode(F+1),g=l):D=l;}return g===C?!1:D[B.get(D.type)]===g}function k(P,C,D){let g=P.getValue(),F=g.type==="ConditionalExpression",l=F?"consequent":"trueType",E=F?"alternate":"falseType",y=F?["test"]:["checkType","extendsType"],N=g[l],x=g[E],b=[],L=!1,M=P.getParentNode(),j=M.type===g.type&&y.some(ue=>M[ue]===g),$=M.type===g.type&&!j,V,q,Y=0;do q=V||g,V=P.getParentNode(Y),Y++;while(V&&V.type===g.type&&y.every(ue=>V[ue]!==q));let H=V||M,R=q;if(F&&(s(g[y[0]])||s(N)||s(x)||A(R))){L=!0,$=!0;let ue=ie=>[h("("),p([m,ie]),m,h(")")],De=ie=>ie.type==="NullLiteral"||ie.type==="Literal"&&ie.value===null||ie.type==="Identifier"&&ie.name==="undefined";b.push(" ? ",De(N)?D(l):ue(D(l))," : ",x.type===g.type||De(x)?D(E):ue(D(E)));}else {let ue=[v,"? ",N.type===g.type?h("","("):"",f(2,D(l)),N.type===g.type?h("",")"):"",v,": ",x.type===g.type?D(E):f(2,D(E))];b.push(M.type!==g.type||M[E]===g||j?ue:C.useTabs?w(p(ue)):f(Math.max(0,C.tabWidth-2),ue));}let ee=[...y.map(ue=>a(g[ue])),a(N),a(x)].flat().some(ue=>c(ue)&&t(C.originalText,i(ue),o(ue))),te=ue=>M===H?d(ue,{shouldBreak:ee}):ee?[ue,T]:ue,oe=!L&&(u(M)||M.type==="NGPipeExpression"&&M.left===g)&&!M.computed,W=I(P),X=te([S(P,C,D),$?b:p(b),F&&oe&&!W?m:""]);return j||W?d([p([m,X]),m]):X}n.exports={printTernary:k};}}),fo=Z({"src/language-js/print/statement.js"(e,n){re();var{builders:{hardline:t}}=Oe(),s=jt(),{getLeftSidePathName:a,hasNakedLeftSide:r,isJsxNode:u,isTheOnlyJsxElementInMarkdown:i,hasComment:o,CommentCheckFlags:c,isNextLineEmpty:v}=Ke(),{shouldPrintParamsWithoutParens:m}=Lr();function d(B,I,k,P){let C=B.getValue(),D=[],g=C.type==="ClassBody",F=p(C[P]);return B.each((l,E,y)=>{let N=l.getValue();if(N.type==="EmptyStatement")return;let x=k();!I.semi&&!g&&!i(I,l)&&f(l,I)?o(N,c.Leading)?D.push(k([],{needsSemi:!0})):D.push(";",x):D.push(x),!I.semi&&g&&A(N)&&S(N,y[E+1])&&D.push(";"),N!==F&&(D.push(t),v(N,I)&&D.push(t));},P),D}function p(B){for(let I=B.length-1;I>=0;I--){let k=B[I];if(k.type!=="EmptyStatement")return k}}function f(B,I){return B.getNode().type!=="ExpressionStatement"?!1:B.call(P=>h(P,I),"expression")}function h(B,I){let k=B.getValue();switch(k.type){case"ParenthesizedExpression":case"TypeCastExpression":case"ArrayExpression":case"ArrayPattern":case"TemplateLiteral":case"TemplateElement":case"RegExpLiteral":return !0;case"ArrowFunctionExpression":{if(!m(B,I))return !0;break}case"UnaryExpression":{let{prefix:P,operator:C}=k;if(P&&(C==="+"||C==="-"))return !0;break}case"BindExpression":{if(!k.object)return !0;break}case"Literal":{if(k.regex)return !0;break}default:if(u(k))return !0}return s(B,I)?!0:r(k)?B.call(P=>h(P,I),...a(B,k)):!1}function w(B,I,k){return d(B,I,k,"body")}function T(B,I,k){return d(B,I,k,"consequent")}var A=B=>{let{type:I}=B;return I==="ClassProperty"||I==="PropertyDefinition"||I==="ClassPrivateProperty"||I==="ClassAccessorProperty"};function S(B,I){let k=B.key&&B.key.name;if((k==="static"||k==="get"||k==="set")&&!B.value&&!B.typeAnnotation)return !0;if(!I||I.static||I.accessibility)return !1;if(!I.computed){let P=I.key&&I.key.name;if(P==="in"||P==="instanceof")return !0}if(A(I)&&I.variance&&!I.static&&!I.declare)return !0;switch(I.type){case"ClassProperty":case"PropertyDefinition":case"TSAbstractPropertyDefinition":return I.computed;case"MethodDefinition":case"TSAbstractMethodDefinition":case"ClassMethod":case"ClassPrivateMethod":{if((I.value?I.value.async:I.async)||I.kind==="get"||I.kind==="set")return !1;let C=I.value?I.value.generator:I.generator;return !!(I.computed||C)}case"TSIndexSignature":return !0}return !1}n.exports={printBody:w,printSwitchCaseConsequent:T};}}),Do=Z({"src/language-js/print/block.js"(e,n){re();var{printDanglingComments:t}=et(),{isNonEmptyArray:s}=Ue(),{builders:{hardline:a,indent:r}}=Oe(),{hasComment:u,CommentCheckFlags:i,isNextLineEmpty:o}=Ke(),{printHardlineAfterHeritage:c}=Zt(),{printBody:v}=fo();function m(p,f,h){let w=p.getValue(),T=[];if(w.type==="StaticBlock"&&T.push("static "),w.type==="ClassBody"&&s(w.body)){let S=p.getParentNode();T.push(c(S));}T.push("{");let A=d(p,f,h);if(A)T.push(r([a,A]),a);else {let S=p.getParentNode(),B=p.getParentNode(1);S.type==="ArrowFunctionExpression"||S.type==="FunctionExpression"||S.type==="FunctionDeclaration"||S.type==="ObjectMethod"||S.type==="ClassMethod"||S.type==="ClassPrivateMethod"||S.type==="ForStatement"||S.type==="WhileStatement"||S.type==="DoWhileStatement"||S.type==="DoExpression"||S.type==="CatchClause"&&!B.finalizer||S.type==="TSModuleDeclaration"||S.type==="TSDeclareFunction"||w.type==="StaticBlock"||w.type==="ClassBody"||T.push(a);}return T.push("}"),T}function d(p,f,h){let w=p.getValue(),T=s(w.directives),A=w.body.some(I=>I.type!=="EmptyStatement"),S=u(w,i.Dangling);if(!T&&!A&&!S)return "";let B=[];if(T&&p.each((I,k,P)=>{B.push(h()),(k<P.length-1||A||S)&&(B.push(a),o(I.getValue(),f)&&B.push(a));},"directives"),A&&B.push(v(p,f,h)),S&&B.push(t(p,f,!0)),w.type==="Program"){let I=p.getParentNode();(!I||I.type!=="ModuleExpression")&&B.push(a);}return B}n.exports={printBlock:m,printBlockBody:d};}}),Xm=Z({"src/language-js/print/typescript.js"(e,n){re();var{printDanglingComments:t}=et(),{hasNewlineInRange:s}=Ue(),{builders:{join:a,line:r,hardline:u,softline:i,group:o,indent:c,conditionalGroup:v,ifBreak:m}}=Oe(),{isLiteral:d,getTypeScriptMappedTypeModifier:p,shouldPrintComma:f,isCallExpression:h,isMemberExpression:w}=Ke(),T=zm(),{locStart:A,locEnd:S}=st(),{printOptionalToken:B,printTypeScriptModifiers:I}=ct(),{printTernary:k}=po(),{printFunctionParameters:P,shouldGroupFunctionParameters:C}=Pr(),{printTemplateLiteral:D}=Lt(),{printArrayItems:g}=Kt(),{printObject:F}=zn(),{printClassProperty:l,printClassMethod:E}=Zt(),{printTypeParameter:y,printTypeParameters:N}=Ir(),{printPropertyKey:x}=Qt(),{printFunction:b,printMethodInternal:L}=Lr(),{printInterface:M}=lo(),{printBlock:j}=Do(),{printTypeAlias:$,printIntersectionType:V,printUnionType:q,printFunctionType:Y,printTupleType:H,printIndexedAccessType:R,printJSDocType:Q}=kr();function ee(te,oe,W){let X=te.getValue();if(!X.type.startsWith("TS"))return;if(T(X))return X.type.slice(2,-7).toLowerCase();let ue=oe.semi?";":"",De=[];switch(X.type){case"TSThisType":return "this";case"TSTypeAssertion":{let ie=!(X.expression.type==="ArrayExpression"||X.expression.type==="ObjectExpression"),G=o(["<",c([i,W("typeAnnotation")]),i,">"]),z=[m("("),c([i,W("expression")]),i,m(")")];return ie?v([[G,W("expression")],[G,o(z,{shouldBreak:!0})],[G,W("expression")]]):o([G,W("expression")])}case"TSDeclareFunction":return b(te,W,oe);case"TSExportAssignment":return ["export = ",W("expression"),ue];case"TSModuleBlock":return j(te,oe,W);case"TSInterfaceBody":case"TSTypeLiteral":return F(te,oe,W);case"TSTypeAliasDeclaration":return $(te,oe,W);case"TSQualifiedName":return a(".",[W("left"),W("right")]);case"TSAbstractMethodDefinition":case"TSDeclareMethod":return E(te,oe,W);case"TSAbstractPropertyDefinition":return l(te,oe,W);case"TSInterfaceHeritage":case"TSExpressionWithTypeArguments":return De.push(W("expression")),X.typeParameters&&De.push(W("typeParameters")),De;case"TSTemplateLiteralType":return D(te,W,oe);case"TSNamedTupleMember":return [W("label"),X.optional?"?":"",": ",W("elementType")];case"TSRestType":return ["...",W("typeAnnotation")];case"TSOptionalType":return [W("typeAnnotation"),"?"];case"TSInterfaceDeclaration":return M(te,oe,W);case"TSClassImplements":return [W("expression"),W("typeParameters")];case"TSTypeParameterDeclaration":case"TSTypeParameterInstantiation":return N(te,oe,W,"params");case"TSTypeParameter":return y(te,oe,W);case"TSAsExpression":{De.push(W("expression")," as ",W("typeAnnotation"));let ie=te.getParentNode();return h(ie)&&ie.callee===X||w(ie)&&ie.object===X?o([c([i,...De]),i]):De}case"TSArrayType":return [W("elementType"),"[]"];case"TSPropertySignature":return X.readonly&&De.push("readonly "),De.push(x(te,oe,W),B(te)),X.typeAnnotation&&De.push(": ",W("typeAnnotation")),X.initializer&&De.push(" = ",W("initializer")),De;case"TSParameterProperty":return X.accessibility&&De.push(X.accessibility+" "),X.export&&De.push("export "),X.static&&De.push("static "),X.override&&De.push("override "),X.readonly&&De.push("readonly "),De.push(W("parameter")),De;case"TSTypeQuery":return ["typeof ",W("exprName"),W("typeParameters")];case"TSIndexSignature":{let ie=te.getParentNode(),G=X.parameters.length>1?m(f(oe)?",":""):"",z=o([c([i,a([", ",i],te.map(W,"parameters"))]),G,i]);return [X.export?"export ":"",X.accessibility?[X.accessibility," "]:"",X.static?"static ":"",X.readonly?"readonly ":"",X.declare?"declare ":"","[",X.parameters?z:"",X.typeAnnotation?"]: ":"]",X.typeAnnotation?W("typeAnnotation"):"",ie.type==="ClassBody"?ue:""]}case"TSTypePredicate":return [X.asserts?"asserts ":"",W("parameterName"),X.typeAnnotation?[" is ",W("typeAnnotation")]:""];case"TSNonNullExpression":return [W("expression"),"!"];case"TSImportType":return [X.isTypeOf?"typeof ":"","import(",W(X.parameter?"parameter":"argument"),")",X.qualifier?[".",W("qualifier")]:"",N(te,oe,W,"typeParameters")];case"TSLiteralType":return W("literal");case"TSIndexedAccessType":return R(te,oe,W);case"TSConstructSignatureDeclaration":case"TSCallSignatureDeclaration":case"TSConstructorType":{if(X.type==="TSConstructorType"&&X.abstract&&De.push("abstract "),X.type!=="TSCallSignatureDeclaration"&&De.push("new "),De.push(o(P(te,W,oe,!1,!0))),X.returnType||X.typeAnnotation){let ie=X.type==="TSConstructorType";De.push(ie?" => ":": ",W("returnType"),W("typeAnnotation"));}return De}case"TSTypeOperator":return [X.operator," ",W("typeAnnotation")];case"TSMappedType":{let ie=s(oe.originalText,A(X),S(X));return o(["{",c([oe.bracketSpacing?r:i,X.readonly?[p(X.readonly,"readonly")," "]:"",I(te,oe,W),W("typeParameter"),X.optional?p(X.optional,"?"):"",X.typeAnnotation?": ":"",W("typeAnnotation"),m(ue)]),t(te,oe,!0),oe.bracketSpacing?r:i,"}"],{shouldBreak:ie})}case"TSMethodSignature":{let ie=X.kind&&X.kind!=="method"?"".concat(X.kind," "):"";De.push(X.accessibility?[X.accessibility," "]:"",ie,X.export?"export ":"",X.static?"static ":"",X.readonly?"readonly ":"",X.abstract?"abstract ":"",X.declare?"declare ":"",X.computed?"[":"",W("key"),X.computed?"]":"",B(te));let G=P(te,W,oe,!1,!0),z=X.returnType?"returnType":"typeAnnotation",U=X[z],le=U?W(z):"",ge=C(X,le);return De.push(ge?o(G):G),U&&De.push(": ",o(le)),o(De)}case"TSNamespaceExportDeclaration":return De.push("export as namespace ",W("id")),oe.semi&&De.push(";"),o(De);case"TSEnumDeclaration":return X.declare&&De.push("declare "),X.modifiers&&De.push(I(te,oe,W)),X.const&&De.push("const "),De.push("enum ",W("id")," "),X.members.length===0?De.push(o(["{",t(te,oe),i,"}"])):De.push(o(["{",c([u,g(te,oe,"members",W),f(oe,"es5")?",":""]),t(te,oe,!0),u,"}"])),De;case"TSEnumMember":return X.computed?De.push("[",W("id"),"]"):De.push(W("id")),X.initializer&&De.push(" = ",W("initializer")),De;case"TSImportEqualsDeclaration":return X.isExport&&De.push("export "),De.push("import "),X.importKind&&X.importKind!=="value"&&De.push(X.importKind," "),De.push(W("id")," = ",W("moduleReference")),oe.semi&&De.push(";"),o(De);case"TSExternalModuleReference":return ["require(",W("expression"),")"];case"TSModuleDeclaration":{let ie=te.getParentNode(),G=d(X.id),z=ie.type==="TSModuleDeclaration",U=X.body&&X.body.type==="TSModuleDeclaration";if(z)De.push(".");else {X.declare&&De.push("declare "),De.push(I(te,oe,W));let le=oe.originalText.slice(A(X),A(X.id));X.id.type==="Identifier"&&X.id.name==="global"&&!/namespace|module/.test(le)||De.push(G||/(?:^|\s)module(?:\s|$)/.test(le)?"module ":"namespace ");}return De.push(W("id")),U?De.push(W("body")):X.body?De.push(" ",o(W("body"))):De.push(ue),De}case"TSConditionalType":return k(te,oe,W);case"TSInferType":return ["infer"," ",W("typeParameter")];case"TSIntersectionType":return V(te,oe,W);case"TSUnionType":return q(te,oe,W);case"TSFunctionType":return Y(te,oe,W);case"TSTupleType":return H(te,oe,W);case"TSTypeReference":return [W("typeName"),N(te,oe,W,"typeParameters")];case"TSTypeAnnotation":return W("typeAnnotation");case"TSEmptyBodyFunctionExpression":return L(te,oe,W);case"TSJSDocAllType":return "*";case"TSJSDocUnknownType":return "?";case"TSJSDocNullableType":return Q(te,W,"?");case"TSJSDocNonNullableType":return Q(te,W,"!");case"TSInstantiationExpression":return [W("expression"),W("typeParameters")];default:throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(X.type),"."))}}n.exports={printTypescript:ee};}}),Km=Z({"src/language-js/print/comment.js"(e,n){re();var{hasNewline:t}=Ue(),{builders:{join:s,hardline:a},utils:{replaceTextEndOfLine:r}}=Oe(),{isLineComment:u}=Ke(),{locStart:i,locEnd:o}=st(),c=It();function v(p,f){let h=p.getValue();if(u(h))return f.originalText.slice(i(h),o(h)).trimEnd();if(c(h)){if(m(h)){let A=d(h);return h.trailing&&!t(f.originalText,i(h),{backwards:!0})?[a,A]:A}let w=o(h),T=f.originalText.slice(w-3,w)==="*-/";return ["/*",r(h.value),T?"*-/":"*/"]}throw new Error("Not a comment: "+JSON.stringify(h))}function m(p){let f="*".concat(p.value,"*").split(`
	`);return f.length>1&&f.every(h=>h.trim()[0]==="*")}function d(p){let f=p.value.split(`
	`);return ["/*",s(a,f.map((h,w)=>w===0?h.trimEnd():" "+(w<f.length-1?h.trim():h.trimStart()))),"*/"]}n.exports={printComment:v};}}),Ym=Z({"src/language-js/print/literal.js"(e,n){re();var{printString:t,printNumber:s}=Ue();function a(i,o){let c=i.getNode();switch(c.type){case"RegExpLiteral":return u(c);case"BigIntLiteral":return r(c.bigint||c.extra.raw);case"NumericLiteral":return s(c.extra.raw);case"StringLiteral":return t(c.extra.raw,o);case"NullLiteral":return "null";case"BooleanLiteral":return String(c.value);case"DecimalLiteral":return s(c.value)+"m";case"Literal":{if(c.regex)return u(c.regex);if(c.bigint)return r(c.raw);if(c.decimal)return s(c.decimal)+"m";let{value:v}=c;return typeof v=="number"?s(c.raw):typeof v=="string"?t(c.raw,o):String(v)}}}function r(i){return i.toLowerCase()}function u(i){let{pattern:o,flags:c}=i;return c=[...c].sort().join(""),"/".concat(o,"/").concat(c)}n.exports={printLiteral:a};}}),Qm=Z({"src/language-js/printer-estree.js"(e,n){re();var{printDanglingComments:t}=et(),{hasNewline:s}=Ue(),{builders:{join:a,line:r,hardline:u,softline:i,group:o,indent:c},utils:{replaceTextEndOfLine:v}}=Oe(),m=Im(),d=Lm(),{insertPragma:p}=no(),f=uo(),h=jt(),w=so(),{hasFlowShorthandAnnotationComment:T,hasComment:A,CommentCheckFlags:S,isTheOnlyJsxElementInMarkdown:B,isLineComment:I,isNextLineEmpty:k,needsHardlineAfterDanglingComment:P,rawText:C,hasIgnoreComment:D,isCallExpression:g,isMemberExpression:F,markerForIfWithoutBlockAndSameLineComment:l}=Ke(),{locStart:E,locEnd:y}=st(),N=It(),{printHtmlBinding:x,isVueEventBindingExpression:b}=$m(),{printAngular:L}=Hm(),{printJsx:M,hasJsxIgnoreComment:j}=Gm(),{printFlow:$}=Um(),{printTypescript:V}=Xm(),{printOptionalToken:q,printBindExpressionCallee:Y,printTypeAnnotation:H,adjustClause:R,printRestSpread:Q,printDefiniteToken:ee}=ct(),{printImportDeclaration:te,printExportDeclaration:oe,printExportAllDeclaration:W,printModuleSpecifier:X}=co(),{printTernary:ue}=po(),{printTemplateLiteral:De}=Lt(),{printArray:ie}=Kt(),{printObject:G}=zn(),{printClass:z,printClassMethod:U,printClassProperty:le}=Zt(),{printProperty:ge}=Qt(),{printFunction:Ae,printArrowFunction:Ne,printMethod:ke,printReturnStatement:ce,printThrowStatement:pe}=Lr(),{printCallExpression:de}=oo(),{printVariableDeclarator:ae,printAssignmentExpression:ve}=Yt(),{printBinaryishExpression:K}=Jn(),{printSwitchCaseConsequent:he}=fo(),{printMemberExpression:ye}=ao(),{printBlock:Ce,printBlockBody:Ie}=Do(),{printComment:Fe}=Km(),{printLiteral:me}=Ym(),{printDecorators:_}=Un();function J(Be,Pe,Se,Qe){let xe=ne(Be,Pe,Se,Qe);if(!xe)return "";let Xe=Be.getValue(),{type:_e}=Xe;if(_e==="ClassMethod"||_e==="ClassPrivateMethod"||_e==="ClassProperty"||_e==="ClassAccessorProperty"||_e==="PropertyDefinition"||_e==="TSAbstractPropertyDefinition"||_e==="ClassPrivateProperty"||_e==="MethodDefinition"||_e==="TSAbstractMethodDefinition"||_e==="TSDeclareMethod")return xe;let je=[xe],Re=_(Be,Pe,Se),be=Xe.type==="ClassExpression"&&Re;if(Re&&(je=[...Re,xe],!be))return o(je);if(!h(Be,Pe))return Qe&&Qe.needsSemi&&je.unshift(";"),je.length===1&&je[0]===xe?xe:je;if(be&&(je=[c([r,...je])]),je.unshift("("),Qe&&Qe.needsSemi&&je.unshift(";"),T(Xe)){let[qe]=Xe.trailingComments;je.push(" /*",qe.value.trimStart(),"*/"),qe.printed=!0;}return be&&je.push(r),je.push(")"),je}function ne(Be,Pe,Se,Qe){let xe=Be.getValue(),Xe=Pe.semi?";":"";if(!xe)return "";if(typeof xe=="string")return xe;for(let je of [me,x,L,M,$,V]){let Re=je(Be,Pe,Se);if(typeof Re<"u")return Re}let _e=[];switch(xe.type){case"JsExpressionRoot":return Se("node");case"JsonRoot":return [Se("node"),u];case"File":return xe.program&&xe.program.interpreter&&_e.push(Se(["program","interpreter"])),_e.push(Se("program")),_e;case"Program":return Ie(Be,Pe,Se);case"EmptyStatement":return "";case"ExpressionStatement":{if(xe.directive)return [Ee(xe.expression,Pe),Xe];if(Pe.parser==="__vue_event_binding"||Pe.parser==="__vue_ts_event_binding"){let Re=Be.getParentNode();if(Re.type==="Program"&&Re.body.length===1&&Re.body[0]===xe)return [Se("expression"),b(xe.expression)?";":""]}let je=t(Be,Pe,!0,Re=>{let{marker:be}=Re;return be===l});return [Se("expression"),B(Pe,Be)?"":Xe,je?[" ",je]:""]}case"ParenthesizedExpression":return !A(xe.expression)&&(xe.expression.type==="ObjectExpression"||xe.expression.type==="ArrayExpression")?["(",Se("expression"),")"]:o(["(",c([i,Se("expression")]),i,")"]);case"AssignmentExpression":return ve(Be,Pe,Se);case"VariableDeclarator":return ae(Be,Pe,Se);case"BinaryExpression":case"LogicalExpression":return K(Be,Pe,Se);case"AssignmentPattern":return [Se("left")," = ",Se("right")];case"OptionalMemberExpression":case"MemberExpression":return ye(Be,Pe,Se);case"MetaProperty":return [Se("meta"),".",Se("property")];case"BindExpression":return xe.object&&_e.push(Se("object")),_e.push(o(c([i,Y(Be,Pe,Se)]))),_e;case"Identifier":return [xe.name,q(Be),ee(Be),H(Be,Pe,Se)];case"V8IntrinsicIdentifier":return ["%",xe.name];case"SpreadElement":case"SpreadElementPattern":case"SpreadProperty":case"SpreadPropertyPattern":case"RestElement":return Q(Be,Pe,Se);case"FunctionDeclaration":case"FunctionExpression":return Ae(Be,Se,Pe,Qe);case"ArrowFunctionExpression":return Ne(Be,Pe,Se,Qe);case"YieldExpression":return _e.push("yield"),xe.delegate&&_e.push("*"),xe.argument&&_e.push(" ",Se("argument")),_e;case"AwaitExpression":{if(_e.push("await"),xe.argument){_e.push(" ",Se("argument"));let je=Be.getParentNode();if(g(je)&&je.callee===xe||F(je)&&je.object===xe){_e=[c([i,..._e]),i];let Re=Be.findAncestor(be=>be.type==="AwaitExpression"||be.type==="BlockStatement");if(!Re||Re.type!=="AwaitExpression")return o(_e)}}return _e}case"ExportDefaultDeclaration":case"ExportNamedDeclaration":return oe(Be,Pe,Se);case"ExportAllDeclaration":return W(Be,Pe,Se);case"ImportDeclaration":return te(Be,Pe,Se);case"ImportSpecifier":case"ExportSpecifier":case"ImportNamespaceSpecifier":case"ExportNamespaceSpecifier":case"ImportDefaultSpecifier":case"ExportDefaultSpecifier":return X(Be,Pe,Se);case"ImportAttribute":return [Se("key"),": ",Se("value")];case"Import":return "import";case"BlockStatement":case"StaticBlock":case"ClassBody":return Ce(Be,Pe,Se);case"ThrowStatement":return pe(Be,Pe,Se);case"ReturnStatement":return ce(Be,Pe,Se);case"NewExpression":case"ImportExpression":case"OptionalCallExpression":case"CallExpression":return de(Be,Pe,Se);case"ObjectExpression":case"ObjectPattern":case"RecordExpression":return G(Be,Pe,Se);case"ObjectProperty":case"Property":return xe.method||xe.kind==="get"||xe.kind==="set"?ke(Be,Pe,Se):ge(Be,Pe,Se);case"ObjectMethod":return ke(Be,Pe,Se);case"Decorator":return ["@",Se("expression")];case"ArrayExpression":case"ArrayPattern":case"TupleExpression":return ie(Be,Pe,Se);case"SequenceExpression":{let je=Be.getParentNode(0);if(je.type==="ExpressionStatement"||je.type==="ForStatement"){let Re=[];return Be.each((be,Le)=>{Le===0?Re.push(Se()):Re.push(",",c([r,Se()]));},"expressions"),o(Re)}return o(a([",",r],Be.map(Se,"expressions")))}case"ThisExpression":return "this";case"Super":return "super";case"Directive":return [Se("value"),Xe];case"DirectiveLiteral":return Ee(xe,Pe);case"UnaryExpression":return _e.push(xe.operator),/[a-z]$/.test(xe.operator)&&_e.push(" "),A(xe.argument)?_e.push(o(["(",c([i,Se("argument")]),i,")"])):_e.push(Se("argument")),_e;case"UpdateExpression":return _e.push(Se("argument"),xe.operator),xe.prefix&&_e.reverse(),_e;case"ConditionalExpression":return ue(Be,Pe,Se);case"VariableDeclaration":{let je=Be.map(Se,"declarations"),Re=Be.getParentNode(),be=Re.type==="ForStatement"||Re.type==="ForInStatement"||Re.type==="ForOfStatement",Le=xe.declarations.some(se=>se.init),qe;return je.length===1&&!A(xe.declarations[0])?qe=je[0]:je.length>0&&(qe=c(je[0])),_e=[xe.declare?"declare ":"",xe.kind,qe?[" ",qe]:"",c(je.slice(1).map(se=>[",",Le&&!be?u:r,se]))],be&&Re.body!==xe||_e.push(Xe),o(_e)}case"WithStatement":return o(["with (",Se("object"),")",R(xe.body,Se("body"))]);case"IfStatement":{let je=R(xe.consequent,Se("consequent")),Re=o(["if (",o([c([i,Se("test")]),i]),")",je]);if(_e.push(Re),xe.alternate){let be=A(xe.consequent,S.Trailing|S.Line)||P(xe),Le=xe.consequent.type==="BlockStatement"&&!be;_e.push(Le?" ":u),A(xe,S.Dangling)&&_e.push(t(Be,Pe,!0),be?u:" "),_e.push("else",o(R(xe.alternate,Se("alternate"),xe.alternate.type==="IfStatement")));}return _e}case"ForStatement":{let je=R(xe.body,Se("body")),Re=t(Be,Pe,!0),be=Re?[Re,i]:"";return !xe.init&&!xe.test&&!xe.update?[be,o(["for (;;)",je])]:[be,o(["for (",o([c([i,Se("init"),";",r,Se("test"),";",r,Se("update")]),i]),")",je])]}case"WhileStatement":return o(["while (",o([c([i,Se("test")]),i]),")",R(xe.body,Se("body"))]);case"ForInStatement":return o(["for (",Se("left")," in ",Se("right"),")",R(xe.body,Se("body"))]);case"ForOfStatement":return o(["for",xe.await?" await":""," (",Se("left")," of ",Se("right"),")",R(xe.body,Se("body"))]);case"DoWhileStatement":{let je=R(xe.body,Se("body"));return _e=[o(["do",je])],xe.body.type==="BlockStatement"?_e.push(" "):_e.push(u),_e.push("while (",o([c([i,Se("test")]),i]),")",Xe),_e}case"DoExpression":return [xe.async?"async ":"","do ",Se("body")];case"BreakStatement":return _e.push("break"),xe.label&&_e.push(" ",Se("label")),_e.push(Xe),_e;case"ContinueStatement":return _e.push("continue"),xe.label&&_e.push(" ",Se("label")),_e.push(Xe),_e;case"LabeledStatement":return xe.body.type==="EmptyStatement"?[Se("label"),":;"]:[Se("label"),": ",Se("body")];case"TryStatement":return ["try ",Se("block"),xe.handler?[" ",Se("handler")]:"",xe.finalizer?[" finally ",Se("finalizer")]:""];case"CatchClause":if(xe.param){let je=A(xe.param,be=>!N(be)||be.leading&&s(Pe.originalText,y(be))||be.trailing&&s(Pe.originalText,E(be),{backwards:!0})),Re=Se("param");return ["catch ",je?["(",c([i,Re]),i,") "]:["(",Re,") "],Se("body")]}return ["catch ",Se("body")];case"SwitchStatement":return [o(["switch (",c([i,Se("discriminant")]),i,")"])," {",xe.cases.length>0?c([u,a(u,Be.map((je,Re,be)=>{let Le=je.getValue();return [Se(),Re!==be.length-1&&k(Le,Pe)?u:""]},"cases"))]):"",u,"}"];case"SwitchCase":{xe.test?_e.push("case ",Se("test"),":"):_e.push("default:"),A(xe,S.Dangling)&&_e.push(" ",t(Be,Pe,!0));let je=xe.consequent.filter(Re=>Re.type!=="EmptyStatement");if(je.length>0){let Re=he(Be,Pe,Se);_e.push(je.length===1&&je[0].type==="BlockStatement"?[" ",Re]:c([u,Re]));}return _e}case"DebuggerStatement":return ["debugger",Xe];case"ClassDeclaration":case"ClassExpression":return z(Be,Pe,Se);case"ClassMethod":case"ClassPrivateMethod":case"MethodDefinition":return U(Be,Pe,Se);case"ClassProperty":case"PropertyDefinition":case"ClassPrivateProperty":case"ClassAccessorProperty":return le(Be,Pe,Se);case"TemplateElement":return v(xe.value.raw);case"TemplateLiteral":return De(Be,Se,Pe);case"TaggedTemplateExpression":return [Se("tag"),Se("typeParameters"),Se("quasi")];case"PrivateIdentifier":return ["#",Se("name")];case"PrivateName":return ["#",Se("id")];case"InterpreterDirective":return _e.push("#!",xe.value,u),k(xe,Pe)&&_e.push(u),_e;case"TopicReference":return "%";case"ArgumentPlaceholder":return "?";case"ModuleExpression":{_e.push("module {");let je=Se("body");return je&&_e.push(c([u,je]),u),_e.push("}"),_e}default:throw new Error("unknown type: "+JSON.stringify(xe.type))}}function Ee(Be,Pe){let Se=C(Be),Qe=Se.slice(1,-1);if(Qe.includes('"')||Qe.includes("'"))return Se;let xe=Pe.singleQuote?"'":'"';return xe+Qe+xe}function We(Be){return Be.type&&!N(Be)&&!I(Be)&&Be.type!=="EmptyStatement"&&Be.type!=="TemplateElement"&&Be.type!=="Import"&&Be.type!=="TSEmptyBodyFunctionExpression"}n.exports={preprocess:w,print:J,embed:m,insertPragma:p,massageAstNode:d,hasPrettierIgnore(Be){return D(Be)||j(Be)},willPrintOwnComments:f.willPrintOwnComments,canAttachComment:We,printComment:Fe,isBlockComment:N,handleComments:{avoidAstMutation:!0,ownLine:f.handleOwnLineComment,endOfLine:f.handleEndOfLineComment,remaining:f.handleRemainingComment},getCommentChildNodes:f.getCommentChildNodes};}}),Zm=Z({"src/language-js/printer-estree-json.js"(e,n){re();var{builders:{hardline:t,indent:s,join:a}}=Oe(),r=so();function u(c,v,m){let d=c.getValue();switch(d.type){case"JsonRoot":return [m("node"),t];case"ArrayExpression":{if(d.elements.length===0)return "[]";let p=c.map(()=>c.getValue()===null?"null":m(),"elements");return ["[",s([t,a([",",t],p)]),t,"]"]}case"ObjectExpression":return d.properties.length===0?"{}":["{",s([t,a([",",t],c.map(m,"properties"))]),t,"}"];case"ObjectProperty":return [m("key"),": ",m("value")];case"UnaryExpression":return [d.operator==="+"?"":d.operator,m("argument")];case"NullLiteral":return "null";case"BooleanLiteral":return d.value?"true":"false";case"StringLiteral":case"NumericLiteral":return JSON.stringify(d.value);case"Identifier":{let p=c.getParentNode();return p&&p.type==="ObjectProperty"&&p.key===d?JSON.stringify(d.name):d.name}case"TemplateLiteral":return m(["quasis",0]);case"TemplateElement":return JSON.stringify(d.value.cooked);default:throw new Error("unknown type: "+JSON.stringify(d.type))}}var i=new Set(["start","end","extra","loc","comments","leadingComments","trailingComments","innerComments","errors","range","tokens"]);function o(c,v){let{type:m}=c;if(m==="ObjectProperty"&&c.key.type==="Identifier"){v.key={type:"StringLiteral",value:c.key.name};return}if(m==="UnaryExpression"&&c.operator==="+")return v.argument;if(m==="ArrayExpression"){for(let[d,p]of c.elements.entries())p===null&&v.elements.splice(d,0,{type:"NullLiteral"});return}if(m==="TemplateLiteral")return {type:"StringLiteral",value:c.quasis[0].value.cooked}}o.ignoredProperties=i,n.exports={preprocess:r,print:u,massageAstNode:o};}}),Ot=Z({"src/common/common-options.js"(e,n){re();var t="Common";n.exports={bracketSpacing:{since:"0.0.0",category:t,type:"boolean",default:!0,description:"Print spaces between brackets.",oppositeDescription:"Do not print spaces between brackets."},singleQuote:{since:"0.0.0",category:t,type:"boolean",default:!1,description:"Use single quotes instead of double quotes."},proseWrap:{since:"1.8.2",category:t,type:"choice",default:[{since:"1.8.2",value:!0},{since:"1.9.0",value:"preserve"}],description:"How to wrap prose.",choices:[{since:"1.9.0",value:"always",description:"Wrap prose if it exceeds the print width."},{since:"1.9.0",value:"never",description:"Do not wrap prose."},{since:"1.9.0",value:"preserve",description:"Wrap prose as-is."}]},bracketSameLine:{since:"2.4.0",category:t,type:"boolean",default:!1,description:"Put > of opening tags on the last line instead of on a new line."},singleAttributePerLine:{since:"2.6.0",category:t,type:"boolean",default:!1,description:"Enforce single attribute per line in HTML, Vue and JSX."}};}}),ed=Z({"src/language-js/options.js"(e,n){re();var t=Ot(),s="JavaScript";n.exports={arrowParens:{since:"1.9.0",category:s,type:"choice",default:[{since:"1.9.0",value:"avoid"},{since:"2.0.0",value:"always"}],description:"Include parentheses around a sole arrow function parameter.",choices:[{value:"always",description:"Always include parens. Example: `(x) => x`"},{value:"avoid",description:"Omit parens when possible. Example: `x => x`"}]},bracketSameLine:t.bracketSameLine,bracketSpacing:t.bracketSpacing,jsxBracketSameLine:{since:"0.17.0",category:s,type:"boolean",description:"Put > on the last line instead of at a new line.",deprecated:"2.4.0"},semi:{since:"1.0.0",category:s,type:"boolean",default:!0,description:"Print semicolons.",oppositeDescription:"Do not print semicolons, except at the beginning of lines which may need them."},singleQuote:t.singleQuote,jsxSingleQuote:{since:"1.15.0",category:s,type:"boolean",default:!1,description:"Use single quotes in JSX."},quoteProps:{since:"1.17.0",category:s,type:"choice",default:"as-needed",description:"Change when properties in objects are quoted.",choices:[{value:"as-needed",description:"Only add quotes around object properties where required."},{value:"consistent",description:"If at least one property in an object requires quotes, quote all properties."},{value:"preserve",description:"Respect the input use of quotes in object properties."}]},trailingComma:{since:"0.0.0",category:s,type:"choice",default:[{since:"0.0.0",value:!1},{since:"0.19.0",value:"none"},{since:"2.0.0",value:"es5"}],description:"Print trailing commas wherever possible when multi-line.",choices:[{value:"es5",description:"Trailing commas where valid in ES5 (objects, arrays, etc.)"},{value:"none",description:"No trailing commas."},{value:"all",description:"Trailing commas wherever possible (including function arguments)."}]},singleAttributePerLine:t.singleAttributePerLine};}}),td=Z({"src/language-js/parse/parsers.js"(){re();}}),Sn=Z({"node_modules/linguist-languages/data/JavaScript.json"(e,n){n.exports={name:"JavaScript",type:"programming",tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"text/javascript",color:"#f1e05a",aliases:["js","node"],extensions:[".js","._js",".bones",".cjs",".es",".es6",".frag",".gs",".jake",".javascript",".jsb",".jscad",".jsfl",".jslib",".jsm",".jspre",".jss",".jsx",".mjs",".njs",".pac",".sjs",".ssjs",".xsjs",".xsjslib"],filenames:["Jakefile"],interpreters:["chakra","d8","gjs","js","node","nodejs","qjs","rhino","v8","v8-shell"],languageId:183};}}),rd=Z({"node_modules/linguist-languages/data/TypeScript.json"(e,n){n.exports={name:"TypeScript",type:"programming",color:"#3178c6",aliases:["ts"],interpreters:["deno","ts-node"],extensions:[".ts",".cts",".mts"],tmScope:"source.ts",aceMode:"typescript",codemirrorMode:"javascript",codemirrorMimeType:"application/typescript",languageId:378};}}),nd=Z({"node_modules/linguist-languages/data/TSX.json"(e,n){n.exports={name:"TSX",type:"programming",color:"#3178c6",group:"TypeScript",extensions:[".tsx"],tmScope:"source.tsx",aceMode:"javascript",codemirrorMode:"jsx",codemirrorMimeType:"text/jsx",languageId:94901924};}}),ma=Z({"node_modules/linguist-languages/data/JSON.json"(e,n){n.exports={name:"JSON",type:"data",color:"#292929",tmScope:"source.json",aceMode:"json",codemirrorMode:"javascript",codemirrorMimeType:"application/json",aliases:["geojson","jsonl","topojson"],extensions:[".json",".4DForm",".4DProject",".avsc",".geojson",".gltf",".har",".ice",".JSON-tmLanguage",".jsonl",".mcmeta",".tfstate",".tfstate.backup",".topojson",".webapp",".webmanifest",".yy",".yyp"],filenames:[".arcconfig",".auto-changelog",".c8rc",".htmlhintrc",".imgbotconfig",".nycrc",".tern-config",".tern-project",".watchmanconfig","Pipfile.lock","composer.lock","mcmod.info"],languageId:174};}}),ud=Z({"node_modules/linguist-languages/data/JSON with Comments.json"(e,n){n.exports={name:"JSON with Comments",type:"data",color:"#292929",group:"JSON",tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"text/javascript",aliases:["jsonc"],extensions:[".jsonc",".code-snippets",".sublime-build",".sublime-commands",".sublime-completions",".sublime-keymap",".sublime-macro",".sublime-menu",".sublime-mousemap",".sublime-project",".sublime-settings",".sublime-theme",".sublime-workspace",".sublime_metrics",".sublime_session"],filenames:[".babelrc",".devcontainer.json",".eslintrc.json",".jscsrc",".jshintrc",".jslintrc","api-extractor.json","devcontainer.json","jsconfig.json","language-configuration.json","tsconfig.json","tslint.json"],languageId:423};}}),sd=Z({"node_modules/linguist-languages/data/JSON5.json"(e,n){n.exports={name:"JSON5",type:"data",color:"#267CB9",extensions:[".json5"],tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"application/json",languageId:175};}}),id=Z({"src/language-js/index.js"(e,n){re();var t=Bt(),s=Qm(),a=Zm(),r=ed(),u=td(),i=[t(Sn(),c=>({since:"0.0.0",parsers:["babel","acorn","espree","meriyah","babel-flow","babel-ts","flow","typescript"],vscodeLanguageIds:["javascript","mongo"],interpreters:[...c.interpreters,"zx"],extensions:[...c.extensions.filter(v=>v!==".jsx"),".wxs"]})),t(Sn(),()=>({name:"Flow",since:"0.0.0",parsers:["flow","babel-flow"],vscodeLanguageIds:["javascript"],aliases:[],filenames:[],extensions:[".js.flow"]})),t(Sn(),()=>({name:"JSX",since:"0.0.0",parsers:["babel","babel-flow","babel-ts","flow","typescript","espree","meriyah"],vscodeLanguageIds:["javascriptreact"],aliases:void 0,filenames:void 0,extensions:[".jsx"],group:"JavaScript",interpreters:void 0,tmScope:"source.js.jsx",aceMode:"javascript",codemirrorMode:"jsx",codemirrorMimeType:"text/jsx",color:void 0})),t(rd(),()=>({since:"1.4.0",parsers:["typescript","babel-ts"],vscodeLanguageIds:["typescript"]})),t(nd(),()=>({since:"1.4.0",parsers:["typescript","babel-ts"],vscodeLanguageIds:["typescriptreact"]})),t(ma(),()=>({name:"JSON.stringify",since:"1.13.0",parsers:["json-stringify"],vscodeLanguageIds:["json"],extensions:[".importmap"],filenames:["package.json","package-lock.json","composer.json"]})),t(ma(),c=>({since:"1.5.0",parsers:["json"],vscodeLanguageIds:["json"],extensions:c.extensions.filter(v=>v!==".jsonl")})),t(ud(),c=>({since:"1.5.0",parsers:["json"],vscodeLanguageIds:["jsonc"],filenames:[...c.filenames,".eslintrc",".swcrc"]})),t(sd(),()=>({since:"1.13.0",parsers:["json5"],vscodeLanguageIds:["json5"]}))],o={estree:s,"estree-json":a};n.exports={languages:i,options:r,printers:o,parsers:u};}}),ad=Z({"src/language-css/clean.js"(e,n){re();var{isFrontMatterNode:t}=Ue(),s=it(),a=new Set(["raw","raws","sourceIndex","source","before","after","trailingComma"]);function r(i,o,c){if(t(i)&&i.lang==="yaml"&&delete o.value,i.type==="css-comment"&&c.type==="css-root"&&c.nodes.length>0&&((c.nodes[0]===i||t(c.nodes[0])&&c.nodes[1]===i)&&(delete o.text,/^\*\s*@(?:format|prettier)\s*$/.test(i.text))||c.type==="css-root"&&s(c.nodes)===i))return null;if(i.type==="value-root"&&delete o.text,(i.type==="media-query"||i.type==="media-query-list"||i.type==="media-feature-expression")&&delete o.value,i.type==="css-rule"&&delete o.params,i.type==="selector-combinator"&&(o.value=o.value.replace(/\s+/g," ")),i.type==="media-feature"&&(o.value=o.value.replace(/ /g,"")),(i.type==="value-word"&&(i.isColor&&i.isHex||["initial","inherit","unset","revert"].includes(o.value.replace().toLowerCase()))||i.type==="media-feature"||i.type==="selector-root-invalid"||i.type==="selector-pseudo")&&(o.value=o.value.toLowerCase()),i.type==="css-decl"&&(o.prop=o.prop.toLowerCase()),(i.type==="css-atrule"||i.type==="css-import")&&(o.name=o.name.toLowerCase()),i.type==="value-number"&&(o.unit=o.unit.toLowerCase()),(i.type==="media-feature"||i.type==="media-keyword"||i.type==="media-type"||i.type==="media-unknown"||i.type==="media-url"||i.type==="media-value"||i.type==="selector-attribute"||i.type==="selector-string"||i.type==="selector-class"||i.type==="selector-combinator"||i.type==="value-string")&&o.value&&(o.value=u(o.value)),i.type==="selector-attribute"&&(o.attribute=o.attribute.trim(),o.namespace&&typeof o.namespace=="string"&&(o.namespace=o.namespace.trim(),o.namespace.length===0&&(o.namespace=!0)),o.value&&(o.value=o.value.trim().replace(/^["']|["']$/g,""),delete o.quoted)),(i.type==="media-value"||i.type==="media-type"||i.type==="value-number"||i.type==="selector-root-invalid"||i.type==="selector-class"||i.type==="selector-combinator"||i.type==="selector-tag")&&o.value&&(o.value=o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g,(v,m,d)=>{let p=Number(m);return Number.isNaN(p)?v:p+d.toLowerCase()})),i.type==="selector-tag"){let v=i.value.toLowerCase();["from","to"].includes(v)&&(o.value=v);}if(i.type==="css-atrule"&&i.name.toLowerCase()==="supports"&&delete o.value,i.type==="selector-unknown"&&delete o.value,i.type==="value-comma_group"){let v=i.groups.findIndex(m=>m.type==="value-number"&&m.unit==="...");v!==-1&&(o.groups[v].unit="",o.groups.splice(v+1,0,{type:"value-word",value:"...",isColor:!1,isHex:!1}));}}r.ignoredProperties=a;function u(i){return i.replace(/'/g,'"').replace(/\\([^\dA-Fa-f])/g,"$1")}n.exports=r;}}),Xn=Z({"src/utils/front-matter/print.js"(e,n){re();var{builders:{hardline:t,markAsRoot:s}}=Oe();function a(r,u){if(r.lang==="yaml"){let i=r.value.trim(),o=i?u(i,{parser:"yaml"},{stripTrailingHardline:!0}):"";return s([r.startDelimiter,t,o,o?t:"",r.endDelimiter])}}n.exports=a;}}),od=Z({"src/language-css/embed.js"(e,n){re();var{builders:{hardline:t}}=Oe(),s=Xn();function a(r,u,i){let o=r.getValue();if(o.type==="front-matter"){let c=s(o,i);return c?[c,t]:""}}n.exports=a;}}),mo=Z({"src/utils/front-matter/parse.js"(e,n){re();var t=new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)","s");function s(a){let r=a.match(t);if(!r)return {content:a};let{startDelimiter:u,language:i,value:o="",endDelimiter:c}=r.groups,v=i.trim()||"yaml";if(u==="+++"&&(v="toml"),v!=="yaml"&&u!==c)return {content:a};let[m]=r;return {frontMatter:{type:"front-matter",lang:v,value:o,startDelimiter:u,endDelimiter:c,raw:m.replace(/\n$/,"")},content:m.replace(/[^\n]/g," ")+a.slice(m.length)}}n.exports=s;}}),ld=Z({"src/language-css/pragma.js"(e,n){re();var t=no(),s=mo();function a(u){return t.hasPragma(s(u).content)}function r(u){let{frontMatter:i,content:o}=s(u);return (i?i.raw+`

	`:"")+t.insertPragma(o)}n.exports={hasPragma:a,insertPragma:r};}}),cd=Z({"src/language-css/utils/index.js"(e,n){re();var t=new Set(["red","green","blue","alpha","a","rgb","hue","h","saturation","s","lightness","l","whiteness","w","blackness","b","tint","shade","blend","blenda","contrast","hsl","hsla","hwb","hwba"]);function s(G,z){let U=Array.isArray(z)?z:[z],le=-1,ge;for(;ge=G.getParentNode(++le);)if(U.includes(ge.type))return le;return -1}function a(G,z){let U=s(G,z);return U===-1?null:G.getParentNode(U)}function r(G){var z;let U=a(G,"css-decl");return U==null||(z=U.prop)===null||z===void 0?void 0:z.toLowerCase()}var u=new Set(["initial","inherit","unset","revert"]);function i(G){return u.has(G.toLowerCase())}function o(G,z){let U=a(G,"css-atrule");return (U==null?void 0:U.name)&&U.name.toLowerCase().endsWith("keyframes")&&["from","to"].includes(z.toLowerCase())}function c(G){return G.includes("$")||G.includes("@")||G.includes("#")||G.startsWith("%")||G.startsWith("--")||G.startsWith(":--")||G.includes("(")&&G.includes(")")?G:G.toLowerCase()}function v(G,z){var U;let le=a(G,"value-func");return (le==null||(U=le.value)===null||U===void 0?void 0:U.toLowerCase())===z}function m(G){var z;let U=a(G,"css-rule"),le=U==null||(z=U.raws)===null||z===void 0?void 0:z.selector;return le&&(le.startsWith(":import")||le.startsWith(":export"))}function d(G,z){let U=Array.isArray(z)?z:[z],le=a(G,"css-atrule");return le&&U.includes(le.name.toLowerCase())}function p(G){let z=G.getValue(),U=a(G,"css-atrule");return (U==null?void 0:U.name)==="import"&&z.groups[0].value==="url"&&z.groups.length===2}function f(G){return G.type==="value-func"&&G.value.toLowerCase()==="url"}function h(G,z){var U;let le=(U=G.getParentNode())===null||U===void 0?void 0:U.nodes;return le&&le.indexOf(z)===le.length-1}function w(G){let{selector:z}=G;return z?typeof z=="string"&&/^@.+:.*$/.test(z)||z.value&&/^@.+:.*$/.test(z.value):!1}function T(G){return G.type==="value-word"&&["from","through","end"].includes(G.value)}function A(G){return G.type==="value-word"&&["and","or","not"].includes(G.value)}function S(G){return G.type==="value-word"&&G.value==="in"}function B(G){return G.type==="value-operator"&&G.value==="*"}function I(G){return G.type==="value-operator"&&G.value==="/"}function k(G){return G.type==="value-operator"&&G.value==="+"}function P(G){return G.type==="value-operator"&&G.value==="-"}function C(G){return G.type==="value-operator"&&G.value==="%"}function D(G){return B(G)||I(G)||k(G)||P(G)||C(G)}function g(G){return G.type==="value-word"&&["==","!="].includes(G.value)}function F(G){return G.type==="value-word"&&["<",">","<=",">="].includes(G.value)}function l(G){return G.type==="css-atrule"&&["if","else","for","each","while"].includes(G.name)}function E(G){var z;return ((z=G.raws)===null||z===void 0?void 0:z.params)&&/^\(\s*\)$/.test(G.raws.params)}function y(G){return G.name.startsWith("prettier-placeholder")}function N(G){return G.prop.startsWith("@prettier-placeholder")}function x(G,z){return G.value==="$$"&&G.type==="value-func"&&(z==null?void 0:z.type)==="value-word"&&!z.raws.before}function b(G){var z,U;return ((z=G.value)===null||z===void 0?void 0:z.type)==="value-root"&&((U=G.value.group)===null||U===void 0?void 0:U.type)==="value-value"&&G.prop.toLowerCase()==="composes"}function L(G){var z,U,le;return ((z=G.value)===null||z===void 0||(U=z.group)===null||U===void 0||(le=U.group)===null||le===void 0?void 0:le.type)==="value-paren_group"&&G.value.group.group.open!==null&&G.value.group.group.close!==null}function M(G){var z;return ((z=G.raws)===null||z===void 0?void 0:z.before)===""}function j(G){var z,U;return G.type==="value-comma_group"&&((z=G.groups)===null||z===void 0||(U=z[1])===null||U===void 0?void 0:U.type)==="value-colon"}function $(G){var z;return G.type==="value-paren_group"&&((z=G.groups)===null||z===void 0?void 0:z[0])&&j(G.groups[0])}function V(G){var z;let U=G.getValue();if(U.groups.length===0)return !1;let le=G.getParentNode(1);if(!$(U)&&!(le&&$(le)))return !1;let ge=a(G,"css-decl");return !!(ge!=null&&(z=ge.prop)!==null&&z!==void 0&&z.startsWith("$")||$(le)||le.type==="value-func")}function q(G){return G.type==="value-comment"&&G.inline}function Y(G){return G.type==="value-word"&&G.value==="#"}function H(G){return G.type==="value-word"&&G.value==="{"}function R(G){return G.type==="value-word"&&G.value==="}"}function Q(G){return ["value-word","value-atword"].includes(G.type)}function ee(G){return (G==null?void 0:G.type)==="value-colon"}function te(G,z){if(!j(z))return !1;let{groups:U}=z,le=U.indexOf(G);return le===-1?!1:ee(U[le+1])}function oe(G){return G.value&&["not","and","or"].includes(G.value.toLowerCase())}function W(G){return G.type!=="value-func"?!1:t.has(G.value.toLowerCase())}function X(G){return /\/\//.test(G.split(/[\n\r]/).pop())}function ue(G){return (G==null?void 0:G.type)==="value-atword"&&G.value.startsWith("prettier-placeholder-")}function De(G,z){var U,le;if(((U=G.open)===null||U===void 0?void 0:U.value)!=="("||((le=G.close)===null||le===void 0?void 0:le.value)!==")"||G.groups.some(ge=>ge.type!=="value-comma_group"))return !1;if(z.type==="value-comma_group"){let ge=z.groups.indexOf(G)-1,Ae=z.groups[ge];if((Ae==null?void 0:Ae.type)==="value-word"&&Ae.value==="with")return !0}return !1}function ie(G){var z,U;return G.type==="value-paren_group"&&((z=G.open)===null||z===void 0?void 0:z.value)==="("&&((U=G.close)===null||U===void 0?void 0:U.value)===")"}n.exports={getAncestorCounter:s,getAncestorNode:a,getPropOfDeclNode:r,maybeToLowerCase:c,insideValueFunctionNode:v,insideICSSRuleNode:m,insideAtRuleNode:d,insideURLFunctionInImportAtRuleNode:p,isKeyframeAtRuleKeywords:o,isWideKeywords:i,isLastNode:h,isSCSSControlDirectiveNode:l,isDetachedRulesetDeclarationNode:w,isRelationalOperatorNode:F,isEqualityOperatorNode:g,isMultiplicationNode:B,isDivisionNode:I,isAdditionNode:k,isSubtractionNode:P,isModuloNode:C,isMathOperatorNode:D,isEachKeywordNode:S,isForKeywordNode:T,isURLFunctionNode:f,isIfElseKeywordNode:A,hasComposesNode:b,hasParensAroundNode:L,hasEmptyRawBefore:M,isDetachedRulesetCallNode:E,isTemplatePlaceholderNode:y,isTemplatePropNode:N,isPostcssSimpleVarNode:x,isKeyValuePairNode:j,isKeyValuePairInParenGroupNode:$,isKeyInValuePairNode:te,isSCSSMapItemNode:V,isInlineValueCommentNode:q,isHashNode:Y,isLeftCurlyBraceNode:H,isRightCurlyBraceNode:R,isWordNode:Q,isColonNode:ee,isMediaAndSupportsKeywords:oe,isColorAdjusterFuncNode:W,lastLineHasInlineComment:X,isAtWordPlaceholderNode:ue,isConfigurationNode:De,isParenGroupNode:ie};}}),pd=Z({"src/utils/line-column-to-index.js"(e,n){re(),n.exports=function(t,s){let a=0;for(let r=0;r<t.line-1;++r)a=s.indexOf(`
	`,a)+1;return a+t.column};}}),fd=Z({"src/language-css/loc.js"(e,n){re();var{skipEverythingButNewLine:t}=Nr(),s=it(),a=pd();function r(p,f){return typeof p.sourceIndex=="number"?p.sourceIndex:p.source?a(p.source.start,f)-1:null}function u(p,f){if(p.type==="css-comment"&&p.inline)return t(f,p.source.startOffset);let h=p.nodes&&s(p.nodes);return h&&p.source&&!p.source.end&&(p=h),p.source&&p.source.end?a(p.source.end,f):null}function i(p,f){p.source&&(p.source.startOffset=r(p,f),p.source.endOffset=u(p,f));for(let h in p){let w=p[h];h==="source"||!w||typeof w!="object"||(w.type==="value-root"||w.type==="value-unknown"?o(w,c(p),w.text||w.value):i(w,f));}}function o(p,f,h){p.source&&(p.source.startOffset=r(p,h)+f,p.source.endOffset=u(p,h)+f);for(let w in p){let T=p[w];w==="source"||!T||typeof T!="object"||o(T,f,h);}}function c(p){let f=p.source.startOffset;return typeof p.prop=="string"&&(f+=p.prop.length),p.type==="css-atrule"&&typeof p.name=="string"&&(f+=1+p.name.length+p.raws.afterName.match(/^\s*:?\s*/)[0].length),p.type!=="css-atrule"&&p.raws&&typeof p.raws.between=="string"&&(f+=p.raws.between.length),f}function v(p){let f="initial",h="initial",w,T=!1,A=[];for(let S=0;S<p.length;S++){let B=p[S];switch(f){case"initial":if(B==="'"){f="single-quotes";continue}if(B==='"'){f="double-quotes";continue}if((B==="u"||B==="U")&&p.slice(S,S+4).toLowerCase()==="url("){f="url",S+=3;continue}if(B==="*"&&p[S-1]==="/"){f="comment-block";continue}if(B==="/"&&p[S-1]==="/"){f="comment-inline",w=S-1;continue}continue;case"single-quotes":if(B==="'"&&p[S-1]!=="\\"&&(f=h,h="initial"),B===`
	`||B==="\r")return p;continue;case"double-quotes":if(B==='"'&&p[S-1]!=="\\"&&(f=h,h="initial"),B===`
	`||B==="\r")return p;continue;case"url":if(B===")"&&(f="initial"),B===`
	`||B==="\r")return p;if(B==="'"){f="single-quotes",h="url";continue}if(B==='"'){f="double-quotes",h="url";continue}continue;case"comment-block":B==="/"&&p[S-1]==="*"&&(f="initial");continue;case"comment-inline":(B==='"'||B==="'"||B==="*")&&(T=!0),(B===`
	`||B==="\r")&&(T&&A.push([w,S]),f="initial",T=!1);continue}}for(let[S,B]of A)p=p.slice(0,S)+p.slice(S,B).replace(/["'*]/g," ")+p.slice(B);return p}function m(p){return p.source.startOffset}function d(p){return p.source.endOffset}n.exports={locStart:m,locEnd:d,calculateLoc:i,replaceQuotesInInlineComments:v};}}),Dd=Z({"src/language-css/utils/is-less-parser.js"(e,n){re();function t(s){return s.parser==="css"||s.parser==="less"}n.exports=t;}}),md=Z({"src/language-css/utils/is-scss.js"(e,n){re();function t(s,a){return s==="less"||s==="scss"?s==="scss":/(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a)}n.exports=t;}}),dd=Z({"src/language-css/utils/css-units.evaluate.js"(e,n){n.exports={em:"em",rem:"rem",ex:"ex",rex:"rex",cap:"cap",rcap:"rcap",ch:"ch",rch:"rch",ic:"ic",ric:"ric",lh:"lh",rlh:"rlh",vw:"vw",svw:"svw",lvw:"lvw",dvw:"dvw",vh:"vh",svh:"svh",lvh:"lvh",dvh:"dvh",vi:"vi",svi:"svi",lvi:"lvi",dvi:"dvi",vb:"vb",svb:"svb",lvb:"lvb",dvb:"dvb",vmin:"vmin",svmin:"svmin",lvmin:"lvmin",dvmin:"dvmin",vmax:"vmax",svmax:"svmax",lvmax:"lvmax",dvmax:"dvmax",cm:"cm",mm:"mm",q:"Q",in:"in",pt:"pt",pc:"pc",px:"px",deg:"deg",grad:"grad",rad:"rad",turn:"turn",s:"s",ms:"ms",hz:"Hz",khz:"kHz",dpi:"dpi",dpcm:"dpcm",dppx:"dppx",x:"x"};}}),gd=Z({"src/language-css/utils/print-unit.js"(e,n){re();var t=dd();function s(a){let r=a.toLowerCase();return Object.prototype.hasOwnProperty.call(t,r)?t[r]:a}n.exports=s;}}),yd=Z({"src/language-css/printer-postcss.js"(e,n){re();var t=it(),{printNumber:s,printString:a,hasNewline:r,isFrontMatterNode:u,isNextLineEmpty:i,isNonEmptyArray:o}=Ue(),{builders:{join:c,line:v,hardline:m,softline:d,group:p,fill:f,indent:h,dedent:w,ifBreak:T,breakParent:A},utils:{removeLines:S,getDocParts:B}}=Oe(),I=ad(),k=od(),{insertPragma:P}=ld(),{getAncestorNode:C,getPropOfDeclNode:D,maybeToLowerCase:g,insideValueFunctionNode:F,insideICSSRuleNode:l,insideAtRuleNode:E,insideURLFunctionInImportAtRuleNode:y,isKeyframeAtRuleKeywords:N,isWideKeywords:x,isLastNode:b,isSCSSControlDirectiveNode:L,isDetachedRulesetDeclarationNode:M,isRelationalOperatorNode:j,isEqualityOperatorNode:$,isMultiplicationNode:V,isDivisionNode:q,isAdditionNode:Y,isSubtractionNode:H,isMathOperatorNode:R,isEachKeywordNode:Q,isForKeywordNode:ee,isURLFunctionNode:te,isIfElseKeywordNode:oe,hasComposesNode:W,hasParensAroundNode:X,hasEmptyRawBefore:ue,isKeyValuePairNode:De,isKeyInValuePairNode:ie,isDetachedRulesetCallNode:G,isTemplatePlaceholderNode:z,isTemplatePropNode:U,isPostcssSimpleVarNode:le,isSCSSMapItemNode:ge,isInlineValueCommentNode:Ae,isHashNode:Ne,isLeftCurlyBraceNode:ke,isRightCurlyBraceNode:ce,isWordNode:pe,isColonNode:de,isMediaAndSupportsKeywords:ae,isColorAdjusterFuncNode:ve,lastLineHasInlineComment:K,isAtWordPlaceholderNode:he,isConfigurationNode:ye,isParenGroupNode:Ce}=cd(),{locStart:Ie,locEnd:Fe}=fd(),me=Dd(),_=md(),J=gd();function ne(be){return be.trailingComma==="es5"||be.trailingComma==="all"}function Ee(be,Le,qe){let se=be.getValue();if(!se)return "";if(typeof se=="string")return se;switch(se.type){case"front-matter":return [se.raw,m];case"css-root":{let He=We(be,Le,qe),Me=se.raws.after.trim();return [He,Me?" ".concat(Me):"",B(He).length>0?m:""]}case"css-comment":{let He=se.inline||se.raws.inline,Me=Le.originalText.slice(Ie(se),Fe(se));return He?Me.trimEnd():Me}case"css-rule":return [qe("selector"),se.important?" !important":"",se.nodes?[se.selector&&se.selector.type==="selector-unknown"&&K(se.selector.value)?v:" ","{",se.nodes.length>0?h([m,We(be,Le,qe)]):"",m,"}",M(se)?";":""]:";"];case"css-decl":{let He=be.getParentNode(),{between:Me}=se.raws,ze=Me.trim(),nt=ze===":",tt=W(se)?S(qe("value")):qe("value");return !nt&&K(ze)&&(tt=h([m,w(tt)])),[se.raws.before.replace(/[\s;]/g,""),l(be)?se.prop:g(se.prop),ze.startsWith("//")?" ":"",ze,se.extend?"":" ",me(Le)&&se.extend&&se.selector?["extend(",qe("selector"),")"]:"",tt,se.raws.important?se.raws.important.replace(/\s*!\s*important/i," !important"):se.important?" !important":"",se.raws.scssDefault?se.raws.scssDefault.replace(/\s*!default/i," !default"):se.scssDefault?" !default":"",se.raws.scssGlobal?se.raws.scssGlobal.replace(/\s*!global/i," !global"):se.scssGlobal?" !global":"",se.nodes?[" {",h([d,We(be,Le,qe)]),d,"}"]:U(se)&&!He.raws.semicolon&&Le.originalText[Fe(se)-1]!==";"?"":Le.__isHTMLStyleAttribute&&b(be,se)?T(";"):";"]}case"css-atrule":{let He=be.getParentNode(),Me=z(se)&&!He.raws.semicolon&&Le.originalText[Fe(se)-1]!==";";if(me(Le)){if(se.mixin)return [qe("selector"),se.important?" !important":"",Me?"":";"];if(se.function)return [se.name,qe("params"),Me?"":";"];if(se.variable)return ["@",se.name,": ",se.value?qe("value"):"",se.raws.between.trim()?se.raws.between.trim()+" ":"",se.nodes?["{",h([se.nodes.length>0?d:"",We(be,Le,qe)]),d,"}"]:"",Me?"":";"]}return ["@",G(se)||se.name.endsWith(":")?se.name:g(se.name),se.params?[G(se)?"":z(se)?se.raws.afterName===""?"":se.name.endsWith(":")?" ":/^\s*\n\s*\n/.test(se.raws.afterName)?[m,m]:/^\s*\n/.test(se.raws.afterName)?m:" ":" ",qe("params")]:"",se.selector?h([" ",qe("selector")]):"",se.value?p([" ",qe("value"),L(se)?X(se)?" ":v:""]):se.name==="else"?" ":"",se.nodes?[L(se)?"":se.selector&&!se.selector.nodes&&typeof se.selector.value=="string"&&K(se.selector.value)||!se.selector&&typeof se.params=="string"&&K(se.params)?v:" ","{",h([se.nodes.length>0?d:"",We(be,Le,qe)]),d,"}"]:Me?"":";"]}case"media-query-list":{let He=[];return be.each(Me=>{let ze=Me.getValue();ze.type==="media-query"&&ze.value===""||He.push(qe());},"nodes"),p(h(c(v,He)))}case"media-query":return [c(" ",be.map(qe,"nodes")),b(be,se)?"":","];case"media-type":return je(Xe(se.value,Le));case"media-feature-expression":return se.nodes?["(",...be.map(qe,"nodes"),")"]:se.value;case"media-feature":return g(Xe(se.value.replace(/ +/g," "),Le));case"media-colon":return [se.value," "];case"media-value":return je(Xe(se.value,Le));case"media-keyword":return Xe(se.value,Le);case"media-url":return Xe(se.value.replace(/^url\(\s+/gi,"url(").replace(/\s+\)$/g,")"),Le);case"media-unknown":return se.value;case"selector-root":return p([E(be,"custom-selector")?[C(be,"css-atrule").customSelector,v]:"",c([",",E(be,["extend","custom-selector","nest"])?v:m],be.map(qe,"nodes"))]);case"selector-selector":return p(h(be.map(qe,"nodes")));case"selector-comment":return se.value;case"selector-string":return Xe(se.value,Le);case"selector-tag":{let He=be.getParentNode(),Me=He&&He.nodes.indexOf(se),ze=Me&&He.nodes[Me-1];return [se.namespace?[se.namespace===!0?"":se.namespace.trim(),"|"]:"",ze.type==="selector-nesting"?se.value:je(N(be,se.value)?se.value.toLowerCase():se.value)]}case"selector-id":return ["#",se.value];case"selector-class":return [".",je(Xe(se.value,Le))];case"selector-attribute":return ["[",se.namespace?[se.namespace===!0?"":se.namespace.trim(),"|"]:"",se.attribute.trim(),se.operator?se.operator:"",se.value?_e(Xe(se.value.trim(),Le),Le):"",se.insensitive?" i":"","]"];case"selector-combinator":{if(se.value==="+"||se.value===">"||se.value==="~"||se.value===">>>"){let ze=be.getParentNode();return [ze.type==="selector-selector"&&ze.nodes[0]===se?"":v,se.value,b(be,se)?"":" "]}let He=se.value.trim().startsWith("(")?v:"",Me=je(Xe(se.value.trim(),Le))||v;return [He,Me]}case"selector-universal":return [se.namespace?[se.namespace===!0?"":se.namespace.trim(),"|"]:"",se.value];case"selector-pseudo":return [g(se.value),o(se.nodes)?["(",c(", ",be.map(qe,"nodes")),")"]:""];case"selector-nesting":return se.value;case"selector-unknown":{let He=C(be,"css-rule");if(He&&He.isSCSSNesterProperty)return je(Xe(g(se.value),Le));let Me=be.getParentNode();if(Me.raws&&Me.raws.selector){let nt=Ie(Me),tt=nt+Me.raws.selector.length;return Le.originalText.slice(nt,tt).trim()}let ze=be.getParentNode(1);if(Me.type==="value-paren_group"&&ze&&ze.type==="value-func"&&ze.value==="selector"){let nt=Fe(Me.open)+1,tt=Ie(Me.close),pt=Le.originalText.slice(nt,tt).trim();return K(pt)?[A,pt]:pt}return se.value}case"value-value":case"value-root":return qe("group");case"value-comment":return Le.originalText.slice(Ie(se),Fe(se));case"value-comma_group":{let He=be.getParentNode(),Me=be.getParentNode(1),ze=D(be),nt=ze&&He.type==="value-value"&&(ze==="grid"||ze.startsWith("grid-template")),tt=C(be,"css-atrule"),pt=tt&&L(tt),O=se.groups.some(ut=>Ae(ut)),fe=be.map(qe,"groups"),Te=[],$e=F(be,"url"),Je=!1,Ze=!1;for(let ut=0;ut<se.groups.length;++ut){Te.push(fe[ut]);let rt=se.groups[ut-1],Ve=se.groups[ut],Ge=se.groups[ut+1],tr=se.groups[ut+2];if($e){(Ge&&Y(Ge)||Y(Ve))&&Te.push(" ");continue}if(E(be,"forward")&&Ve.type==="value-word"&&Ve.value&&rt!==void 0&&rt.type==="value-word"&&rt.value==="as"&&Ge.type==="value-operator"&&Ge.value==="*"||!Ge||Ve.type==="value-word"&&Ve.value.endsWith("-")&&he(Ge))continue;let Eo=Ve.type==="value-string"&&Ve.value.startsWith("#{"),Fo=Je&&Ge.type==="value-string"&&Ge.value.endsWith("}");if(Eo||Fo){Je=!Je;continue}if(Je||de(Ve)||de(Ge)||Ve.type==="value-atword"&&Ve.value===""||Ve.value==="~"||Ve.value&&Ve.value.includes("\\")&&Ge&&Ge.type!=="value-comment"||rt&&rt.value&&rt.value.indexOf("\\")===rt.value.length-1&&Ve.type==="value-operator"&&Ve.value==="/"||Ve.value==="\\"||le(Ve,Ge)||Ne(Ve)||ke(Ve)||ce(Ge)||ke(Ge)&&ue(Ge)||ce(Ve)&&ue(Ge)||Ve.value==="--"&&Ne(Ge))continue;let Qn=R(Ve),Zn=R(Ge);if((Qn&&Ne(Ge)||Zn&&ce(Ve))&&ue(Ge)||!rt&&q(Ve)||F(be,"calc")&&(Y(Ve)||Y(Ge)||H(Ve)||H(Ge))&&ue(Ge))continue;let Ao=(Y(Ve)||H(Ve))&&ut===0&&(Ge.type==="value-number"||Ge.isHex)&&Me&&ve(Me)&&!ue(Ge),eu=tr&&tr.type==="value-func"||tr&&pe(tr)||Ve.type==="value-func"||pe(Ve),tu=Ge.type==="value-func"||pe(Ge)||rt&&rt.type==="value-func"||rt&&pe(rt);if(!(!(V(Ge)||V(Ve))&&!F(be,"calc")&&!Ao&&(q(Ge)&&!eu||q(Ve)&&!tu||Y(Ge)&&!eu||Y(Ve)&&!tu||H(Ge)||H(Ve))&&(ue(Ge)||Qn&&(!rt||rt&&R(rt))))){if(Ae(Ve)){if(He.type==="value-paren_group"){Te.push(w(m));continue}Te.push(m);continue}if(pt&&($(Ge)||j(Ge)||oe(Ge)||Q(Ve)||ee(Ve))){Te.push(" ");continue}if(tt&&tt.name.toLowerCase()==="namespace"){Te.push(" ");continue}if(nt){Ve.source&&Ge.source&&Ve.source.start.line!==Ge.source.start.line?(Te.push(m),Ze=!0):Te.push(" ");continue}if(Zn){Te.push(" ");continue}if(!(Ge&&Ge.value==="...")&&!(he(Ve)&&he(Ge)&&Fe(Ve)===Ie(Ge))){if(he(Ve)&&Ce(Ge)&&Fe(Ve)===Ie(Ge.open)){Te.push(d);continue}if(Ve.value==="with"&&Ce(Ge)){Te.push(" ");continue}Te.push(v);}}}return O&&Te.push(A),Ze&&Te.unshift(m),pt?p(h(Te)):y(be)?p(f(Te)):p(h(f(Te)))}case"value-paren_group":{let He=be.getParentNode();if(He&&te(He)&&(se.groups.length===1||se.groups.length>0&&se.groups[0].type==="value-comma_group"&&se.groups[0].groups.length>0&&se.groups[0].groups[0].type==="value-word"&&se.groups[0].groups[0].value.startsWith("data:")))return [se.open?qe("open"):"",c(",",be.map(qe,"groups")),se.close?qe("close"):""];if(!se.open){let $e=be.map(qe,"groups"),Je=[];for(let Ze=0;Ze<$e.length;Ze++)Ze!==0&&Je.push([",",v]),Je.push($e[Ze]);return p(h(f(Je)))}let Me=ge(be),ze=t(se.groups),nt=ze&&ze.type==="value-comment",tt=ie(se,He),pt=ye(se,He),O=pt||Me&&!tt,fe=pt||tt,Te=p([se.open?qe("open"):"",h([d,c([v],be.map(($e,Je)=>{let Ze=$e.getValue(),ut=Je===se.groups.length-1,rt=[qe(),ut?"":","];if(De(Ze)&&Ze.type==="value-comma_group"&&Ze.groups&&Ze.groups[0].type!=="value-paren_group"&&Ze.groups[2]&&Ze.groups[2].type==="value-paren_group"){let Ve=B(rt[0].contents.contents);return Ve[1]=p(Ve[1]),p(w(rt))}if(!ut&&Ze.type==="value-comma_group"&&o(Ze.groups)){let Ve=t(Ze.groups);Ve.source&&i(Le.originalText,Ve,Fe)&&rt.push(m);}return rt},"groups"))]),T(!nt&&_(Le.parser,Le.originalText)&&Me&&ne(Le)?",":""),d,se.close?qe("close"):""],{shouldBreak:O});return fe?w(Te):Te}case"value-func":return [se.value,E(be,"supports")&&ae(se)?" ":"",qe("group")];case"value-paren":return se.value;case"value-number":return [Re(se.value),J(se.unit)];case"value-operator":return se.value;case"value-word":return se.isColor&&se.isHex||x(se.value)?se.value.toLowerCase():se.value;case"value-colon":{let He=be.getParentNode(),Me=He&&He.groups.indexOf(se),ze=Me&&He.groups[Me-1];return [se.value,ze&&typeof ze.value=="string"&&t(ze.value)==="\\"||F(be,"url")?"":v]}case"value-comma":return [se.value," "];case"value-string":return a(se.raws.quote+se.value+se.raws.quote,Le);case"value-atword":return ["@",se.value];case"value-unicode-range":return se.value;case"value-unknown":return se.value;default:throw new Error("Unknown postcss type ".concat(JSON.stringify(se.type)))}}function We(be,Le,qe){let se=[];return be.each((He,Me,ze)=>{let nt=ze[Me-1];if(nt&&nt.type==="css-comment"&&nt.text.trim()==="prettier-ignore"){let tt=He.getValue();se.push(Le.originalText.slice(Ie(tt),Fe(tt)));}else se.push(qe());Me!==ze.length-1&&(ze[Me+1].type==="css-comment"&&!r(Le.originalText,Ie(ze[Me+1]),{backwards:!0})&&!u(ze[Me])||ze[Me+1].type==="css-atrule"&&ze[Me+1].name==="else"&&ze[Me].type!=="css-comment"?se.push(" "):(se.push(Le.__isHTMLStyleAttribute?v:m),i(Le.originalText,He.getValue(),Fe)&&!u(ze[Me])&&se.push(m)));},"nodes"),se}var Be=/(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,Pe=/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g,Se=/[A-Za-z]+/g,Qe=/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g,xe=new RegExp(Be.source+"|(".concat(Qe.source,")?(").concat(Pe.source,")(").concat(Se.source,")?"),"g");function Xe(be,Le){return be.replace(Be,qe=>a(qe,Le))}function _e(be,Le){let qe=Le.singleQuote?"'":'"';return be.includes('"')||be.includes("'")?be:qe+be+qe}function je(be){return be.replace(xe,(Le,qe,se,He,Me)=>!se&&He?Re(He)+g(Me||""):Le)}function Re(be){return s(be).replace(/\.0(?=$|e)/,"")}n.exports={print:Ee,embed:k,insertPragma:P,massageAstNode:I};}}),hd=Z({"src/language-css/options.js"(e,n){re();var t=Ot();n.exports={singleQuote:t.singleQuote};}}),vd=Z({"src/language-css/parsers.js"(){re();}}),Cd=Z({"node_modules/linguist-languages/data/CSS.json"(e,n){n.exports={name:"CSS",type:"markup",tmScope:"source.css",aceMode:"css",codemirrorMode:"css",codemirrorMimeType:"text/css",color:"#563d7c",extensions:[".css"],languageId:50};}}),Ed=Z({"node_modules/linguist-languages/data/PostCSS.json"(e,n){n.exports={name:"PostCSS",type:"markup",color:"#dc3a0c",tmScope:"source.postcss",group:"CSS",extensions:[".pcss",".postcss"],aceMode:"text",languageId:262764437};}}),Fd=Z({"node_modules/linguist-languages/data/Less.json"(e,n){n.exports={name:"Less",type:"markup",color:"#1d365d",aliases:["less-css"],extensions:[".less"],tmScope:"source.css.less",aceMode:"less",codemirrorMode:"css",codemirrorMimeType:"text/css",languageId:198};}}),Ad=Z({"node_modules/linguist-languages/data/SCSS.json"(e,n){n.exports={name:"SCSS",type:"markup",color:"#c6538c",tmScope:"source.css.scss",aceMode:"scss",codemirrorMode:"css",codemirrorMimeType:"text/x-scss",extensions:[".scss"],languageId:329};}}),Sd=Z({"src/language-css/index.js"(e,n){re();var t=Bt(),s=yd(),a=hd(),r=vd(),u=[t(Cd(),o=>({since:"1.4.0",parsers:["css"],vscodeLanguageIds:["css"],extensions:[...o.extensions,".wxss"]})),t(Ed(),()=>({since:"1.4.0",parsers:["css"],vscodeLanguageIds:["postcss"]})),t(Fd(),()=>({since:"1.4.0",parsers:["less"],vscodeLanguageIds:["less"]})),t(Ad(),()=>({since:"1.4.0",parsers:["scss"],vscodeLanguageIds:["scss"]}))],i={postcss:s};n.exports={languages:u,options:a,printers:i,parsers:r};}}),xd=Z({"src/language-handlebars/loc.js"(e,n){re();function t(a){return a.loc.start.offset}function s(a){return a.loc.end.offset}n.exports={locStart:t,locEnd:s};}}),bd=Z({"src/language-handlebars/clean.js"(e,n){re();function t(s,a){if(s.type==="TextNode"){let r=s.chars.trim();if(!r)return null;a.chars=r.replace(/[\t\n\f\r ]+/g," ");}s.type==="AttrNode"&&s.name.toLowerCase()==="class"&&delete a.value;}t.ignoredProperties=new Set(["loc","selfClosing"]),n.exports=t;}}),Td=Z({"vendors/html-void-elements.json"(e,n){n.exports={htmlVoidElements:["area","base","basefont","bgsound","br","col","command","embed","frame","hr","image","img","input","isindex","keygen","link","menuitem","meta","nextid","param","source","track","wbr"]};}}),Bd=Z({"src/language-handlebars/utils.js"(e,n){re();var{htmlVoidElements:t}=Td(),s=it();function a(S){let B=S.getValue(),I=S.getParentNode(0);return !!(m(S,["ElementNode"])&&s(I.children)===B||m(S,["Block"])&&s(I.body)===B)}function r(S){return S.toUpperCase()===S}function u(S){return v(S,["ElementNode"])&&typeof S.tag=="string"&&!S.tag.startsWith(":")&&(r(S.tag[0])||S.tag.includes("."))}var i=new Set(t);function o(S){return i.has(S.tag)||u(S)&&S.children.every(B=>c(B))}function c(S){return v(S,["TextNode"])&&!/\S/.test(S.chars)}function v(S,B){return S&&B.includes(S.type)}function m(S,B){let I=S.getParentNode(0);return v(I,B)}function d(S,B){let I=h(S);return v(I,B)}function p(S,B){let I=w(S);return v(I,B)}function f(S,B){var I,k,P,C;let D=S.getValue(),g=(I=S.getParentNode(0))!==null&&I!==void 0?I:{},F=(k=(P=(C=g.children)!==null&&C!==void 0?C:g.body)!==null&&P!==void 0?P:g.parts)!==null&&k!==void 0?k:[],l=F.indexOf(D);return l!==-1&&F[l+B]}function h(S){let B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;return f(S,-B)}function w(S){return f(S,1)}function T(S){return v(S,["MustacheCommentStatement"])&&typeof S.value=="string"&&S.value.trim()==="prettier-ignore"}function A(S){let B=S.getValue(),I=h(S,2);return T(B)||T(I)}n.exports={getNextNode:w,getPreviousNode:h,hasPrettierIgnore:A,isLastNodeOfSiblings:a,isNextNodeOfSomeType:p,isNodeOfSomeType:v,isParentOfSomeType:m,isPreviousNodeOfSomeType:d,isVoid:o,isWhitespaceNode:c};}}),Nd=Z({"src/language-handlebars/printer-glimmer.js"(e,n){re();var{builders:{dedent:t,fill:s,group:a,hardline:r,ifBreak:u,indent:i,join:o,line:c,softline:v},utils:{getDocParts:m,replaceTextEndOfLine:d}}=Oe(),{getPreferredQuote:p,isNonEmptyArray:f}=Ue(),{locStart:h,locEnd:w}=xd(),T=bd(),{getNextNode:A,getPreviousNode:S,hasPrettierIgnore:B,isLastNodeOfSiblings:I,isNextNodeOfSomeType:k,isNodeOfSomeType:P,isParentOfSomeType:C,isPreviousNodeOfSomeType:D,isVoid:g,isWhitespaceNode:F}=Bd(),l=2;function E(K,he,ye){let Ce=K.getValue();if(!Ce)return "";if(B(K))return he.originalText.slice(h(Ce),w(Ce));let Ie=he.singleQuote?"'":'"';switch(Ce.type){case"Block":case"Program":case"Template":return a(K.map(ye,"body"));case"ElementNode":{let Fe=a(N(K,ye)),me=he.htmlWhitespaceSensitivity==="ignore"&&k(K,["ElementNode"])?v:"";if(g(Ce))return [Fe,me];let _=["</",Ce.tag,">"];return Ce.children.length===0?[Fe,i(_),me]:he.htmlWhitespaceSensitivity==="ignore"?[Fe,i(x(K,he,ye)),r,i(_),me]:[Fe,i(a(x(K,he,ye))),i(_),me]}case"BlockStatement":{let Fe=K.getParentNode(1);return Fe&&Fe.inverse&&Fe.inverse.body.length===1&&Fe.inverse.body[0]===Ce&&Fe.inverse.body[0].path.parts[0]==="if"?[ee(K,ye),ue(K,ye,he),De(K,ye,he)]:[R(K,ye),a([ue(K,ye,he),De(K,ye,he),te(K,ye,he)])]}case"ElementModifierStatement":return a(["{{",pe(K,ye),"}}"]);case"MustacheStatement":return a([L(Ce),pe(K,ye),M(Ce)]);case"SubExpression":return a(["(",ce(K,ye),v,")"]);case"AttrNode":{let Fe=Ce.value.type==="TextNode";if(Fe&&Ce.value.chars===""&&h(Ce.value)===w(Ce.value))return Ce.name;let _=Fe?p(Ce.value.chars,Ie).quote:Ce.value.type==="ConcatStatement"?p(Ce.value.parts.filter(ne=>ne.type==="TextNode").map(ne=>ne.chars).join(""),Ie).quote:"",J=ye("value");return [Ce.name,"=",_,Ce.name==="class"&&_?a(i(J)):J,_]}case"ConcatStatement":return K.map(ye,"parts");case"Hash":return o(c,K.map(ye,"pairs"));case"HashPair":return [Ce.key,"=",ye("value")];case"TextNode":{let Fe=Ce.chars.replace(/{{/g,"\\{{"),me=z(K);if(me){if(me==="class"){let xe=Fe.trim().split(/\s+/).join(" "),Xe=!1,_e=!1;return C(K,["ConcatStatement"])&&(D(K,["MustacheStatement"])&&/^\s/.test(Fe)&&(Xe=!0),k(K,["MustacheStatement"])&&/\s$/.test(Fe)&&xe!==""&&(_e=!0)),[Xe?c:"",xe,_e?c:""]}return d(Fe)}let J=/^[\t\n\f\r ]*$/.test(Fe),ne=!S(K),Ee=!A(K);if(he.htmlWhitespaceSensitivity!=="ignore"){let xe=/^[\t\n\f\r ]*/,Xe=/[\t\n\f\r ]*$/,_e=Ee&&C(K,["Template"]),je=ne&&C(K,["Template"]);if(J){if(je||_e)return "";let se=[c],He=U(Fe);return He&&(se=Ae(He)),I(K)&&(se=se.map(Me=>t(Me))),se}let[Re]=Fe.match(xe),[be]=Fe.match(Xe),Le=[];if(Re){Le=[c];let se=U(Re);se&&(Le=Ae(se)),Fe=Fe.replace(xe,"");}let qe=[];if(be){if(!_e){qe=[c];let se=U(be);se&&(qe=Ae(se)),I(K)&&(qe=qe.map(He=>t(He)));}Fe=Fe.replace(Xe,"");}return [...Le,s(ie(Fe)),...qe]}let We=U(Fe),Be=le(Fe),Pe=ge(Fe);if((ne||Ee)&&J&&C(K,["Block","ElementNode","Template"]))return "";J&&We?(Be=Math.min(We,l),Pe=0):(k(K,["BlockStatement","ElementNode"])&&(Pe=Math.max(Pe,1)),D(K,["BlockStatement","ElementNode"])&&(Be=Math.max(Be,1)));let Se="",Qe="";return Pe===0&&k(K,["MustacheStatement"])&&(Qe=" "),Be===0&&D(K,["MustacheStatement"])&&(Se=" "),ne&&(Be=0,Se=""),Ee&&(Pe=0,Qe=""),Fe=Fe.replace(/^[\t\n\f\r ]+/g,Se).replace(/[\t\n\f\r ]+$/,Qe),[...Ae(Be),s(ie(Fe)),...Ae(Pe)]}case"MustacheCommentStatement":{let Fe=h(Ce),me=w(Ce),_=he.originalText.charAt(Fe+2)==="~",J=he.originalText.charAt(me-3)==="~",ne=Ce.value.includes("}}")?"--":"";return ["{{",_?"~":"","!",ne,Ce.value,ne,J?"~":"","}}"]}case"PathExpression":return Ce.original;case"BooleanLiteral":return String(Ce.value);case"CommentStatement":return ["<!--",Ce.value,"-->"];case"StringLiteral":{if(ke(K)){let Fe=he.singleQuote?'"':"'";return Ne(Ce.value,Fe)}return Ne(Ce.value,Ie)}case"NumberLiteral":return String(Ce.value);case"UndefinedLiteral":return "undefined";case"NullLiteral":return "null";default:throw new Error("unknown glimmer type: "+JSON.stringify(Ce.type))}}function y(K,he){return h(K)-h(he)}function N(K,he){let ye=K.getValue(),Ce=["attributes","modifiers","comments"].filter(Fe=>f(ye[Fe])),Ie=Ce.flatMap(Fe=>ye[Fe]).sort(y);for(let Fe of Ce)K.each(me=>{let _=Ie.indexOf(me.getValue());Ie.splice(_,1,[c,he()]);},Fe);return f(ye.blockParams)&&Ie.push(c,ve(ye)),["<",ye.tag,i(Ie),b(ye)]}function x(K,he,ye){let Ie=K.getValue().children.every(Fe=>F(Fe));return he.htmlWhitespaceSensitivity==="ignore"&&Ie?"":K.map((Fe,me)=>{let _=ye();return me===0&&he.htmlWhitespaceSensitivity==="ignore"?[v,_]:_},"children")}function b(K){return g(K)?u([v,"/>"],[" />",v]):u([v,">"],">")}function L(K){let he=K.escaped===!1?"{{{":"{{",ye=K.strip&&K.strip.open?"~":"";return [he,ye]}function M(K){let he=K.escaped===!1?"}}}":"}}";return [K.strip&&K.strip.close?"~":"",he]}function j(K){let he=L(K),ye=K.openStrip.open?"~":"";return [he,ye,"#"]}function $(K){let he=M(K);return [K.openStrip.close?"~":"",he]}function V(K){let he=L(K),ye=K.closeStrip.open?"~":"";return [he,ye,"/"]}function q(K){let he=M(K);return [K.closeStrip.close?"~":"",he]}function Y(K){let he=L(K),ye=K.inverseStrip.open?"~":"";return [he,ye]}function H(K){let he=M(K);return [K.inverseStrip.close?"~":"",he]}function R(K,he){let ye=K.getValue(),Ce=j(ye),Ie=$(ye),Fe=[de(K,he)],me=ae(K,he);if(me&&Fe.push(c,me),f(ye.program.blockParams)){let _=ve(ye.program);Fe.push(c,_);}return a([Ce,i(Fe),v,Ie])}function Q(K,he){return [he.htmlWhitespaceSensitivity==="ignore"?r:"",Y(K),"else",H(K)]}function ee(K,he){let ye=K.getParentNode(1);return [Y(ye),"else if ",ae(K,he),H(ye)]}function te(K,he,ye){let Ce=K.getValue();return ye.htmlWhitespaceSensitivity==="ignore"?[oe(Ce)?v:r,V(Ce),he("path"),q(Ce)]:[V(Ce),he("path"),q(Ce)]}function oe(K){return P(K,["BlockStatement"])&&K.program.body.every(he=>F(he))}function W(K){return X(K)&&K.inverse.body.length===1&&P(K.inverse.body[0],["BlockStatement"])&&K.inverse.body[0].path.parts[0]==="if"}function X(K){return P(K,["BlockStatement"])&&K.inverse}function ue(K,he,ye){let Ce=K.getValue();if(oe(Ce))return "";let Ie=he("program");return ye.htmlWhitespaceSensitivity==="ignore"?i([r,Ie]):i(Ie)}function De(K,he,ye){let Ce=K.getValue(),Ie=he("inverse"),Fe=ye.htmlWhitespaceSensitivity==="ignore"?[r,Ie]:Ie;return W(Ce)?Fe:X(Ce)?[Q(Ce,ye),i(Fe)]:""}function ie(K){return m(o(c,G(K)))}function G(K){return K.split(/[\t\n\f\r ]+/)}function z(K){for(let he=0;he<2;he++){let ye=K.getParentNode(he);if(ye&&ye.type==="AttrNode")return ye.name.toLowerCase()}}function U(K){return K=typeof K=="string"?K:"",K.split(`
	`).length-1}function le(K){K=typeof K=="string"?K:"";let he=(K.match(/^([^\S\n\r]*[\n\r])+/g)||[])[0]||"";return U(he)}function ge(K){K=typeof K=="string"?K:"";let he=(K.match(/([\n\r][^\S\n\r]*)+$/g)||[])[0]||"";return U(he)}function Ae(){let K=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return Array.from({length:Math.min(K,l)}).fill(r)}function Ne(K,he){let{quote:ye,regex:Ce}=p(K,he);return [ye,K.replace(Ce,"\\".concat(ye)),ye]}function ke(K){let he=0,ye=K.getParentNode(he);for(;ye&&P(ye,["SubExpression"]);)he++,ye=K.getParentNode(he);return !!(ye&&P(K.getParentNode(he+1),["ConcatStatement"])&&P(K.getParentNode(he+2),["AttrNode"]))}function ce(K,he){let ye=de(K,he),Ce=ae(K,he);return Ce?i([ye,c,a(Ce)]):ye}function pe(K,he){let ye=de(K,he),Ce=ae(K,he);return Ce?[i([ye,c,Ce]),v]:ye}function de(K,he){return he("path")}function ae(K,he){let ye=K.getValue(),Ce=[];if(ye.params.length>0){let Ie=K.map(he,"params");Ce.push(...Ie);}if(ye.hash&&ye.hash.pairs.length>0){let Ie=he("hash");Ce.push(Ie);}return Ce.length===0?"":o(c,Ce)}function ve(K){return ["as |",K.blockParams.join(" "),"|"]}n.exports={print:E,massageAstNode:T};}}),wd=Z({"src/language-handlebars/parsers.js"(){re();}}),_d=Z({"node_modules/linguist-languages/data/Handlebars.json"(e,n){n.exports={name:"Handlebars",type:"markup",color:"#f7931e",aliases:["hbs","htmlbars"],extensions:[".handlebars",".hbs"],tmScope:"text.html.handlebars",aceMode:"handlebars",languageId:155};}}),Pd=Z({"src/language-handlebars/index.js"(e,n){re();var t=Bt(),s=Nd(),a=wd(),r=[t(_d(),()=>({since:"2.3.0",parsers:["glimmer"],vscodeLanguageIds:["handlebars"]}))],u={glimmer:s};n.exports={languages:r,printers:u,parsers:a};}}),kd=Z({"src/language-graphql/pragma.js"(e,n){re();function t(a){return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a)}function s(a){return `# @format

	`+a}n.exports={hasPragma:t,insertPragma:s};}}),Id=Z({"src/language-graphql/loc.js"(e,n){re();function t(a){return typeof a.start=="number"?a.start:a.loc&&a.loc.start}function s(a){return typeof a.end=="number"?a.end:a.loc&&a.loc.end}n.exports={locStart:t,locEnd:s};}}),Ld=Z({"src/language-graphql/printer-graphql.js"(e,n){re();var{builders:{join:t,hardline:s,line:a,softline:r,group:u,indent:i,ifBreak:o}}=Oe(),{isNextLineEmpty:c,isNonEmptyArray:v}=Ue(),{insertPragma:m}=kd(),{locStart:d,locEnd:p}=Id();function f(k,P,C){let D=k.getValue();if(!D)return "";if(typeof D=="string")return D;switch(D.kind){case"Document":{let g=[];return k.each((F,l,E)=>{g.push(C()),l!==E.length-1&&(g.push(s),c(P.originalText,F.getValue(),p)&&g.push(s));},"definitions"),[...g,s]}case"OperationDefinition":{let g=P.originalText[d(D)]!=="{",F=Boolean(D.name);return [g?D.operation:"",g&&F?[" ",C("name")]:"",g&&!F&&v(D.variableDefinitions)?" ":"",v(D.variableDefinitions)?u(["(",i([r,t([o("",", "),r],k.map(C,"variableDefinitions"))]),r,")"]):"",h(k,C,D),D.selectionSet?!g&&!F?"":" ":"",C("selectionSet")]}case"FragmentDefinition":return ["fragment ",C("name"),v(D.variableDefinitions)?u(["(",i([r,t([o("",", "),r],k.map(C,"variableDefinitions"))]),r,")"]):""," on ",C("typeCondition"),h(k,C,D)," ",C("selectionSet")];case"SelectionSet":return ["{",i([s,t(s,w(k,P,C,"selections"))]),s,"}"];case"Field":return u([D.alias?[C("alias"),": "]:"",C("name"),D.arguments.length>0?u(["(",i([r,t([o("",", "),r],w(k,P,C,"arguments"))]),r,")"]):"",h(k,C,D),D.selectionSet?" ":"",C("selectionSet")]);case"Name":return D.value;case"StringValue":{if(D.block){let g=D.value.replace(/"""/g,"\\$&").split(`
	`);return g.length===1&&(g[0]=g[0].trim()),g.every(F=>F==="")&&(g.length=0),t(s,['"""',...g,'"""'])}return ['"',D.value.replace(/["\\]/g,"\\$&").replace(/\n/g,"\\n"),'"']}case"IntValue":case"FloatValue":case"EnumValue":return D.value;case"BooleanValue":return D.value?"true":"false";case"NullValue":return "null";case"Variable":return ["$",C("name")];case"ListValue":return u(["[",i([r,t([o("",", "),r],k.map(C,"values"))]),r,"]"]);case"ObjectValue":return u(["{",P.bracketSpacing&&D.fields.length>0?" ":"",i([r,t([o("",", "),r],k.map(C,"fields"))]),r,o("",P.bracketSpacing&&D.fields.length>0?" ":""),"}"]);case"ObjectField":case"Argument":return [C("name"),": ",C("value")];case"Directive":return ["@",C("name"),D.arguments.length>0?u(["(",i([r,t([o("",", "),r],w(k,P,C,"arguments"))]),r,")"]):""];case"NamedType":return C("name");case"VariableDefinition":return [C("variable"),": ",C("type"),D.defaultValue?[" = ",C("defaultValue")]:"",h(k,C,D)];case"ObjectTypeExtension":case"ObjectTypeDefinition":return [C("description"),D.description?s:"",D.kind==="ObjectTypeExtension"?"extend ":"","type ",C("name"),D.interfaces.length>0?[" implements ",...S(k,P,C)]:"",h(k,C,D),D.fields.length>0?[" {",i([s,t(s,w(k,P,C,"fields"))]),s,"}"]:""];case"FieldDefinition":return [C("description"),D.description?s:"",C("name"),D.arguments.length>0?u(["(",i([r,t([o("",", "),r],w(k,P,C,"arguments"))]),r,")"]):"",": ",C("type"),h(k,C,D)];case"DirectiveDefinition":return [C("description"),D.description?s:"","directive ","@",C("name"),D.arguments.length>0?u(["(",i([r,t([o("",", "),r],w(k,P,C,"arguments"))]),r,")"]):"",D.repeatable?" repeatable":""," on ",t(" | ",k.map(C,"locations"))];case"EnumTypeExtension":case"EnumTypeDefinition":return [C("description"),D.description?s:"",D.kind==="EnumTypeExtension"?"extend ":"","enum ",C("name"),h(k,C,D),D.values.length>0?[" {",i([s,t(s,w(k,P,C,"values"))]),s,"}"]:""];case"EnumValueDefinition":return [C("description"),D.description?s:"",C("name"),h(k,C,D)];case"InputValueDefinition":return [C("description"),D.description?D.description.block?s:a:"",C("name"),": ",C("type"),D.defaultValue?[" = ",C("defaultValue")]:"",h(k,C,D)];case"InputObjectTypeExtension":case"InputObjectTypeDefinition":return [C("description"),D.description?s:"",D.kind==="InputObjectTypeExtension"?"extend ":"","input ",C("name"),h(k,C,D),D.fields.length>0?[" {",i([s,t(s,w(k,P,C,"fields"))]),s,"}"]:""];case"SchemaExtension":return ["extend schema",h(k,C,D),...D.operationTypes.length>0?[" {",i([s,t(s,w(k,P,C,"operationTypes"))]),s,"}"]:[]];case"SchemaDefinition":return [C("description"),D.description?s:"","schema",h(k,C,D)," {",D.operationTypes.length>0?i([s,t(s,w(k,P,C,"operationTypes"))]):"",s,"}"];case"OperationTypeDefinition":return [C("operation"),": ",C("type")];case"InterfaceTypeExtension":case"InterfaceTypeDefinition":return [C("description"),D.description?s:"",D.kind==="InterfaceTypeExtension"?"extend ":"","interface ",C("name"),D.interfaces.length>0?[" implements ",...S(k,P,C)]:"",h(k,C,D),D.fields.length>0?[" {",i([s,t(s,w(k,P,C,"fields"))]),s,"}"]:""];case"FragmentSpread":return ["...",C("name"),h(k,C,D)];case"InlineFragment":return ["...",D.typeCondition?[" on ",C("typeCondition")]:"",h(k,C,D)," ",C("selectionSet")];case"UnionTypeExtension":case"UnionTypeDefinition":return u([C("description"),D.description?s:"",u([D.kind==="UnionTypeExtension"?"extend ":"","union ",C("name"),h(k,C,D),D.types.length>0?[" =",o(""," "),i([o([a,"  "]),t([a,"| "],k.map(C,"types"))])]:""])]);case"ScalarTypeExtension":case"ScalarTypeDefinition":return [C("description"),D.description?s:"",D.kind==="ScalarTypeExtension"?"extend ":"","scalar ",C("name"),h(k,C,D)];case"NonNullType":return [C("type"),"!"];case"ListType":return ["[",C("type"),"]"];default:throw new Error("unknown graphql type: "+JSON.stringify(D.kind))}}function h(k,P,C){if(C.directives.length===0)return "";let D=t(a,k.map(P,"directives"));return C.kind==="FragmentDefinition"||C.kind==="OperationDefinition"?u([a,D]):[" ",u(i([r,D]))]}function w(k,P,C,D){return k.map((g,F,l)=>{let E=C();return F<l.length-1&&c(P.originalText,g.getValue(),p)?[E,s]:E},D)}function T(k){return k.kind&&k.kind!=="Comment"}function A(k){let P=k.getValue();if(P.kind==="Comment")return "#"+P.value.trimEnd();throw new Error("Not a comment: "+JSON.stringify(P))}function S(k,P,C){let D=k.getNode(),g=[],{interfaces:F}=D,l=k.map(E=>C(E),"interfaces");for(let E=0;E<F.length;E++){let y=F[E];g.push(l[E]);let N=F[E+1];if(N){let x=P.originalText.slice(y.loc.end,N.loc.start),b=x.includes("#"),L=x.replace(/#.*/g,"").trim();g.push(L===","?",":" &",b?a:" ");}}return g}function B(k,P){k.kind==="StringValue"&&k.block&&!k.value.includes(`
	`)&&(P.value=P.value.trim());}B.ignoredProperties=new Set(["loc","comments"]);function I(k){var P;let C=k.getValue();return C==null||(P=C.comments)===null||P===void 0?void 0:P.some(D=>D.value.trim()==="prettier-ignore")}n.exports={print:f,massageAstNode:B,hasPrettierIgnore:I,insertPragma:m,printComment:A,canAttachComment:T};}}),jd=Z({"src/language-graphql/options.js"(e,n){re();var t=Ot();n.exports={bracketSpacing:t.bracketSpacing};}}),Od=Z({"src/language-graphql/parsers.js"(){re();}}),qd=Z({"node_modules/linguist-languages/data/GraphQL.json"(e,n){n.exports={name:"GraphQL",type:"data",color:"#e10098",extensions:[".graphql",".gql",".graphqls"],tmScope:"source.graphql",aceMode:"text",languageId:139};}}),Md=Z({"src/language-graphql/index.js"(e,n){re();var t=Bt(),s=Ld(),a=jd(),r=Od(),u=[t(qd(),()=>({since:"1.5.0",parsers:["graphql"],vscodeLanguageIds:["graphql"]}))],i={graphql:s};n.exports={languages:u,options:a,printers:i,parsers:r};}}),go=Z({"src/language-markdown/loc.js"(e,n){re();function t(a){return a.position.start.offset}function s(a){return a.position.end.offset}n.exports={locStart:t,locEnd:s};}}),Rd=Z({"src/language-markdown/constants.evaluate.js"(e,n){n.exports={cjkPattern:"(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",kPattern:"[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",punctuationPattern:"[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"};}}),Kn=Z({"src/language-markdown/utils.js"(e,n){re();var{getLast:t}=Ue(),{locStart:s,locEnd:a}=go(),{cjkPattern:r,kPattern:u,punctuationPattern:i}=Rd(),o=["liquidNode","inlineCode","emphasis","esComment","strong","delete","wikiLink","link","linkReference","image","imageReference","footnote","footnoteReference","sentence","whitespace","word","break","inlineMath"],c=[...o,"tableCell","paragraph","heading"],v=new RegExp(u),m=new RegExp(i);function d(A,S){let B="non-cjk",I="cj-letter",k="k-letter",P="cjk-punctuation",C=[],D=(S.proseWrap==="preserve"?A:A.replace(new RegExp("(".concat(r,`)
	(`).concat(r,")"),"g"),"$1$2")).split(/([\t\n ]+)/);for(let[F,l]of D.entries()){if(F%2===1){C.push({type:"whitespace",value:/\n/.test(l)?`
	`:" "});continue}if((F===0||F===D.length-1)&&l==="")continue;let E=l.split(new RegExp("(".concat(r,")")));for(let[y,N]of E.entries())if(!((y===0||y===E.length-1)&&N==="")){if(y%2===0){N!==""&&g({type:"word",value:N,kind:B,hasLeadingPunctuation:m.test(N[0]),hasTrailingPunctuation:m.test(t(N))});continue}g(m.test(N)?{type:"word",value:N,kind:P,hasLeadingPunctuation:!0,hasTrailingPunctuation:!0}:{type:"word",value:N,kind:v.test(N)?k:I,hasLeadingPunctuation:!1,hasTrailingPunctuation:!1});}}return C;function g(F){let l=t(C);l&&l.type==="word"&&(l.kind===B&&F.kind===I&&!l.hasTrailingPunctuation||l.kind===I&&F.kind===B&&!F.hasLeadingPunctuation?C.push({type:"whitespace",value:" "}):!E(B,P)&&![l.value,F.value].some(y=>/\u3000/.test(y))&&C.push({type:"whitespace",value:""})),C.push(F);function E(y,N){return l.kind===y&&F.kind===N||l.kind===N&&F.kind===y}}}function p(A,S){let[,B,I,k]=S.slice(A.position.start.offset,A.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);return {numberText:B,marker:I,leadingSpaces:k}}function f(A,S){if(!A.ordered||A.children.length<2)return !1;let B=Number(p(A.children[0],S.originalText).numberText),I=Number(p(A.children[1],S.originalText).numberText);if(B===0&&A.children.length>2){let k=Number(p(A.children[2],S.originalText).numberText);return I===1&&k===1}return I===1}function h(A,S){let{value:B}=A;return A.position.end.offset===S.length&&B.endsWith(`
	`)&&S.endsWith(`
	`)?B.slice(0,-1):B}function w(A,S){return function B(I,k,P){let C=Object.assign({},S(I,k,P));return C.children&&(C.children=C.children.map((D,g)=>B(D,g,[C,...P]))),C}(A,null,[])}function T(A){if((A==null?void 0:A.type)!=="link"||A.children.length!==1)return !1;let[S]=A.children;return s(A)===s(S)&&a(A)===a(S)}n.exports={mapAst:w,splitText:d,punctuationPattern:i,getFencedCodeBlockValue:h,getOrderedListItemInfo:p,hasGitDiffFriendlyOrderedList:f,INLINE_NODE_TYPES:o,INLINE_NODE_WRAPPER_TYPES:c,isAutolink:T};}}),Vd=Z({"src/language-markdown/embed.js"(e,n){re();var{inferParserByLanguage:t,getMaxContinuousCount:s}=Ue(),{builders:{hardline:a,markAsRoot:r},utils:{replaceEndOfLine:u}}=Oe(),i=Xn(),{getFencedCodeBlockValue:o}=Kn();function c(v,m,d,p){let f=v.getValue();if(f.type==="code"&&f.lang!==null){let h=t(f.lang,p);if(h){let w=p.__inJsTemplate?"~":"`",T=w.repeat(Math.max(3,s(f.value,w)+1)),A={parser:h};f.lang==="tsx"&&(A.filepath="dummy.tsx");let S=d(o(f,p.originalText),A,{stripTrailingHardline:!0});return r([T,f.lang,f.meta?" "+f.meta:"",a,u(S),a,T])}}switch(f.type){case"front-matter":return i(f,d);case"importExport":return [d(f.value,{parser:"babel"},{stripTrailingHardline:!0}),a];case"jsx":return d("<$>".concat(f.value,"</$>"),{parser:"__js_expression",rootMarker:"mdx"},{stripTrailingHardline:!0})}return null}n.exports=c;}}),yo=Z({"src/language-markdown/pragma.js"(e,n){re();var t=mo(),s=["format","prettier"];function a(r){let u="@(".concat(s.join("|"),")"),i=new RegExp(["<!--\\s*".concat(u,"\\s*-->"),"{\\s*\\/\\*\\s*".concat(u,"\\s*\\*\\/\\s*}"),`<!--.*\r?
	[\\s\\S]*(^|
	)[^\\S
	]*`.concat(u,`[^\\S
	]*($|
	)[\\s\\S]*
	.*-->`)].join("|"),"m"),o=r.match(i);return (o==null?void 0:o.index)===0}n.exports={startWithPragma:a,hasPragma:r=>a(t(r).content.trimStart()),insertPragma:r=>{let u=t(r),i="<!-- @".concat(s[0]," -->");return u.frontMatter?"".concat(u.frontMatter.raw,`

	`).concat(i,`

	`).concat(u.content):"".concat(i,`

	`).concat(u.content)}};}}),Wd=Z({"src/language-markdown/print-preprocess.js"(e,n){re();var t=it(),{getOrderedListItemInfo:s,mapAst:a,splitText:r}=Kn(),u=/^.$/su;function i(T,A){return T=v(T,A),T=p(T),T=c(T),T=h(T,A),T=w(T,A),T=f(T,A),T=o(T),T=m(T),T}function o(T){return a(T,A=>A.type!=="import"&&A.type!=="export"?A:Object.assign(Object.assign({},A),{},{type:"importExport"}))}function c(T){return a(T,A=>A.type!=="inlineCode"?A:Object.assign(Object.assign({},A),{},{value:A.value.replace(/\s+/g," ")}))}function v(T,A){return a(T,S=>S.type!=="text"||S.value==="*"||S.value==="_"||!u.test(S.value)||S.position.end.offset-S.position.start.offset===S.value.length?S:Object.assign(Object.assign({},S),{},{value:A.originalText.slice(S.position.start.offset,S.position.end.offset)}))}function m(T){return d(T,(A,S)=>A.type==="importExport"&&S.type==="importExport",(A,S)=>({type:"importExport",value:A.value+`

	`+S.value,position:{start:A.position.start,end:S.position.end}}))}function d(T,A,S){return a(T,B=>{if(!B.children)return B;let I=B.children.reduce((k,P)=>{let C=t(k);return C&&A(C,P)?k.splice(-1,1,S(C,P)):k.push(P),k},[]);return Object.assign(Object.assign({},B),{},{children:I})})}function p(T){return d(T,(A,S)=>A.type==="text"&&S.type==="text",(A,S)=>({type:"text",value:A.value+S.value,position:{start:A.position.start,end:S.position.end}}))}function f(T,A){return a(T,(S,B,I)=>{let[k]=I;if(S.type!=="text")return S;let{value:P}=S;return k.type==="paragraph"&&(B===0&&(P=P.trimStart()),B===k.children.length-1&&(P=P.trimEnd())),{type:"sentence",position:S.position,children:r(P,A)}})}function h(T,A){return a(T,(S,B,I)=>{if(S.type==="code"){let k=/^\n?(?: {4,}|\t)/.test(A.originalText.slice(S.position.start.offset,S.position.end.offset));if(S.isIndented=k,k)for(let P=0;P<I.length;P++){let C=I[P];if(C.hasIndentedCodeblock)break;C.type==="list"&&(C.hasIndentedCodeblock=!0);}}return S})}function w(T,A){return a(T,(I,k,P)=>{if(I.type==="list"&&I.children.length>0){for(let C=0;C<P.length;C++){let D=P[C];if(D.type==="list"&&!D.isAligned)return I.isAligned=!1,I}I.isAligned=B(I);}return I});function S(I){return I.children.length===0?-1:I.children[0].position.start.column-1}function B(I){if(!I.ordered)return !0;let[k,P]=I.children;if(s(k,A.originalText).leadingSpaces.length>1)return !0;let D=S(k);if(D===-1)return !1;if(I.children.length===1)return D%A.tabWidth===0;let g=S(P);return D!==g?!1:D%A.tabWidth===0?!0:s(P,A.originalText).leadingSpaces.length>1}}n.exports=i;}}),$d=Z({"src/language-markdown/clean.js"(e,n){re();var{isFrontMatterNode:t}=Ue(),{startWithPragma:s}=yo(),a=new Set(["position","raw"]);function r(u,i,o){if((u.type==="front-matter"||u.type==="code"||u.type==="yaml"||u.type==="import"||u.type==="export"||u.type==="jsx")&&delete i.value,u.type==="list"&&delete i.isAligned,(u.type==="list"||u.type==="listItem")&&(delete i.spread,delete i.loose),u.type==="text"||(u.type==="inlineCode"&&(i.value=u.value.replace(/[\t\n ]+/g," ")),u.type==="wikiLink"&&(i.value=u.value.trim().replace(/[\t\n]+/g," ")),(u.type==="definition"||u.type==="linkReference")&&(i.label=u.label.trim().replace(/[\t\n ]+/g," ").toLowerCase()),(u.type==="definition"||u.type==="link"||u.type==="image")&&u.title&&(i.title=u.title.replace(/\\(["')])/g,"$1")),o&&o.type==="root"&&o.children.length>0&&(o.children[0]===u||t(o.children[0])&&o.children[1]===u)&&u.type==="html"&&s(u.value)))return null}r.ignoredProperties=a,n.exports=r;}}),Hd=Z({"src/language-markdown/printer-markdown.js"(e,n){re();var{getLast:t,getMinNotPresentContinuousCount:s,getMaxContinuousCount:a,getStringWidth:r,isNonEmptyArray:u}=Ue(),{builders:{breakParent:i,join:o,line:c,literalline:v,markAsRoot:m,hardline:d,softline:p,ifBreak:f,fill:h,align:w,indent:T,group:A,hardlineWithoutBreakParent:S},utils:{normalizeDoc:B,replaceTextEndOfLine:I},printer:{printDocToString:k}}=Oe(),P=Vd(),{insertPragma:C}=yo(),{locStart:D,locEnd:g}=go(),F=Wd(),l=$d(),{getFencedCodeBlockValue:E,hasGitDiffFriendlyOrderedList:y,splitText:N,punctuationPattern:x,INLINE_NODE_TYPES:b,INLINE_NODE_WRAPPER_TYPES:L,isAutolink:M}=Kn(),j=new Set(["importExport"]),$=["heading","tableCell","link","wikiLink"],V=new Set(["listItem","definition","footnoteDefinition"]);function q(ce,pe,de){let ae=ce.getValue();if(le(ce))return N(pe.originalText.slice(ae.position.start.offset,ae.position.end.offset),pe).map(ve=>ve.type==="word"?ve.value:ve.value===""?"":oe(ce,ve.value,pe));switch(ae.type){case"front-matter":return pe.originalText.slice(ae.position.start.offset,ae.position.end.offset);case"root":return ae.children.length===0?"":[B(X(ce,pe,de)),j.has(De(ae).type)?"":d];case"paragraph":return ue(ce,pe,de,{postprocessor:h});case"sentence":return ue(ce,pe,de);case"word":{let ve=ae.value.replace(/\*/g,"\\$&").replace(new RegExp(["(^|".concat(x,")(_+)"),"(_+)(".concat(x,"|$)")].join("|"),"g"),(ye,Ce,Ie,Fe,me)=>(Ie?"".concat(Ce).concat(Ie):"".concat(Fe).concat(me)).replace(/_/g,"\\_")),K=(ye,Ce,Ie)=>ye.type==="sentence"&&Ie===0,he=(ye,Ce,Ie)=>M(ye.children[Ie-1]);return ve!==ae.value&&(ce.match(void 0,K,he)||ce.match(void 0,K,(ye,Ce,Ie)=>ye.type==="emphasis"&&Ie===0,he))&&(ve=ve.replace(/^(\\?[*_])+/,ye=>ye.replace(/\\/g,""))),ve}case"whitespace":{let ve=ce.getParentNode(),K=ve.children.indexOf(ae),he=ve.children[K+1],ye=he&&/^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(he.value)?"never":pe.proseWrap;return oe(ce,ae.value,{proseWrap:ye})}case"emphasis":{let ve;if(M(ae.children[0]))ve=pe.originalText[ae.position.start.offset];else {let K=ce.getParentNode(),he=K.children.indexOf(ae),ye=K.children[he-1],Ce=K.children[he+1];ve=ye&&ye.type==="sentence"&&ye.children.length>0&&t(ye.children).type==="word"&&!t(ye.children).hasTrailingPunctuation||Ce&&Ce.type==="sentence"&&Ce.children.length>0&&Ce.children[0].type==="word"&&!Ce.children[0].hasLeadingPunctuation||te(ce,"emphasis")?"*":"_";}return [ve,ue(ce,pe,de),ve]}case"strong":return ["**",ue(ce,pe,de),"**"];case"delete":return ["~~",ue(ce,pe,de),"~~"];case"inlineCode":{let ve=s(ae.value,"`"),K="`".repeat(ve||1),he=ve&&!/^\s/.test(ae.value)?" ":"";return [K,he,ae.value,he,K]}case"wikiLink":{let ve="";return pe.proseWrap==="preserve"?ve=ae.value:ve=ae.value.replace(/[\t\n]+/g," "),["[[",ve,"]]"]}case"link":switch(pe.originalText[ae.position.start.offset]){case"<":{let ve="mailto:",K=ae.url.startsWith(ve)&&pe.originalText.slice(ae.position.start.offset+1,ae.position.start.offset+1+ve.length)!==ve?ae.url.slice(ve.length):ae.url;return ["<",K,">"]}case"[":return ["[",ue(ce,pe,de),"](",ge(ae.url,")"),Ae(ae.title,pe),")"];default:return pe.originalText.slice(ae.position.start.offset,ae.position.end.offset)}case"image":return ["![",ae.alt||"","](",ge(ae.url,")"),Ae(ae.title,pe),")"];case"blockquote":return ["> ",w("> ",ue(ce,pe,de))];case"heading":return ["#".repeat(ae.depth)+" ",ue(ce,pe,de)];case"code":{if(ae.isIndented){let he=" ".repeat(4);return w(he,[he,...I(ae.value,d)])}let ve=pe.__inJsTemplate?"~":"`",K=ve.repeat(Math.max(3,a(ae.value,ve)+1));return [K,ae.lang||"",ae.meta?" "+ae.meta:"",d,...I(E(ae,pe.originalText),d),d,K]}case"html":{let ve=ce.getParentNode(),K=ve.type==="root"&&t(ve.children)===ae?ae.value.trimEnd():ae.value,he=/^<!--.*-->$/s.test(K);return I(K,he?d:m(v))}case"list":{let ve=R(ae,ce.getParentNode()),K=y(ae,pe);return ue(ce,pe,de,{processor:(he,ye)=>{let Ce=Fe(),Ie=he.getValue();if(Ie.children.length===2&&Ie.children[1].type==="html"&&Ie.children[0].position.start.column!==Ie.children[1].position.start.column)return [Ce,Y(he,pe,de,Ce)];return [Ce,w(" ".repeat(Ce.length),Y(he,pe,de,Ce))];function Fe(){let me=ae.ordered?(ye===0?ae.start:K?1:ae.start+ye)+(ve%2===0?". ":") "):ve%2===0?"- ":"* ";return ae.isAligned||ae.hasIndentedCodeblock?H(me,pe):me}}})}case"thematicBreak":{let ve=ee(ce,"list");return ve===-1?"---":R(ce.getParentNode(ve),ce.getParentNode(ve+1))%2===0?"***":"---"}case"linkReference":return ["[",ue(ce,pe,de),"]",ae.referenceType==="full"?["[",ae.identifier,"]"]:ae.referenceType==="collapsed"?"[]":""];case"imageReference":switch(ae.referenceType){case"full":return ["![",ae.alt||"","][",ae.identifier,"]"];default:return ["![",ae.alt,"]",ae.referenceType==="collapsed"?"[]":""]}case"definition":{let ve=pe.proseWrap==="always"?c:" ";return A(["[",ae.identifier,"]:",T([ve,ge(ae.url),ae.title===null?"":[ve,Ae(ae.title,pe,!1)]])])}case"footnote":return ["[^",ue(ce,pe,de),"]"];case"footnoteReference":return ["[^",ae.identifier,"]"];case"footnoteDefinition":{let ve=ce.getParentNode().children[ce.getName()+1],K=ae.children.length===1&&ae.children[0].type==="paragraph"&&(pe.proseWrap==="never"||pe.proseWrap==="preserve"&&ae.children[0].position.start.line===ae.children[0].position.end.line);return ["[^",ae.identifier,"]: ",K?ue(ce,pe,de):A([w(" ".repeat(4),ue(ce,pe,de,{processor:(he,ye)=>ye===0?A([p,de()]):de()})),ve&&ve.type==="footnoteDefinition"?p:""])]}case"table":return W(ce,pe,de);case"tableCell":return ue(ce,pe,de);case"break":return /\s/.test(pe.originalText[ae.position.start.offset])?["  ",m(v)]:["\\",d];case"liquidNode":return I(ae.value,d);case"importExport":return [ae.value,d];case"esComment":return ["{/* ",ae.value," */}"];case"jsx":return ae.value;case"math":return ["$$",d,ae.value?[...I(ae.value,d),d]:"","$$"];case"inlineMath":return pe.originalText.slice(D(ae),g(ae));case"tableRow":case"listItem":default:throw new Error("Unknown markdown type ".concat(JSON.stringify(ae.type)))}}function Y(ce,pe,de,ae){let ve=ce.getValue(),K=ve.checked===null?"":ve.checked?"[x] ":"[ ] ";return [K,ue(ce,pe,de,{processor:(he,ye)=>{if(ye===0&&he.getValue().type!=="list")return w(" ".repeat(K.length),de());let Ce=" ".repeat(Ne(pe.tabWidth-ae.length,0,3));return [Ce,w(Ce,de())]}})]}function H(ce,pe){let de=ae();return ce+" ".repeat(de>=4?0:de);function ae(){let ve=ce.length%pe.tabWidth;return ve===0?0:pe.tabWidth-ve}}function R(ce,pe){return Q(ce,pe,de=>de.ordered===ce.ordered)}function Q(ce,pe,de){let ae=-1;for(let ve of pe.children)if(ve.type===ce.type&&de(ve)?ae++:ae=-1,ve===ce)return ae}function ee(ce,pe){let de=Array.isArray(pe)?pe:[pe],ae=-1,ve;for(;ve=ce.getParentNode(++ae);)if(de.includes(ve.type))return ae;return -1}function te(ce,pe){let de=ee(ce,pe);return de===-1?null:ce.getParentNode(de)}function oe(ce,pe,de){if(de.proseWrap==="preserve"&&pe===`
	`)return d;let ae=de.proseWrap==="always"&&!te(ce,$);return pe!==""?ae?c:" ":ae?p:""}function W(ce,pe,de){let ae=ce.getValue(),ve=[],K=ce.map(me=>me.map((_,J)=>{let ne=k(de(),pe).formatted,Ee=r(ne);return ve[J]=Math.max(ve[J]||3,Ee),{text:ne,width:Ee}},"children"),"children"),he=Ce(!1);if(pe.proseWrap!=="never")return [i,he];let ye=Ce(!0);return [i,A(f(ye,he))];function Ce(me){let _=[Fe(K[0],me),Ie(me)];return K.length>1&&_.push(o(S,K.slice(1).map(J=>Fe(J,me)))),o(S,_)}function Ie(me){let _=ve.map((J,ne)=>{let Ee=ae.align[ne],We=Ee==="center"||Ee==="left"?":":"-",Be=Ee==="center"||Ee==="right"?":":"-",Pe=me?"-":"-".repeat(J-2);return "".concat(We).concat(Pe).concat(Be)});return "| ".concat(_.join(" | ")," |")}function Fe(me,_){let J=me.map((ne,Ee)=>{let{text:We,width:Be}=ne;if(_)return We;let Pe=ve[Ee]-Be,Se=ae.align[Ee],Qe=0;Se==="right"?Qe=Pe:Se==="center"&&(Qe=Math.floor(Pe/2));let xe=Pe-Qe;return "".concat(" ".repeat(Qe)).concat(We).concat(" ".repeat(xe))});return "| ".concat(J.join(" | ")," |")}}function X(ce,pe,de){let ae=[],ve=null,{children:K}=ce.getValue();for(let[he,ye]of K.entries())switch(ie(ye)){case"start":ve===null&&(ve={index:he,offset:ye.position.end.offset});break;case"end":ve!==null&&(ae.push({start:ve,end:{index:he,offset:ye.position.start.offset}}),ve=null);break;}return ue(ce,pe,de,{processor:(he,ye)=>{if(ae.length>0){let Ce=ae[0];if(ye===Ce.start.index)return [K[Ce.start.index].value,pe.originalText.slice(Ce.start.offset,Ce.end.offset),K[Ce.end.index].value];if(Ce.start.index<ye&&ye<Ce.end.index)return !1;if(ye===Ce.end.index)return ae.shift(),!1}return de()}})}function ue(ce,pe,de){let ae=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},{postprocessor:ve}=ae,K=ae.processor||(()=>de()),he=ce.getValue(),ye=[],Ce;return ce.each((Ie,Fe)=>{let me=Ie.getValue(),_=K(Ie,Fe);if(_!==!1){let J={parts:ye,prevNode:Ce,parentNode:he,options:pe};G(me,J)&&(ye.push(d),Ce&&j.has(Ce.type)||(z(me,J)||U(me,J))&&ye.push(d),U(me,J)&&ye.push(d)),ye.push(_),Ce=me;}},"children"),ve?ve(ye):ye}function De(ce){let pe=ce;for(;u(pe.children);)pe=t(pe.children);return pe}function ie(ce){let pe;if(ce.type==="html")pe=ce.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);else {let de;ce.type==="esComment"?de=ce:ce.type==="paragraph"&&ce.children.length===1&&ce.children[0].type==="esComment"&&(de=ce.children[0]),de&&(pe=de.value.match(/^prettier-ignore(?:-(start|end))?$/));}return pe?pe[1]||"next":!1}function G(ce,pe){let de=pe.parts.length===0,ae=b.includes(ce.type),ve=ce.type==="html"&&L.includes(pe.parentNode.type);return !de&&!ae&&!ve}function z(ce,pe){var de,ae,ve;let he=(pe.prevNode&&pe.prevNode.type)===ce.type&&V.has(ce.type),ye=pe.parentNode.type==="listItem"&&!pe.parentNode.loose,Ce=((de=pe.prevNode)===null||de===void 0?void 0:de.type)==="listItem"&&pe.prevNode.loose,Ie=ie(pe.prevNode)==="next",Fe=ce.type==="html"&&((ae=pe.prevNode)===null||ae===void 0?void 0:ae.type)==="html"&&pe.prevNode.position.end.line+1===ce.position.start.line,me=ce.type==="html"&&pe.parentNode.type==="listItem"&&((ve=pe.prevNode)===null||ve===void 0?void 0:ve.type)==="paragraph"&&pe.prevNode.position.end.line+1===ce.position.start.line;return Ce||!(he||ye||Ie||Fe||me)}function U(ce,pe){let de=pe.prevNode&&pe.prevNode.type==="list",ae=ce.type==="code"&&ce.isIndented;return de&&ae}function le(ce){let pe=te(ce,["linkReference","imageReference"]);return pe&&(pe.type!=="linkReference"||pe.referenceType!=="full")}function ge(ce){let pe=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[],de=[" ",...Array.isArray(pe)?pe:[pe]];return new RegExp(de.map(ae=>"\\".concat(ae)).join("|")).test(ce)?"<".concat(ce,">"):ce}function Ae(ce,pe){let de=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;if(!ce)return "";if(de)return " "+Ae(ce,pe,!1);if(ce=ce.replace(/\\(["')])/g,"$1"),ce.includes('"')&&ce.includes("'")&&!ce.includes(")"))return "(".concat(ce,")");let ae=ce.split("'").length-1,ve=ce.split('"').length-1,K=ae>ve?'"':ve>ae||pe.singleQuote?"'":'"';return ce=ce.replace(/\\/,"\\\\"),ce=ce.replace(new RegExp("(".concat(K,")"),"g"),"\\$1"),"".concat(K).concat(ce).concat(K)}function Ne(ce,pe,de){return ce<pe?pe:ce>de?de:ce}function ke(ce){let pe=Number(ce.getName());if(pe===0)return !1;let de=ce.getParentNode().children[pe-1];return ie(de)==="next"}n.exports={preprocess:F,print:q,embed:P,massageAstNode:l,hasPrettierIgnore:ke,insertPragma:C};}}),Gd=Z({"src/language-markdown/options.js"(e,n){re();var t=Ot();n.exports={proseWrap:t.proseWrap,singleQuote:t.singleQuote};}}),Jd=Z({"src/language-markdown/parsers.js"(){re();}}),da=Z({"node_modules/linguist-languages/data/Markdown.json"(e,n){n.exports={name:"Markdown",type:"prose",color:"#083fa1",aliases:["pandoc"],aceMode:"markdown",codemirrorMode:"gfm",codemirrorMimeType:"text/x-gfm",wrap:!0,extensions:[".md",".livemd",".markdown",".mdown",".mdwn",".mdx",".mkd",".mkdn",".mkdown",".ronn",".scd",".workbook"],filenames:["contents.lr"],tmScope:"source.gfm",languageId:222};}}),Ud=Z({"src/language-markdown/index.js"(e,n){re();var t=Bt(),s=Hd(),a=Gd(),r=Jd(),u=[t(da(),o=>({since:"1.8.0",parsers:["markdown"],vscodeLanguageIds:["markdown"],filenames:[...o.filenames,"README"],extensions:o.extensions.filter(c=>c!==".mdx")})),t(da(),()=>({name:"MDX",since:"1.15.0",parsers:["mdx"],vscodeLanguageIds:["mdx"],filenames:[],extensions:[".mdx"]}))],i={mdast:s};n.exports={languages:u,options:a,printers:i,parsers:r};}}),zd=Z({"src/language-html/clean.js"(e,n){re();var{isFrontMatterNode:t}=Ue(),s=new Set(["sourceSpan","startSourceSpan","endSourceSpan","nameSpan","valueSpan"]);function a(r,u){if(r.type==="text"||r.type==="comment"||t(r)||r.type==="yaml"||r.type==="toml")return null;r.type==="attribute"&&delete u.value,r.type==="docType"&&delete u.value;}a.ignoredProperties=s,n.exports=a;}}),Xd=Z({"src/language-html/constants.evaluate.js"(e,n){n.exports={CSS_DISPLAY_TAGS:{area:"none",base:"none",basefont:"none",datalist:"none",head:"none",link:"none",meta:"none",noembed:"none",noframes:"none",param:"block",rp:"none",script:"block",source:"block",style:"none",template:"inline",track:"block",title:"none",html:"block",body:"block",address:"block",blockquote:"block",center:"block",div:"block",figure:"block",figcaption:"block",footer:"block",form:"block",header:"block",hr:"block",legend:"block",listing:"block",main:"block",p:"block",plaintext:"block",pre:"block",xmp:"block",slot:"contents",ruby:"ruby",rt:"ruby-text",article:"block",aside:"block",h1:"block",h2:"block",h3:"block",h4:"block",h5:"block",h6:"block",hgroup:"block",nav:"block",section:"block",dir:"block",dd:"block",dl:"block",dt:"block",ol:"block",ul:"block",li:"list-item",table:"table",caption:"table-caption",colgroup:"table-column-group",col:"table-column",thead:"table-header-group",tbody:"table-row-group",tfoot:"table-footer-group",tr:"table-row",td:"table-cell",th:"table-cell",fieldset:"block",button:"inline-block",details:"block",summary:"block",dialog:"block",meter:"inline-block",progress:"inline-block",object:"inline-block",video:"inline-block",audio:"inline-block",select:"inline-block",option:"block",optgroup:"block"},CSS_DISPLAY_DEFAULT:"inline",CSS_WHITE_SPACE_TAGS:{listing:"pre",plaintext:"pre",pre:"pre",xmp:"pre",nobr:"nowrap",table:"initial",textarea:"pre-wrap"},CSS_WHITE_SPACE_DEFAULT:"normal"};}}),Kd=Z({"src/language-html/utils/is-unknown-namespace.js"(e,n){re();function t(s){return s.type==="element"&&!s.hasExplicitNamespace&&!["html","svg"].includes(s.namespace)}n.exports=t;}}),qt=Z({"src/language-html/utils/index.js"(e,n){re();var{inferParserByLanguage:t,isFrontMatterNode:s}=Ue(),{builders:{line:a,hardline:r,join:u},utils:{getDocParts:i,replaceTextEndOfLine:o}}=Oe(),{CSS_DISPLAY_TAGS:c,CSS_DISPLAY_DEFAULT:v,CSS_WHITE_SPACE_TAGS:m,CSS_WHITE_SPACE_DEFAULT:d}=Xd(),p=Kd(),f=new Set(["	",`
	`,"\f","\r"," "]),h=_=>_.replace(/^[\t\n\f\r ]+/,""),w=_=>_.replace(/[\t\n\f\r ]+$/,""),T=_=>h(w(_)),A=_=>_.replace(/^[\t\f\r ]*\n/g,""),S=_=>A(w(_)),B=_=>_.split(/[\t\n\f\r ]+/),I=_=>_.match(/^[\t\n\f\r ]*/)[0],k=_=>{let[,J,ne,Ee]=_.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);return {leadingWhitespace:J,trailingWhitespace:Ee,text:ne}},P=_=>/[\t\n\f\r ]/.test(_);function C(_,J){return !!(_.type==="ieConditionalComment"&&_.lastChild&&!_.lastChild.isSelfClosing&&!_.lastChild.endSourceSpan||_.type==="ieConditionalComment"&&!_.complete||le(_)&&_.children.some(ne=>ne.type!=="text"&&ne.type!=="interpolation")||ye(_,J)&&!l(_)&&_.type!=="interpolation")}function D(_){return _.type==="attribute"||!_.parent||!_.prev?!1:g(_.prev)}function g(_){return _.type==="comment"&&_.value.trim()==="prettier-ignore"}function F(_){return _.type==="text"||_.type==="comment"}function l(_){return _.type==="element"&&(_.fullName==="script"||_.fullName==="style"||_.fullName==="svg:style"||p(_)&&(_.name==="script"||_.name==="style"))}function E(_){return _.children&&!l(_)}function y(_){return l(_)||_.type==="interpolation"||N(_)}function N(_){return ke(_).startsWith("pre")}function x(_,J){let ne=Ee();if(ne&&!_.prev&&_.parent&&_.parent.tagDefinition&&_.parent.tagDefinition.ignoreFirstLf)return _.type==="interpolation";return ne;function Ee(){return s(_)?!1:(_.type==="text"||_.type==="interpolation")&&_.prev&&(_.prev.type==="text"||_.prev.type==="interpolation")?!0:!_.parent||_.parent.cssDisplay==="none"?!1:le(_.parent)?!0:!(!_.prev&&(_.parent.type==="root"||le(_)&&_.parent||l(_.parent)||K(_.parent,J)||!De(_.parent.cssDisplay))||_.prev&&!z(_.prev.cssDisplay))}}function b(_,J){return s(_)?!1:(_.type==="text"||_.type==="interpolation")&&_.next&&(_.next.type==="text"||_.next.type==="interpolation")?!0:!_.parent||_.parent.cssDisplay==="none"?!1:le(_.parent)?!0:!(!_.next&&(_.parent.type==="root"||le(_)&&_.parent||l(_.parent)||K(_.parent,J)||!ie(_.parent.cssDisplay))||_.next&&!G(_.next.cssDisplay))}function L(_){return U(_.cssDisplay)&&!l(_)}function M(_){return s(_)||_.next&&_.sourceSpan.end&&_.sourceSpan.end.line+1<_.next.sourceSpan.start.line}function j(_){return $(_)||_.type==="element"&&_.children.length>0&&(["body","script","style"].includes(_.name)||_.children.some(J=>te(J)))||_.firstChild&&_.firstChild===_.lastChild&&_.firstChild.type!=="text"&&H(_.firstChild)&&(!_.lastChild.isTrailingSpaceSensitive||R(_.lastChild))}function $(_){return _.type==="element"&&_.children.length>0&&(["html","head","ul","ol","select"].includes(_.name)||_.cssDisplay.startsWith("table")&&_.cssDisplay!=="table-cell")}function V(_){return Q(_)||_.prev&&q(_.prev)||Y(_)}function q(_){return Q(_)||_.type==="element"&&_.fullName==="br"||Y(_)}function Y(_){return H(_)&&R(_)}function H(_){return _.hasLeadingSpaces&&(_.prev?_.prev.sourceSpan.end.line<_.sourceSpan.start.line:_.parent.type==="root"||_.parent.startSourceSpan.end.line<_.sourceSpan.start.line)}function R(_){return _.hasTrailingSpaces&&(_.next?_.next.sourceSpan.start.line>_.sourceSpan.end.line:_.parent.type==="root"||_.parent.endSourceSpan&&_.parent.endSourceSpan.start.line>_.sourceSpan.end.line)}function Q(_){switch(_.type){case"ieConditionalComment":case"comment":case"directive":return !0;case"element":return ["script","select"].includes(_.name)}return !1}function ee(_){return _.lastChild?ee(_.lastChild):_}function te(_){return _.children&&_.children.some(J=>J.type!=="text")}function oe(_){let{type:J,lang:ne}=_.attrMap;if(J==="module"||J==="text/javascript"||J==="text/babel"||J==="application/javascript"||ne==="jsx")return "babel";if(J==="application/x-typescript"||ne==="ts"||ne==="tsx")return "typescript";if(J==="text/markdown")return "markdown";if(J==="text/html")return "html";if(J&&(J.endsWith("json")||J.endsWith("importmap"))||J==="speculationrules")return "json";if(J==="text/x-handlebars-template")return "glimmer"}function W(_,J){let{lang:ne}=_.attrMap;if(!ne||ne==="postcss"||ne==="css")return "css";if(ne==="scss")return "scss";if(ne==="less")return "less";if(ne==="stylus")return t("stylus",J)}function X(_,J){if(_.name==="script"&&!_.attrMap.src)return !_.attrMap.lang&&!_.attrMap.type?"babel":oe(_);if(_.name==="style")return W(_,J);if(J&&ye(_,J))return oe(_)||!("src"in _.attrMap)&&t(_.attrMap.lang,J)}function ue(_){return _==="block"||_==="list-item"||_.startsWith("table")}function De(_){return !ue(_)&&_!=="inline-block"}function ie(_){return !ue(_)&&_!=="inline-block"}function G(_){return !ue(_)}function z(_){return !ue(_)}function U(_){return !ue(_)&&_!=="inline-block"}function le(_){return ke(_).startsWith("pre")}function ge(_,J){let ne=0;for(let Ee=_.stack.length-1;Ee>=0;Ee--){let We=_.stack[Ee];We&&typeof We=="object"&&!Array.isArray(We)&&J(We)&&ne++;}return ne}function Ae(_,J){let ne=_;for(;ne;){if(J(ne))return !0;ne=ne.parent;}return !1}function Ne(_,J){if(_.prev&&_.prev.type==="comment"){let Ee=_.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);if(Ee)return Ee[1]}let ne=!1;if(_.type==="element"&&_.namespace==="svg")if(Ae(_,Ee=>Ee.fullName==="svg:foreignObject"))ne=!0;else return _.name==="svg"?"inline-block":"block";switch(J.htmlWhitespaceSensitivity){case"strict":return "inline";case"ignore":return "block";default:return J.parser==="vue"&&_.parent&&_.parent.type==="root"?"block":_.type==="element"&&(!_.namespace||ne||p(_))&&c[_.name]||v}}function ke(_){return _.type==="element"&&(!_.namespace||p(_))&&m[_.name]||d}function ce(_){let J=Number.POSITIVE_INFINITY;for(let ne of _.split(`
	`)){if(ne.length===0)continue;if(!f.has(ne[0]))return 0;let Ee=I(ne).length;ne.length!==Ee&&Ee<J&&(J=Ee);}return J===Number.POSITIVE_INFINITY?0:J}function pe(_){let J=arguments.length>1&&arguments[1]!==void 0?arguments[1]:ce(_);return J===0?_:_.split(`
	`).map(ne=>ne.slice(J)).join(`
	`)}function de(_,J){let ne=0;for(let Ee=0;Ee<_.length;Ee++)_[Ee]===J&&ne++;return ne}function ae(_){return _.replace(/&apos;/g,"'").replace(/&quot;/g,'"')}var ve=new Set(["template","style","script"]);function K(_,J){return he(_,J)&&!ve.has(_.fullName)}function he(_,J){return J.parser==="vue"&&_.type==="element"&&_.parent.type==="root"&&_.fullName.toLowerCase()!=="html"}function ye(_,J){return he(_,J)&&(K(_,J)||_.attrMap.lang&&_.attrMap.lang!=="html")}function Ce(_){let J=_.fullName;return J.charAt(0)==="#"||J==="slot-scope"||J==="v-slot"||J.startsWith("v-slot:")}function Ie(_,J){let ne=_.parent;if(!he(ne,J))return !1;let Ee=ne.fullName,We=_.fullName;return Ee==="script"&&We==="setup"||Ee==="style"&&We==="vars"}function Fe(_){let J=arguments.length>1&&arguments[1]!==void 0?arguments[1]:_.value;return _.parent.isWhitespaceSensitive?_.parent.isIndentationSensitive?o(J):o(pe(S(J)),r):i(u(a,B(J)))}function me(_,J){return he(_,J)&&_.name==="script"}n.exports={htmlTrim:T,htmlTrimPreserveIndentation:S,hasHtmlWhitespace:P,getLeadingAndTrailingHtmlWhitespace:k,canHaveInterpolation:E,countChars:de,countParents:ge,dedentString:pe,forceBreakChildren:$,forceBreakContent:j,forceNextEmptyLine:M,getLastDescendant:ee,getNodeCssStyleDisplay:Ne,getNodeCssStyleWhiteSpace:ke,hasPrettierIgnore:D,inferScriptParser:X,isVueCustomBlock:K,isVueNonHtmlBlock:ye,isVueScriptTag:me,isVueSlotAttribute:Ce,isVueSfcBindingsAttribute:Ie,isVueSfcBlock:he,isDanglingSpaceSensitiveNode:L,isIndentationSensitiveNode:N,isLeadingSpaceSensitiveNode:x,isPreLikeNode:le,isScriptLikeTag:l,isTextLikeNode:F,isTrailingSpaceSensitiveNode:b,isWhitespaceSensitiveNode:y,isUnknownNamespace:p,preferHardlineAsLeadingSpaces:V,preferHardlineAsTrailingSpaces:q,shouldPreserveContent:C,unescapeQuoteEntities:ae,getTextValueParts:Fe};}}),Yd=Z({"node_modules/angular-html-parser/lib/compiler/src/chars.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0}),e.$EOF=0,e.$BSPACE=8,e.$TAB=9,e.$LF=10,e.$VTAB=11,e.$FF=12,e.$CR=13,e.$SPACE=32,e.$BANG=33,e.$DQ=34,e.$HASH=35,e.$$=36,e.$PERCENT=37,e.$AMPERSAND=38,e.$SQ=39,e.$LPAREN=40,e.$RPAREN=41,e.$STAR=42,e.$PLUS=43,e.$COMMA=44,e.$MINUS=45,e.$PERIOD=46,e.$SLASH=47,e.$COLON=58,e.$SEMICOLON=59,e.$LT=60,e.$EQ=61,e.$GT=62,e.$QUESTION=63,e.$0=48,e.$7=55,e.$9=57,e.$A=65,e.$E=69,e.$F=70,e.$X=88,e.$Z=90,e.$LBRACKET=91,e.$BACKSLASH=92,e.$RBRACKET=93,e.$CARET=94,e.$_=95,e.$a=97,e.$b=98,e.$e=101,e.$f=102,e.$n=110,e.$r=114,e.$t=116,e.$u=117,e.$v=118,e.$x=120,e.$z=122,e.$LBRACE=123,e.$BAR=124,e.$RBRACE=125,e.$NBSP=160,e.$PIPE=124,e.$TILDA=126,e.$AT=64,e.$BT=96;function n(i){return i>=e.$TAB&&i<=e.$SPACE||i==e.$NBSP}e.isWhitespace=n;function t(i){return e.$0<=i&&i<=e.$9}e.isDigit=t;function s(i){return i>=e.$a&&i<=e.$z||i>=e.$A&&i<=e.$Z}e.isAsciiLetter=s;function a(i){return i>=e.$a&&i<=e.$f||i>=e.$A&&i<=e.$F||t(i)}e.isAsciiHexDigit=a;function r(i){return i===e.$LF||i===e.$CR}e.isNewLine=r;function u(i){return e.$0<=i&&i<=e.$7}e.isOctalDigit=u;}}),Qd=Z({"node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=class{constructor(s,a,r){this.filePath=s,this.name=a,this.members=r;}assertNoMembers(){if(this.members.length)throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this),"."))}};e.StaticSymbol=n;var t=class{constructor(){this.cache=new Map;}get(s,a,r){r=r||[];let u=r.length?".".concat(r.join(".")):"",i='"'.concat(s,'".').concat(a).concat(u),o=this.cache.get(i);return o||(o=new n(s,a,r),this.cache.set(i,o)),o}};e.StaticSymbolCache=t;}}),Zd=Z({"node_modules/angular-html-parser/lib/compiler/src/util.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=/-+([a-z0-9])/g;function t(l){return l.replace(n,function(){for(var E=arguments.length,y=new Array(E),N=0;N<E;N++)y[N]=arguments[N];return y[1].toUpperCase()})}e.dashCaseToCamelCase=t;function s(l,E){return r(l,":",E)}e.splitAtColon=s;function a(l,E){return r(l,".",E)}e.splitAtPeriod=a;function r(l,E,y){let N=l.indexOf(E);return N==-1?y:[l.slice(0,N).trim(),l.slice(N+1).trim()]}function u(l,E,y){return Array.isArray(l)?E.visitArray(l,y):A(l)?E.visitStringMap(l,y):l==null||typeof l=="string"||typeof l=="number"||typeof l=="boolean"?E.visitPrimitive(l,y):E.visitOther(l,y)}e.visitValue=u;function i(l){return l!=null}e.isDefined=i;function o(l){return l===void 0?null:l}e.noUndefined=o;var c=class{visitArray(l,E){return l.map(y=>u(y,this,E))}visitStringMap(l,E){let y={};return Object.keys(l).forEach(N=>{y[N]=u(l[N],this,E);}),y}visitPrimitive(l,E){return l}visitOther(l,E){return l}};e.ValueTransformer=c,e.SyncAsync={assertSync:l=>{if(k(l))throw new Error("Illegal state: value cannot be a promise");return l},then:(l,E)=>k(l)?l.then(E):E(l),all:l=>l.some(k)?Promise.all(l):l};function v(l){throw new Error("Internal Error: ".concat(l))}e.error=v;function m(l,E){let y=Error(l);return y[d]=!0,E&&(y[p]=E),y}e.syntaxError=m;var d="ngSyntaxError",p="ngParseErrors";function f(l){return l[d]}e.isSyntaxError=f;function h(l){return l[p]||[]}e.getParseErrors=h;function w(l){return l.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")}e.escapeRegExp=w;var T=Object.getPrototypeOf({});function A(l){return typeof l=="object"&&l!==null&&Object.getPrototypeOf(l)===T}function S(l){let E="";for(let y=0;y<l.length;y++){let N=l.charCodeAt(y);if(N>=55296&&N<=56319&&l.length>y+1){let x=l.charCodeAt(y+1);x>=56320&&x<=57343&&(y++,N=(N-55296<<10)+x-56320+65536);}N<=127?E+=String.fromCharCode(N):N<=2047?E+=String.fromCharCode(N>>6&31|192,N&63|128):N<=65535?E+=String.fromCharCode(N>>12|224,N>>6&63|128,N&63|128):N<=2097151&&(E+=String.fromCharCode(N>>18&7|240,N>>12&63|128,N>>6&63|128,N&63|128));}return E}e.utf8Encode=S;function B(l){if(typeof l=="string")return l;if(l instanceof Array)return "["+l.map(B).join(", ")+"]";if(l==null)return ""+l;if(l.overriddenName)return "".concat(l.overriddenName);if(l.name)return "".concat(l.name);if(!l.toString)return "object";let E=l.toString();if(E==null)return ""+E;let y=E.indexOf(`
	`);return y===-1?E:E.substring(0,y)}e.stringify=B;function I(l){return typeof l=="function"&&l.hasOwnProperty("__forward_ref__")?l():l}e.resolveForwardRef=I;function k(l){return !!l&&typeof l.then=="function"}e.isPromise=k;var P=class{constructor(l){this.full=l;let E=l.split(".");this.major=E[0],this.minor=E[1],this.patch=E.slice(2).join(".");}};e.Version=P;var C=typeof window<"u"&&window,D=typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self,g=typeof globalThis<"u"&&globalThis,F=g||C||D;e.global=F;}}),eg=Z({"node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=Qd(),t=Zd(),s=/^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;function a(y){return y.replace(/\W/g,"_")}e.sanitizeIdentifier=a;var r=0;function u(y){if(!y||!y.reference)return null;let N=y.reference;if(N instanceof n.StaticSymbol)return N.name;if(N.__anonymousType)return N.__anonymousType;let x=t.stringify(N);return x.indexOf("(")>=0?(x="anonymous_".concat(r++),N.__anonymousType=x):x=a(x),x}e.identifierName=u;function i(y){let N=y.reference;return N instanceof n.StaticSymbol?N.filePath:"./".concat(t.stringify(N))}e.identifierModuleUrl=i;function o(y,N){return "View_".concat(u({reference:y}),"_").concat(N)}e.viewClassName=o;function c(y){return "RenderType_".concat(u({reference:y}))}e.rendererTypeName=c;function v(y){return "HostView_".concat(u({reference:y}))}e.hostViewClassName=v;function m(y){return "".concat(u({reference:y}),"NgFactory")}e.componentFactoryName=m;var d;(function(y){y[y.Pipe=0]="Pipe",y[y.Directive=1]="Directive",y[y.NgModule=2]="NgModule",y[y.Injectable=3]="Injectable";})(d=e.CompileSummaryKind||(e.CompileSummaryKind={}));function p(y){return y.value!=null?a(y.value):u(y.identifier)}e.tokenName=p;function f(y){return y.identifier!=null?y.identifier.reference:y.value}e.tokenReference=f;var h=class{constructor(){let{moduleUrl:y,styles:N,styleUrls:x}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.moduleUrl=y||null,this.styles=k(N),this.styleUrls=k(x);}};e.CompileStylesheetMetadata=h;var w=class{constructor(y){let{encapsulation:N,template:x,templateUrl:b,htmlAst:L,styles:M,styleUrls:j,externalStylesheets:$,animations:V,ngContentSelectors:q,interpolation:Y,isInline:H,preserveWhitespaces:R}=y;if(this.encapsulation=N,this.template=x,this.templateUrl=b,this.htmlAst=L,this.styles=k(M),this.styleUrls=k(j),this.externalStylesheets=k($),this.animations=V?C(V):[],this.ngContentSelectors=q||[],Y&&Y.length!=2)throw new Error("'interpolation' should have a start and an end symbol.");this.interpolation=Y,this.isInline=H,this.preserveWhitespaces=R;}toSummary(){return {ngContentSelectors:this.ngContentSelectors,encapsulation:this.encapsulation,styles:this.styles,animations:this.animations}}};e.CompileTemplateMetadata=w;var T=class{static create(y){let{isHost:N,type:x,isComponent:b,selector:L,exportAs:M,changeDetection:j,inputs:$,outputs:V,host:q,providers:Y,viewProviders:H,queries:R,guards:Q,viewQueries:ee,entryComponents:te,template:oe,componentViewType:W,rendererType:X,componentFactory:ue}=y,De={},ie={},G={};q!=null&&Object.keys(q).forEach(le=>{let ge=q[le],Ae=le.match(s);Ae===null?G[le]=ge:Ae[1]!=null?ie[Ae[1]]=ge:Ae[2]!=null&&(De[Ae[2]]=ge);});let z={};$!=null&&$.forEach(le=>{let ge=t.splitAtColon(le,[le,le]);z[ge[0]]=ge[1];});let U={};return V!=null&&V.forEach(le=>{let ge=t.splitAtColon(le,[le,le]);U[ge[0]]=ge[1];}),new T({isHost:N,type:x,isComponent:!!b,selector:L,exportAs:M,changeDetection:j,inputs:z,outputs:U,hostListeners:De,hostProperties:ie,hostAttributes:G,providers:Y,viewProviders:H,queries:R,guards:Q,viewQueries:ee,entryComponents:te,template:oe,componentViewType:W,rendererType:X,componentFactory:ue})}constructor(y){let{isHost:N,type:x,isComponent:b,selector:L,exportAs:M,changeDetection:j,inputs:$,outputs:V,hostListeners:q,hostProperties:Y,hostAttributes:H,providers:R,viewProviders:Q,queries:ee,guards:te,viewQueries:oe,entryComponents:W,template:X,componentViewType:ue,rendererType:De,componentFactory:ie}=y;this.isHost=!!N,this.type=x,this.isComponent=b,this.selector=L,this.exportAs=M,this.changeDetection=j,this.inputs=$,this.outputs=V,this.hostListeners=q,this.hostProperties=Y,this.hostAttributes=H,this.providers=k(R),this.viewProviders=k(Q),this.queries=k(ee),this.guards=te,this.viewQueries=k(oe),this.entryComponents=k(W),this.template=X,this.componentViewType=ue,this.rendererType=De,this.componentFactory=ie;}toSummary(){return {summaryKind:d.Directive,type:this.type,isComponent:this.isComponent,selector:this.selector,exportAs:this.exportAs,inputs:this.inputs,outputs:this.outputs,hostListeners:this.hostListeners,hostProperties:this.hostProperties,hostAttributes:this.hostAttributes,providers:this.providers,viewProviders:this.viewProviders,queries:this.queries,guards:this.guards,viewQueries:this.viewQueries,entryComponents:this.entryComponents,changeDetection:this.changeDetection,template:this.template&&this.template.toSummary(),componentViewType:this.componentViewType,rendererType:this.rendererType,componentFactory:this.componentFactory}}};e.CompileDirectiveMetadata=T;var A=class{constructor(y){let{type:N,name:x,pure:b}=y;this.type=N,this.name=x,this.pure=!!b;}toSummary(){return {summaryKind:d.Pipe,type:this.type,name:this.name,pure:this.pure}}};e.CompilePipeMetadata=A;var S=class{};e.CompileShallowModuleMetadata=S;var B=class{constructor(y){let{type:N,providers:x,declaredDirectives:b,exportedDirectives:L,declaredPipes:M,exportedPipes:j,entryComponents:$,bootstrapComponents:V,importedModules:q,exportedModules:Y,schemas:H,transitiveModule:R,id:Q}=y;this.type=N||null,this.declaredDirectives=k(b),this.exportedDirectives=k(L),this.declaredPipes=k(M),this.exportedPipes=k(j),this.providers=k(x),this.entryComponents=k($),this.bootstrapComponents=k(V),this.importedModules=k(q),this.exportedModules=k(Y),this.schemas=k(H),this.id=Q||null,this.transitiveModule=R||null;}toSummary(){let y=this.transitiveModule;return {summaryKind:d.NgModule,type:this.type,entryComponents:y.entryComponents,providers:y.providers,modules:y.modules,exportedDirectives:y.exportedDirectives,exportedPipes:y.exportedPipes}}};e.CompileNgModuleMetadata=B;var I=class{constructor(){this.directivesSet=new Set,this.directives=[],this.exportedDirectivesSet=new Set,this.exportedDirectives=[],this.pipesSet=new Set,this.pipes=[],this.exportedPipesSet=new Set,this.exportedPipes=[],this.modulesSet=new Set,this.modules=[],this.entryComponentsSet=new Set,this.entryComponents=[],this.providers=[];}addProvider(y,N){this.providers.push({provider:y,module:N});}addDirective(y){this.directivesSet.has(y.reference)||(this.directivesSet.add(y.reference),this.directives.push(y));}addExportedDirective(y){this.exportedDirectivesSet.has(y.reference)||(this.exportedDirectivesSet.add(y.reference),this.exportedDirectives.push(y));}addPipe(y){this.pipesSet.has(y.reference)||(this.pipesSet.add(y.reference),this.pipes.push(y));}addExportedPipe(y){this.exportedPipesSet.has(y.reference)||(this.exportedPipesSet.add(y.reference),this.exportedPipes.push(y));}addModule(y){this.modulesSet.has(y.reference)||(this.modulesSet.add(y.reference),this.modules.push(y));}addEntryComponent(y){this.entryComponentsSet.has(y.componentType)||(this.entryComponentsSet.add(y.componentType),this.entryComponents.push(y));}};e.TransitiveCompileNgModuleMetadata=I;function k(y){return y||[]}var P=class{constructor(y,N){let{useClass:x,useValue:b,useExisting:L,useFactory:M,deps:j,multi:$}=N;this.token=y,this.useClass=x||null,this.useValue=b,this.useExisting=L,this.useFactory=M||null,this.dependencies=j||null,this.multi=!!$;}};e.ProviderMeta=P;function C(y){return y.reduce((N,x)=>{let b=Array.isArray(x)?C(x):x;return N.concat(b)},[])}e.flatten=C;function D(y){return y.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/,"ng:///")}function g(y,N,x){let b;return x.isInline?N.type.reference instanceof n.StaticSymbol?b="".concat(N.type.reference.filePath,".").concat(N.type.reference.name,".html"):b="".concat(u(y),"/").concat(u(N.type),".html"):b=x.templateUrl,N.type.reference instanceof n.StaticSymbol?b:D(b)}e.templateSourceUrl=g;function F(y,N){let x=y.moduleUrl.split(/\/\\/g),b=x[x.length-1];return D("css/".concat(N).concat(b,".ngstyle.js"))}e.sharedStylesheetJitUrl=F;function l(y){return D("".concat(u(y.type),"/module.ngfactory.js"))}e.ngModuleJitUrl=l;function E(y,N){return D("".concat(u(y),"/").concat(u(N.type),".ngfactory.js"))}e.templateJitUrl=E;}}),tg=Z({"node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e){re(),Object.defineProperty(e,"__esModule",{value:!0});var n=Yd(),t=eg(),s=class{constructor(v,m,d,p){this.file=v,this.offset=m,this.line=d,this.col=p;}toString(){return this.offset!=null?"".concat(this.file.url,"@").concat(this.line,":").concat(this.col):this.file.url}moveBy(v){let m=this.file.content,d=m.length,p=this.offset,f=this.line,h=this.col;for(;p>0&&v<0;)if(p--,v++,m.charCodeAt(p)==n.$LF){f--;let T=m.substr(0,p-1).lastIndexOf(String.fromCharCode(n.$LF));h=T>0?p-T:p;}else h--;for(;p<d&&v>0;){let w=m.charCodeAt(p);p++,v--,w==n.$LF?(f++,h=0):h++;}return new s(this.file,p,f,h)}getContext(v,m){let d=this.file.content,p=this.offset;if(p!=null){p>d.length-1&&(p=d.length-1);let f=p,h=0,w=0;for(;h<v&&p>0&&(p--,h++,!(d[p]==`
	`&&++w==m)););for(h=0,w=0;h<v&&f<d.length-1&&(f++,h++,!(d[f]==`
	`&&++w==m)););return {before:d.substring(p,this.offset),after:d.substring(this.offset,f+1)}}return null}};e.ParseLocation=s;var a=class{constructor(v,m){this.content=v,this.url=m;}};e.ParseSourceFile=a;var r=class{constructor(v,m){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;this.start=v,this.end=m,this.details=d;}toString(){return this.start.file.content.substring(this.start.offset,this.end.offset)}};e.ParseSourceSpan=r,e.EMPTY_PARSE_LOCATION=new s(new a("",""),0,0,0),e.EMPTY_SOURCE_SPAN=new r(e.EMPTY_PARSE_LOCATION,e.EMPTY_PARSE_LOCATION);var u;(function(v){v[v.WARNING=0]="WARNING",v[v.ERROR=1]="ERROR";})(u=e.ParseErrorLevel||(e.ParseErrorLevel={}));var i=class{constructor(v,m){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:u.ERROR;this.span=v,this.msg=m,this.level=d;}contextualMessage(){let v=this.span.start.getContext(100,3);return v?"".concat(this.msg,' ("').concat(v.before,"[").concat(u[this.level]," ->]").concat(v.after,'")'):this.msg}toString(){let v=this.span.details?", ".concat(this.span.details):"";return "".concat(this.contextualMessage(),": ").concat(this.span.start).concat(v)}};e.ParseError=i;function o(v,m){let d=t.identifierModuleUrl(m),p=d!=null?"in ".concat(v," ").concat(t.identifierName(m)," in ").concat(d):"in ".concat(v," ").concat(t.identifierName(m)),f=new a("",p);return new r(new s(f,-1,-1,-1),new s(f,-1,-1,-1))}e.typeSourceSpan=o;function c(v,m,d){let p="in ".concat(v," ").concat(m," in ").concat(d),f=new a("",p);return new r(new s(f,-1,-1,-1),new s(f,-1,-1,-1))}e.r3JitTypeSourceSpan=c;}}),rg=Z({"src/language-html/print-preprocess.js"(e,n){re();var{ParseSourceSpan:t}=tg(),{htmlTrim:s,getLeadingAndTrailingHtmlWhitespace:a,hasHtmlWhitespace:r,canHaveInterpolation:u,getNodeCssStyleDisplay:i,isDanglingSpaceSensitiveNode:o,isIndentationSensitiveNode:c,isLeadingSpaceSensitiveNode:v,isTrailingSpaceSensitiveNode:m,isWhitespaceSensitiveNode:d,isVueScriptTag:p}=qt(),f=[w,T,S,I,k,D,P,C,g,B,F];function h(l,E){for(let y of f)y(l,E);return l}function w(l){l.walk(E=>{if(E.type==="element"&&E.tagDefinition.ignoreFirstLf&&E.children.length>0&&E.children[0].type==="text"&&E.children[0].value[0]===`
	`){let y=E.children[0];y.value.length===1?E.removeChild(y):y.value=y.value.slice(1);}});}function T(l){let E=y=>y.type==="element"&&y.prev&&y.prev.type==="ieConditionalStartComment"&&y.prev.sourceSpan.end.offset===y.startSourceSpan.start.offset&&y.firstChild&&y.firstChild.type==="ieConditionalEndComment"&&y.firstChild.sourceSpan.start.offset===y.startSourceSpan.end.offset;l.walk(y=>{if(y.children)for(let N=0;N<y.children.length;N++){let x=y.children[N];if(!E(x))continue;let b=x.prev,L=x.firstChild;y.removeChild(b),N--;let M=new t(b.sourceSpan.start,L.sourceSpan.end),j=new t(M.start,x.sourceSpan.end);x.condition=b.condition,x.sourceSpan=j,x.startSourceSpan=M,x.removeChild(L);}});}function A(l,E,y){l.walk(N=>{if(N.children)for(let x=0;x<N.children.length;x++){let b=N.children[x];if(b.type!=="text"&&!E(b))continue;b.type!=="text"&&(b.type="text",b.value=y(b));let L=b.prev;!L||L.type!=="text"||(L.value+=b.value,L.sourceSpan=new t(L.sourceSpan.start,b.sourceSpan.end),N.removeChild(b),x--);}});}function S(l){return A(l,E=>E.type==="cdata",E=>"<![CDATA[".concat(E.value,"]]>"))}function B(l){let E=y=>y.type==="element"&&y.attrs.length===0&&y.children.length===1&&y.firstChild.type==="text"&&!r(y.children[0].value)&&!y.firstChild.hasLeadingSpaces&&!y.firstChild.hasTrailingSpaces&&y.isLeadingSpaceSensitive&&!y.hasLeadingSpaces&&y.isTrailingSpaceSensitive&&!y.hasTrailingSpaces&&y.prev&&y.prev.type==="text"&&y.next&&y.next.type==="text";l.walk(y=>{if(y.children)for(let N=0;N<y.children.length;N++){let x=y.children[N];if(!E(x))continue;let b=x.prev,L=x.next;b.value+="<".concat(x.rawName,">")+x.firstChild.value+"</".concat(x.rawName,">")+L.value,b.sourceSpan=new t(b.sourceSpan.start,L.sourceSpan.end),b.isTrailingSpaceSensitive=L.isTrailingSpaceSensitive,b.hasTrailingSpaces=L.hasTrailingSpaces,y.removeChild(x),N--,y.removeChild(L);}});}function I(l,E){if(E.parser==="html")return;let y=/{{(.+?)}}/s;l.walk(N=>{if(!!u(N))for(let x of N.children){if(x.type!=="text")continue;let b=x.sourceSpan.start,L=null,M=x.value.split(y);for(let j=0;j<M.length;j++,b=L){let $=M[j];if(j%2===0){L=b.moveBy($.length),$.length>0&&N.insertChildBefore(x,{type:"text",value:$,sourceSpan:new t(b,L)});continue}L=b.moveBy($.length+4),N.insertChildBefore(x,{type:"interpolation",sourceSpan:new t(b,L),children:$.length===0?[]:[{type:"text",value:$,sourceSpan:new t(b.moveBy(2),L.moveBy(-2))}]});}N.removeChild(x);}});}function k(l){l.walk(E=>{if(!E.children)return;if(E.children.length===0||E.children.length===1&&E.children[0].type==="text"&&s(E.children[0].value).length===0){E.hasDanglingSpaces=E.children.length>0,E.children=[];return}let y=d(E),N=c(E);if(!y)for(let x=0;x<E.children.length;x++){let b=E.children[x];if(b.type!=="text")continue;let{leadingWhitespace:L,text:M,trailingWhitespace:j}=a(b.value),$=b.prev,V=b.next;M?(b.value=M,b.sourceSpan=new t(b.sourceSpan.start.moveBy(L.length),b.sourceSpan.end.moveBy(-j.length)),L&&($&&($.hasTrailingSpaces=!0),b.hasLeadingSpaces=!0),j&&(b.hasTrailingSpaces=!0,V&&(V.hasLeadingSpaces=!0))):(E.removeChild(b),x--,(L||j)&&($&&($.hasTrailingSpaces=!0),V&&(V.hasLeadingSpaces=!0)));}E.isWhitespaceSensitive=y,E.isIndentationSensitive=N;});}function P(l){l.walk(E=>{E.isSelfClosing=!E.children||E.type==="element"&&(E.tagDefinition.isVoid||E.startSourceSpan===E.endSourceSpan);});}function C(l,E){l.walk(y=>{y.type==="element"&&(y.hasHtmComponentClosingTag=y.endSourceSpan&&/^<\s*\/\s*\/\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset,y.endSourceSpan.end.offset)));});}function D(l,E){l.walk(y=>{y.cssDisplay=i(y,E);});}function g(l,E){l.walk(y=>{let{children:N}=y;if(!!N){if(N.length===0){y.isDanglingSpaceSensitive=o(y);return}for(let x of N)x.isLeadingSpaceSensitive=v(x,E),x.isTrailingSpaceSensitive=m(x,E);for(let x=0;x<N.length;x++){let b=N[x];b.isLeadingSpaceSensitive=(x===0||b.prev.isTrailingSpaceSensitive)&&b.isLeadingSpaceSensitive,b.isTrailingSpaceSensitive=(x===N.length-1||b.next.isLeadingSpaceSensitive)&&b.isTrailingSpaceSensitive;}}});}function F(l,E){if(E.parser==="vue"){let y=l.children.find(x=>p(x,E));if(!y)return;let{lang:N}=y.attrMap;(N==="ts"||N==="typescript")&&(E.__should_parse_vue_template_with_ts=!0);}}n.exports=h;}}),ng=Z({"src/language-html/pragma.js"(e,n){re();function t(a){return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a)}function s(a){return `<!-- @format -->

	`+a.replace(/^\s*\n/,"")}n.exports={hasPragma:t,insertPragma:s};}}),Yn=Z({"src/language-html/loc.js"(e,n){re();function t(a){return a.sourceSpan.start.offset}function s(a){return a.sourceSpan.end.offset}n.exports={locStart:t,locEnd:s};}}),er=Z({"src/language-html/print/tag.js"(e,n){re();var t=Xt(),{isNonEmptyArray:s}=Ue(),{builders:{indent:a,join:r,line:u,softline:i,hardline:o},utils:{replaceTextEndOfLine:c}}=Oe(),{locStart:v,locEnd:m}=Yn(),{isTextLikeNode:d,getLastDescendant:p,isPreLikeNode:f,hasPrettierIgnore:h,shouldPreserveContent:w,isVueSfcBlock:T}=qt();function A(q,Y){return [q.isSelfClosing?"":S(q,Y),B(q,Y)]}function S(q,Y){return q.lastChild&&l(q.lastChild)?"":[I(q,Y),P(q,Y)]}function B(q,Y){return (q.next?g(q.next):F(q.parent))?"":[C(q,Y),k(q,Y)]}function I(q,Y){return F(q)?C(q.lastChild,Y):""}function k(q,Y){return l(q)?P(q.parent,Y):E(q)?$(q.next):""}function P(q,Y){if(t(!q.isSelfClosing),D(q,Y))return "";switch(q.type){case"ieConditionalComment":return "<!";case"element":if(q.hasHtmComponentClosingTag)return "<//";default:return "</".concat(q.rawName)}}function C(q,Y){if(D(q,Y))return "";switch(q.type){case"ieConditionalComment":case"ieConditionalEndComment":return "[endif]-->";case"ieConditionalStartComment":return "]><!-->";case"interpolation":return "}}";case"element":if(q.isSelfClosing)return "/>";default:return ">"}}function D(q,Y){return !q.isSelfClosing&&!q.endSourceSpan&&(h(q)||w(q.parent,Y))}function g(q){return q.prev&&q.prev.type!=="docType"&&!d(q.prev)&&q.isLeadingSpaceSensitive&&!q.hasLeadingSpaces}function F(q){return q.lastChild&&q.lastChild.isTrailingSpaceSensitive&&!q.lastChild.hasTrailingSpaces&&!d(p(q.lastChild))&&!f(q)}function l(q){return !q.next&&!q.hasTrailingSpaces&&q.isTrailingSpaceSensitive&&d(p(q))}function E(q){return q.next&&!d(q.next)&&d(q)&&q.isTrailingSpaceSensitive&&!q.hasTrailingSpaces}function y(q){let Y=q.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);return Y?Y[1]?Y[1].split(/\s+/):!0:!1}function N(q){return !q.prev&&q.isLeadingSpaceSensitive&&!q.hasLeadingSpaces}function x(q,Y,H){let R=q.getValue();if(!s(R.attrs))return R.isSelfClosing?" ":"";let Q=R.prev&&R.prev.type==="comment"&&y(R.prev.value),ee=typeof Q=="boolean"?()=>Q:Array.isArray(Q)?De=>Q.includes(De.rawName):()=>!1,te=q.map(De=>{let ie=De.getValue();return ee(ie)?c(Y.originalText.slice(v(ie),m(ie))):H()},"attrs"),oe=R.type==="element"&&R.fullName==="script"&&R.attrs.length===1&&R.attrs[0].fullName==="src"&&R.children.length===0,X=Y.singleAttributePerLine&&R.attrs.length>1&&!T(R,Y)?o:u,ue=[a([oe?" ":u,r(X,te)])];return R.firstChild&&N(R.firstChild)||R.isSelfClosing&&F(R.parent)||oe?ue.push(R.isSelfClosing?" ":""):ue.push(Y.bracketSameLine?R.isSelfClosing?" ":"":R.isSelfClosing?u:i),ue}function b(q){return q.firstChild&&N(q.firstChild)?"":V(q)}function L(q,Y,H){let R=q.getValue();return [M(R,Y),x(q,Y,H),R.isSelfClosing?"":b(R)]}function M(q,Y){return q.prev&&E(q.prev)?"":[j(q,Y),$(q)]}function j(q,Y){return N(q)?V(q.parent):g(q)?C(q.prev,Y):""}function $(q){switch(q.type){case"ieConditionalComment":case"ieConditionalStartComment":return "<!--[if ".concat(q.condition);case"ieConditionalEndComment":return "<!--<!";case"interpolation":return "{{";case"docType":return "<!DOCTYPE";case"element":if(q.condition)return "<!--[if ".concat(q.condition,"]><!--><").concat(q.rawName);default:return "<".concat(q.rawName)}}function V(q){switch(t(!q.isSelfClosing),q.type){case"ieConditionalComment":return "]>";case"element":if(q.condition)return "><!--<![endif]-->";default:return ">"}}n.exports={printClosingTag:A,printClosingTagStart:S,printClosingTagStartMarker:P,printClosingTagEndMarker:C,printClosingTagSuffix:k,printClosingTagEnd:B,needsToBorrowLastChildClosingTagEndMarker:F,needsToBorrowParentClosingTagStartMarker:l,needsToBorrowPrevClosingTagEndMarker:g,printOpeningTag:L,printOpeningTagStart:M,printOpeningTagPrefix:j,printOpeningTagStartMarker:$,printOpeningTagEndMarker:V,needsToBorrowNextOpeningTagStartMarker:E,needsToBorrowParentOpeningTagEndMarker:N};}}),ug=Z({"node_modules/parse-srcset/src/parse-srcset.js"(e,n){re(),function(t,s){typeof n=="object"&&n.exports?n.exports=s():t.parseSrcset=s();}(e,function(){return function(t,s){var a=s&&s.logger||console;function r(P){return P===" "||P==="	"||P===`
	`||P==="\f"||P==="\r"}function u(P){var C,D=P.exec(t.substring(S));if(D)return C=D[0],S+=C.length,C}for(var i=t.length,o=/^[ \t\n\r\u000c]+/,c=/^[, \t\n\r\u000c]+/,v=/^[^ \t\n\r\u000c]+/,m=/[,]+$/,d=/^\d+$/,p=/^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,f,h,w,T,A,S=0,B=[];;){if(u(c),S>=i)return B;f=u(v),h=[],f.slice(-1)===","?(f=f.replace(m,""),k()):I();}function I(){for(u(o),w="",T="in descriptor";;){if(A=t.charAt(S),T==="in descriptor")if(r(A))w&&(h.push(w),w="",T="after descriptor");else if(A===","){S+=1,w&&h.push(w),k();return}else if(A==="(")w=w+A,T="in parens";else if(A===""){w&&h.push(w),k();return}else w=w+A;else if(T==="in parens")if(A===")")w=w+A,T="in descriptor";else if(A===""){h.push(w),k();return}else w=w+A;else if(T==="after descriptor"&&!r(A))if(A===""){k();return}else T="in descriptor",S-=1;S+=1;}}function k(){var P=!1,C,D,g,F,l={},E,y,N,x,b;for(F=0;F<h.length;F++)E=h[F],y=E[E.length-1],N=E.substring(0,E.length-1),x=parseInt(N,10),b=parseFloat(N),d.test(N)&&y==="w"?((C||D)&&(P=!0),x===0?P=!0:C=x):p.test(N)&&y==="x"?((C||D||g)&&(P=!0),b<0?P=!0:D=b):d.test(N)&&y==="h"?((g||D)&&(P=!0),x===0?P=!0:g=x):P=!0;P?a&&a.error&&a.error("Invalid srcset descriptor found in '"+t+"' at '"+E+"'."):(l.url=f,C&&(l.w=C),D&&(l.d=D),g&&(l.h=g),B.push(l));}}});}}),sg=Z({"src/language-html/syntax-attribute.js"(e,n){re();var t=ug(),{builders:{ifBreak:s,join:a,line:r}}=Oe();function u(o){let c=t(o,{logger:{error(I){throw new Error(I)}}}),v=c.some(I=>{let{w:k}=I;return k}),m=c.some(I=>{let{h:k}=I;return k}),d=c.some(I=>{let{d:k}=I;return k});if(v+m+d>1)throw new Error("Mixed descriptor in srcset is not supported");let p=v?"w":m?"h":"d",f=v?"w":m?"h":"x",h=I=>Math.max(...I),w=c.map(I=>I.url),T=h(w.map(I=>I.length)),A=c.map(I=>I[p]).map(I=>I?I.toString():""),S=A.map(I=>{let k=I.indexOf(".");return k===-1?I.length:k}),B=h(S);return a([",",r],w.map((I,k)=>{let P=[I],C=A[k];if(C){let D=T-I.length+1,g=B-S[k],F=" ".repeat(D+g);P.push(s(F," "),C+f);}return P}))}function i(o){return o.trim().split(/\s+/).join(" ")}n.exports={printImgSrcset:u,printClassNames:i};}}),ig=Z({"src/language-html/syntax-vue.js"(e,n){re();var{builders:{group:t}}=Oe();function s(i,o){let{left:c,operator:v,right:m}=a(i);return [t(o("function _(".concat(c,") {}"),{parser:"babel",__isVueForBindingLeft:!0}))," ",v," ",o(m,{parser:"__js_expression"},{stripTrailingHardline:!0})]}function a(i){let o=/(.*?)\s+(in|of)\s+(.*)/s,c=/,([^,\]}]*)(?:,([^,\]}]*))?$/,v=/^\(|\)$/g,m=i.match(o);if(!m)return;let d={};if(d.for=m[3].trim(),!d.for)return;let p=m[1].trim().replace(v,""),f=p.match(c);f?(d.alias=p.replace(c,""),d.iterator1=f[1].trim(),f[2]&&(d.iterator2=f[2].trim())):d.alias=p;let h=[d.alias,d.iterator1,d.iterator2];if(!h.some((w,T)=>!w&&(T===0||h.slice(T+1).some(Boolean))))return {left:h.filter(Boolean).join(","),operator:m[2],right:d.for}}function r(i,o){return o("function _(".concat(i,") {}"),{parser:"babel",__isVueBindings:!0})}function u(i){let o=/^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/,c=/^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/,v=i.trim();return o.test(v)||c.test(v)}n.exports={isVueEventBindingExpression:u,printVueFor:s,printVueBindings:r};}}),ho=Z({"src/language-html/get-node-content.js"(e,n){re();var{needsToBorrowParentClosingTagStartMarker:t,printClosingTagStartMarker:s,needsToBorrowLastChildClosingTagEndMarker:a,printClosingTagEndMarker:r,needsToBorrowParentOpeningTagEndMarker:u,printOpeningTagEndMarker:i}=er();function o(c,v){let m=c.startSourceSpan.end.offset;c.firstChild&&u(c.firstChild)&&(m-=i(c).length);let d=c.endSourceSpan.start.offset;return c.lastChild&&t(c.lastChild)?d+=s(c,v).length:a(c)&&(d-=r(c.lastChild,v).length),v.originalText.slice(m,d)}n.exports=o;}}),ag=Z({"src/language-html/embed.js"(e,n){re();var{builders:{breakParent:t,group:s,hardline:a,indent:r,line:u,fill:i,softline:o},utils:{mapDoc:c,replaceTextEndOfLine:v}}=Oe(),m=Xn(),{printClosingTag:d,printClosingTagSuffix:p,needsToBorrowPrevClosingTagEndMarker:f,printOpeningTagPrefix:h,printOpeningTag:w}=er(),{printImgSrcset:T,printClassNames:A}=sg(),{printVueFor:S,printVueBindings:B,isVueEventBindingExpression:I}=ig(),{isScriptLikeTag:k,isVueNonHtmlBlock:P,inferScriptParser:C,htmlTrimPreserveIndentation:D,dedentString:g,unescapeQuoteEntities:F,isVueSlotAttribute:l,isVueSfcBindingsAttribute:E,getTextValueParts:y}=qt(),N=ho();function x(L,M,j){let $=te=>new RegExp(te.join("|")).test(L.fullName),V=()=>F(L.value),q=!1,Y=(te,oe)=>{let W=te.type==="NGRoot"?te.node.type==="NGMicrosyntax"&&te.node.body.length===1&&te.node.body[0].type==="NGMicrosyntaxExpression"?te.node.body[0].expression:te.node:te.type==="JsExpressionRoot"?te.node:te;W&&(W.type==="ObjectExpression"||W.type==="ArrayExpression"||oe.parser==="__vue_expression"&&(W.type==="TemplateLiteral"||W.type==="StringLiteral"))&&(q=!0);},H=te=>s(te),R=function(te){let oe=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return s([r([o,te]),oe?o:""])},Q=te=>q?H(te):R(te),ee=(te,oe)=>M(te,Object.assign({__onHtmlBindingRoot:Y,__embeddedInHtml:!0},oe));if(L.fullName==="srcset"&&(L.parent.fullName==="img"||L.parent.fullName==="source"))return R(T(V()));if(L.fullName==="class"&&!j.parentParser){let te=V();if(!te.includes("{{"))return A(te)}if(L.fullName==="style"&&!j.parentParser){let te=V();if(!te.includes("{{"))return R(ee(te,{parser:"css",__isHTMLStyleAttribute:!0}))}if(j.parser==="vue"){if(L.fullName==="v-for")return S(V(),ee);if(l(L)||E(L,j))return B(V(),ee);let te=["^@","^v-on:"],oe=["^:","^v-bind:"],W=["^v-"];if($(te)){let X=V(),ue=I(X)?"__js_expression":j.__should_parse_vue_template_with_ts?"__vue_ts_event_binding":"__vue_event_binding";return Q(ee(X,{parser:ue}))}if($(oe))return Q(ee(V(),{parser:"__vue_expression"}));if($(W))return Q(ee(V(),{parser:"__js_expression"}))}if(j.parser==="angular"){let te=(G,z)=>ee(G,Object.assign(Object.assign({},z),{},{trailingComma:"none"})),oe=["^\\*"],W=["^\\(.+\\)$","^on-"],X=["^\\[.+\\]$","^bind(on)?-","^ng-(if|show|hide|class|style)$"],ue=["^i18n(-.+)?$"];if($(W))return Q(te(V(),{parser:"__ng_action"}));if($(X))return Q(te(V(),{parser:"__ng_binding"}));if($(ue)){let G=V().trim();return R(i(y(L,G)),!G.includes("@@"))}if($(oe))return Q(te(V(),{parser:"__ng_directive"}));let De=/{{(.+?)}}/s,ie=V();if(De.test(ie)){let G=[];for(let[z,U]of ie.split(De).entries())if(z%2===0)G.push(v(U));else try{G.push(s(["{{",r([u,te(U,{parser:"__ng_interpolation",__isInHtmlInterpolation:!0})]),u,"}}"]));}catch{G.push("{{",v(U),"}}");}return s(G)}}return null}function b(L,M,j,$){let V=L.getValue();switch(V.type){case"element":{if(k(V)||V.type==="interpolation")return;if(!V.isSelfClosing&&P(V,$)){let q=C(V,$);if(!q)return;let Y=N(V,$),H=/^\s*$/.test(Y),R="";return H||(R=j(D(Y),{parser:q,__embeddedInHtml:!0},{stripTrailingHardline:!0}),H=R===""),[h(V,$),s(w(L,$,M)),H?"":a,R,H?"":a,d(V,$),p(V,$)]}break}case"text":{if(k(V.parent)){let q=C(V.parent,$);if(q){let Y=q==="markdown"?g(V.value.replace(/^[^\S\n]*\n/,"")):V.value,H={parser:q,__embeddedInHtml:!0};if($.parser==="html"&&q==="babel"){let R="script",{attrMap:Q}=V.parent;Q&&(Q.type==="module"||Q.type==="text/babel"&&Q["data-type"]==="module")&&(R="module"),H.__babelSourceType=R;}return [t,h(V,$),j(Y,H,{stripTrailingHardline:!0}),p(V,$)]}}else if(V.parent.type==="interpolation"){let q={__isInHtmlInterpolation:!0,__embeddedInHtml:!0};return $.parser==="angular"?(q.parser="__ng_interpolation",q.trailingComma="none"):$.parser==="vue"?q.parser=$.__should_parse_vue_template_with_ts?"__vue_ts_expression":"__vue_expression":q.parser="__js_expression",[r([u,j(V.value,q,{stripTrailingHardline:!0})]),V.parent.next&&f(V.parent.next)?" ":u]}break}case"attribute":{if(!V.value)break;if(/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset,V.valueSpan.end.offset)))return [V.rawName,"=",V.value];if($.parser==="lwc"&&/^{.*}$/s.test($.originalText.slice(V.valueSpan.start.offset,V.valueSpan.end.offset)))return [V.rawName,"=",V.value];let q=x(V,(Y,H)=>j(Y,Object.assign({__isInHtmlAttribute:!0,__embeddedInHtml:!0},H),{stripTrailingHardline:!0}),$);if(q)return [V.rawName,'="',s(c(q,Y=>typeof Y=="string"?Y.replace(/"/g,"&quot;"):Y)),'"'];break}case"front-matter":return m(V,j)}}n.exports=b;}}),vo=Z({"src/language-html/print/children.js"(e,n){re();var{builders:{breakParent:t,group:s,ifBreak:a,line:r,softline:u,hardline:i},utils:{replaceTextEndOfLine:o}}=Oe(),{locStart:c,locEnd:v}=Yn(),{forceBreakChildren:m,forceNextEmptyLine:d,isTextLikeNode:p,hasPrettierIgnore:f,preferHardlineAsLeadingSpaces:h}=qt(),{printOpeningTagPrefix:w,needsToBorrowNextOpeningTagStartMarker:T,printOpeningTagStartMarker:A,needsToBorrowPrevClosingTagEndMarker:S,printClosingTagEndMarker:B,printClosingTagSuffix:I,needsToBorrowParentClosingTagStartMarker:k}=er();function P(g,F,l){let E=g.getValue();return f(E)?[w(E,F),...o(F.originalText.slice(c(E)+(E.prev&&T(E.prev)?A(E).length:0),v(E)-(E.next&&S(E.next)?B(E,F).length:0))),I(E,F)]:l()}function C(g,F){return p(g)&&p(F)?g.isTrailingSpaceSensitive?g.hasTrailingSpaces?h(F)?i:r:"":h(F)?i:u:T(g)&&(f(F)||F.firstChild||F.isSelfClosing||F.type==="element"&&F.attrs.length>0)||g.type==="element"&&g.isSelfClosing&&S(F)?"":!F.isLeadingSpaceSensitive||h(F)||S(F)&&g.lastChild&&k(g.lastChild)&&g.lastChild.lastChild&&k(g.lastChild.lastChild)?i:F.hasLeadingSpaces?r:u}function D(g,F,l){let E=g.getValue();if(m(E))return [t,...g.map(N=>{let x=N.getValue(),b=x.prev?C(x.prev,x):"";return [b?[b,d(x.prev)?i:""]:"",P(N,F,l)]},"children")];let y=E.children.map(()=>Symbol(""));return g.map((N,x)=>{let b=N.getValue();if(p(b)){if(b.prev&&p(b.prev)){let Y=C(b.prev,b);if(Y)return d(b.prev)?[i,i,P(N,F,l)]:[Y,P(N,F,l)]}return P(N,F,l)}let L=[],M=[],j=[],$=[],V=b.prev?C(b.prev,b):"",q=b.next?C(b,b.next):"";return V&&(d(b.prev)?L.push(i,i):V===i?L.push(i):p(b.prev)?M.push(V):M.push(a("",u,{groupId:y[x-1]}))),q&&(d(b)?p(b.next)&&$.push(i,i):q===i?p(b.next)&&$.push(i):j.push(q)),[...L,s([...M,s([P(N,F,l),...j],{id:y[x]})]),...$]},"children")}n.exports={printChildren:D};}}),og=Z({"src/language-html/print/element.js"(e,n){re();var{builders:{breakParent:t,dedentToRoot:s,group:a,ifBreak:r,indentIfBreak:u,indent:i,line:o,softline:c},utils:{replaceTextEndOfLine:v}}=Oe(),m=ho(),{shouldPreserveContent:d,isScriptLikeTag:p,isVueCustomBlock:f,countParents:h,forceBreakContent:w}=qt(),{printOpeningTagPrefix:T,printOpeningTag:A,printClosingTagSuffix:S,printClosingTag:B,needsToBorrowPrevClosingTagEndMarker:I,needsToBorrowLastChildClosingTagEndMarker:k}=er(),{printChildren:P}=vo();function C(D,g,F){let l=D.getValue();if(d(l,g))return [T(l,g),a(A(D,g,F)),...v(m(l,g)),...B(l,g),S(l,g)];let E=l.children.length===1&&l.firstChild.type==="interpolation"&&l.firstChild.isLeadingSpaceSensitive&&!l.firstChild.hasLeadingSpaces&&l.lastChild.isTrailingSpaceSensitive&&!l.lastChild.hasTrailingSpaces,y=Symbol("element-attr-group-id"),N=M=>a([a(A(D,g,F),{id:y}),M,B(l,g)]),x=M=>E?u(M,{groupId:y}):(p(l)||f(l,g))&&l.parent.type==="root"&&g.parser==="vue"&&!g.vueIndentScriptAndStyle?M:i(M),b=()=>E?r(c,"",{groupId:y}):l.firstChild.hasLeadingSpaces&&l.firstChild.isLeadingSpaceSensitive?o:l.firstChild.type==="text"&&l.isWhitespaceSensitive&&l.isIndentationSensitive?s(c):c,L=()=>(l.next?I(l.next):k(l.parent))?l.lastChild.hasTrailingSpaces&&l.lastChild.isTrailingSpaceSensitive?" ":"":E?r(c,"",{groupId:y}):l.lastChild.hasTrailingSpaces&&l.lastChild.isTrailingSpaceSensitive?o:(l.lastChild.type==="comment"||l.lastChild.type==="text"&&l.isWhitespaceSensitive&&l.isIndentationSensitive)&&new RegExp("\\n[\\t ]{".concat(g.tabWidth*h(D,j=>j.parent&&j.parent.type!=="root"),"}$")).test(l.lastChild.value)?"":c;return l.children.length===0?N(l.hasDanglingSpaces&&l.isDanglingSpaceSensitive?o:""):N([w(l)?t:"",x([b(),P(D,g,F)]),L()])}n.exports={printElement:C};}}),lg=Z({"src/language-html/printer-html.js"(e,n){re();var{builders:{fill:t,group:s,hardline:a,literalline:r},utils:{cleanDoc:u,getDocParts:i,isConcat:o,replaceTextEndOfLine:c}}=Oe(),v=zd(),{countChars:m,unescapeQuoteEntities:d,getTextValueParts:p}=qt(),f=rg(),{insertPragma:h}=ng(),{locStart:w,locEnd:T}=Yn(),A=ag(),{printClosingTagSuffix:S,printClosingTagEnd:B,printOpeningTagPrefix:I,printOpeningTagStart:k}=er(),{printElement:P}=og(),{printChildren:C}=vo();function D(g,F,l){let E=g.getValue();switch(E.type){case"front-matter":return c(E.raw);case"root":return F.__onHtmlRoot&&F.__onHtmlRoot(E),[s(C(g,F,l)),a];case"element":case"ieConditionalComment":return P(g,F,l);case"ieConditionalStartComment":case"ieConditionalEndComment":return [k(E),B(E)];case"interpolation":return [k(E,F),...g.map(l,"children"),B(E,F)];case"text":{if(E.parent.type==="interpolation"){let N=/\n[^\S\n]*$/,x=N.test(E.value),b=x?E.value.replace(N,""):E.value;return [...c(b),x?a:""]}let y=u([I(E,F),...p(E),S(E,F)]);return o(y)||y.type==="fill"?t(i(y)):y}case"docType":return [s([k(E,F)," ",E.value.replace(/^html\b/i,"html").replace(/\s+/g," ")]),B(E,F)];case"comment":return [I(E,F),...c(F.originalText.slice(w(E),T(E)),r),S(E,F)];case"attribute":{if(E.value===null)return E.rawName;let y=d(E.value),N=m(y,"'"),x=m(y,'"'),b=N<x?"'":'"';return [E.rawName,"=",b,...c(b==='"'?y.replace(/"/g,"&quot;"):y.replace(/'/g,"&apos;")),b]}default:throw new Error("Unexpected node type ".concat(E.type))}}n.exports={preprocess:f,print:D,insertPragma:h,massageAstNode:v,embed:A};}}),cg=Z({"src/language-html/options.js"(e,n){re();var t=Ot(),s="HTML";n.exports={bracketSameLine:t.bracketSameLine,htmlWhitespaceSensitivity:{since:"1.15.0",category:s,type:"choice",default:"css",description:"How to handle whitespaces in HTML.",choices:[{value:"css",description:"Respect the default value of CSS display property."},{value:"strict",description:"Whitespaces are considered sensitive."},{value:"ignore",description:"Whitespaces are considered insensitive."}]},singleAttributePerLine:t.singleAttributePerLine,vueIndentScriptAndStyle:{since:"1.19.0",category:s,type:"boolean",default:!1,description:"Indent script and style tags in Vue files."}};}}),pg=Z({"src/language-html/parsers.js"(){re();}}),xn=Z({"node_modules/linguist-languages/data/HTML.json"(e,n){n.exports={name:"HTML",type:"markup",tmScope:"text.html.basic",aceMode:"html",codemirrorMode:"htmlmixed",codemirrorMimeType:"text/html",color:"#e34c26",aliases:["xhtml"],extensions:[".html",".hta",".htm",".html.hl",".inc",".xht",".xhtml"],languageId:146};}}),fg=Z({"node_modules/linguist-languages/data/Vue.json"(e,n){n.exports={name:"Vue",type:"markup",color:"#41b883",extensions:[".vue"],tmScope:"text.html.vue",aceMode:"html",languageId:391};}}),Dg=Z({"src/language-html/index.js"(e,n){re();var t=Bt(),s=lg(),a=cg(),r=pg(),u=[t(xn(),()=>({name:"Angular",since:"1.15.0",parsers:["angular"],vscodeLanguageIds:["html"],extensions:[".component.html"],filenames:[]})),t(xn(),o=>({since:"1.15.0",parsers:["html"],vscodeLanguageIds:["html"],extensions:[...o.extensions,".mjml"]})),t(xn(),()=>({name:"Lightning Web Components",since:"1.17.0",parsers:["lwc"],vscodeLanguageIds:["html"],extensions:[],filenames:[]})),t(fg(),()=>({since:"1.10.0",parsers:["vue"],vscodeLanguageIds:["vue"]}))],i={html:s};n.exports={languages:u,printers:i,options:a,parsers:r};}}),mg=Z({"src/language-yaml/pragma.js"(e,n){re();function t(r){return /^\s*@(?:prettier|format)\s*$/.test(r)}function s(r){return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r)}function a(r){return `# @format

	`.concat(r)}n.exports={isPragma:t,hasPragma:s,insertPragma:a};}}),dg=Z({"src/language-yaml/loc.js"(e,n){re();function t(a){return a.position.start.offset}function s(a){return a.position.end.offset}n.exports={locStart:t,locEnd:s};}}),gg=Z({"src/language-yaml/embed.js"(e,n){re();function t(s,a,r,u){if(s.getValue().type==="root"&&u.filepath&&/(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath))return r(u.originalText,Object.assign(Object.assign({},u),{},{parser:"json"}))}n.exports=t;}}),Mt=Z({"src/language-yaml/utils.js"(e,n){re();var{getLast:t,isNonEmptyArray:s}=Ue();function a(C,D){let g=0,F=C.stack.length-1;for(let l=0;l<F;l++){let E=C.stack[l];r(E)&&D(E)&&g++;}return g}function r(C,D){return C&&typeof C.type=="string"&&(!D||D.includes(C.type))}function u(C,D,g){return D("children"in C?Object.assign(Object.assign({},C),{},{children:C.children.map(F=>u(F,D,C))}):C,g)}function i(C,D,g){Object.defineProperty(C,D,{get:g,enumerable:!1});}function o(C,D){let g=0,F=D.length;for(let l=C.position.end.offset-1;l<F;l++){let E=D[l];if(E===`
	`&&g++,g===1&&/\S/.test(E))return !1;if(g===2)return !0}return !1}function c(C){switch(C.getValue().type){case"tag":case"anchor":case"comment":return !1}let g=C.stack.length;for(let F=1;F<g;F++){let l=C.stack[F],E=C.stack[F-1];if(Array.isArray(E)&&typeof l=="number"&&l!==E.length-1)return !1}return !0}function v(C){return s(C.children)?v(t(C.children)):C}function m(C){return C.value.trim()==="prettier-ignore"}function d(C){let D=C.getValue();if(D.type==="documentBody"){let g=C.getParentNode();return S(g.head)&&m(t(g.head.endComments))}return h(D)&&m(t(D.leadingComments))}function p(C){return !s(C.children)&&!f(C)}function f(C){return h(C)||w(C)||T(C)||A(C)||S(C)}function h(C){return s(C==null?void 0:C.leadingComments)}function w(C){return s(C==null?void 0:C.middleComments)}function T(C){return C==null?void 0:C.indicatorComment}function A(C){return C==null?void 0:C.trailingComment}function S(C){return s(C==null?void 0:C.endComments)}function B(C){let D=[],g;for(let F of C.split(/( +)/))F!==" "?g===" "?D.push(F):D.push((D.pop()||"")+F):g===void 0&&D.unshift(""),g=F;return g===" "&&D.push((D.pop()||"")+" "),D[0]===""&&(D.shift(),D.unshift(" "+(D.shift()||""))),D}function I(C,D,g){let F=D.split(`
	`).map((l,E,y)=>E===0&&E===y.length-1?l:E!==0&&E!==y.length-1?l.trim():E===0?l.trimEnd():l.trimStart());return g.proseWrap==="preserve"?F.map(l=>l.length===0?[]:[l]):F.map(l=>l.length===0?[]:B(l)).reduce((l,E,y)=>y!==0&&F[y-1].length>0&&E.length>0&&!(C==="quoteDouble"&&t(t(l)).endsWith("\\"))?[...l.slice(0,-1),[...t(l),...E]]:[...l,E],[]).map(l=>g.proseWrap==="never"?[l.join(" ")]:l)}function k(C,D){let{parentIndent:g,isLastDescendant:F,options:l}=D,E=C.position.start.line===C.position.end.line?"":l.originalText.slice(C.position.start.offset,C.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1],y;if(C.indent===null){let b=E.match(/^(?<leadingSpace> *)[^\n\r ]/m);y=b?b.groups.leadingSpace.length:Number.POSITIVE_INFINITY;}else y=C.indent-1+g;let N=E.split(`
	`).map(b=>b.slice(y));if(l.proseWrap==="preserve"||C.type==="blockLiteral")return x(N.map(b=>b.length===0?[]:[b]));return x(N.map(b=>b.length===0?[]:B(b)).reduce((b,L,M)=>M!==0&&N[M-1].length>0&&L.length>0&&!/^\s/.test(L[0])&&!/^\s|\s$/.test(t(b))?[...b.slice(0,-1),[...t(b),...L]]:[...b,L],[]).map(b=>b.reduce((L,M)=>L.length>0&&/\s$/.test(t(L))?[...L.slice(0,-1),t(L)+" "+M]:[...L,M],[])).map(b=>l.proseWrap==="never"?[b.join(" ")]:b));function x(b){if(C.chomping==="keep")return t(b).length===0?b.slice(0,-1):b;let L=0;for(let M=b.length-1;M>=0&&b[M].length===0;M--)L++;return L===0?b:L>=2&&!F?b.slice(0,-(L-1)):b.slice(0,-L)}}function P(C){if(!C)return !0;switch(C.type){case"plain":case"quoteDouble":case"quoteSingle":case"alias":case"flowMapping":case"flowSequence":return !0;default:return !1}}n.exports={getLast:t,getAncestorCount:a,isNode:r,isEmptyNode:p,isInlineNode:P,mapNode:u,defineShortcut:i,isNextLineEmpty:o,isLastDescendantNode:c,getBlockValueLineContents:k,getFlowScalarLineContents:I,getLastDescendantNode:v,hasPrettierIgnore:d,hasLeadingComments:h,hasMiddleComments:w,hasIndicatorComment:T,hasTrailingComment:A,hasEndComments:S};}}),yg=Z({"src/language-yaml/print-preprocess.js"(e,n){re();var{defineShortcut:t,mapNode:s}=Mt();function a(u){return s(u,r)}function r(u){switch(u.type){case"document":t(u,"head",()=>u.children[0]),t(u,"body",()=>u.children[1]);break;case"documentBody":case"sequenceItem":case"flowSequenceItem":case"mappingKey":case"mappingValue":t(u,"content",()=>u.children[0]);break;case"mappingItem":case"flowMappingItem":t(u,"key",()=>u.children[0]),t(u,"value",()=>u.children[1]);break}return u}n.exports=a;}}),jr=Z({"src/language-yaml/print/misc.js"(e,n){re();var{builders:{softline:t,align:s}}=Oe(),{hasEndComments:a,isNextLineEmpty:r,isNode:u}=Mt(),i=new WeakMap;function o(m,d){let p=m.getValue(),f=m.stack[0],h;return i.has(f)?h=i.get(f):(h=new Set,i.set(f,h)),!h.has(p.position.end.line)&&(h.add(p.position.end.line),r(p,d)&&!c(m.getParentNode()))?t:""}function c(m){return a(m)&&!u(m,["documentHead","documentBody","flowMapping","flowSequence"])}function v(m,d){return s(" ".repeat(m),d)}n.exports={alignWithSpaces:v,shouldPrintEndComments:c,printNextEmptyLine:o};}}),hg=Z({"src/language-yaml/print/flow-mapping-sequence.js"(e,n){re();var{builders:{ifBreak:t,line:s,softline:a,hardline:r,join:u}}=Oe(),{isEmptyNode:i,getLast:o,hasEndComments:c}=Mt(),{printNextEmptyLine:v,alignWithSpaces:m}=jr();function d(f,h,w){let T=f.getValue(),A=T.type==="flowMapping",S=A?"{":"[",B=A?"}":"]",I=a;A&&T.children.length>0&&w.bracketSpacing&&(I=s);let k=o(T.children),P=k&&k.type==="flowMappingItem"&&i(k.key)&&i(k.value);return [S,m(w.tabWidth,[I,p(f,h,w),w.trailingComma==="none"?"":t(","),c(T)?[r,u(r,f.map(h,"endComments"))]:""]),P?"":I,B]}function p(f,h,w){let T=f.getValue();return f.map((S,B)=>[h(),B===T.children.length-1?"":[",",s,T.children[B].position.start.line!==T.children[B+1].position.start.line?v(S,w.originalText):""]],"children")}n.exports={printFlowMapping:d,printFlowSequence:d};}}),vg=Z({"src/language-yaml/print/mapping-item.js"(e,n){re();var{builders:{conditionalGroup:t,group:s,hardline:a,ifBreak:r,join:u,line:i}}=Oe(),{hasLeadingComments:o,hasMiddleComments:c,hasTrailingComment:v,hasEndComments:m,isNode:d,isEmptyNode:p,isInlineNode:f}=Mt(),{alignWithSpaces:h}=jr();function w(B,I,k,P,C){let{key:D,value:g}=B,F=p(D),l=p(g);if(F&&l)return ": ";let E=P("key"),y=A(B)?" ":"";if(l)return B.type==="flowMappingItem"&&I.type==="flowMapping"?E:B.type==="mappingItem"&&T(D.content,C)&&!v(D.content)&&(!I.tag||I.tag.value!=="tag:yaml.org,2002:set")?[E,y,":"]:["? ",h(2,E)];let N=P("value");if(F)return [": ",h(2,N)];if(o(g)||!f(D.content))return ["? ",h(2,E),a,u("",k.map(P,"value","leadingComments").map($=>[$,a])),": ",h(2,N)];if(S(D.content)&&!o(D.content)&&!c(D.content)&&!v(D.content)&&!m(D)&&!o(g.content)&&!c(g.content)&&!m(g)&&T(g.content,C))return [E,y,": ",N];let x=Symbol("mappingKey"),b=s([r("? "),s(h(2,E),{id:x})]),L=[a,": ",h(2,N)],M=[y,":"];o(g.content)||m(g)&&g.content&&!d(g.content,["mapping","sequence"])||I.type==="mapping"&&v(D.content)&&f(g.content)||d(g.content,["mapping","sequence"])&&g.content.tag===null&&g.content.anchor===null?M.push(a):g.content&&M.push(i),M.push(N);let j=h(C.tabWidth,M);return T(D.content,C)&&!o(D.content)&&!c(D.content)&&!m(D)?t([[E,j]]):t([[b,r(L,j,{groupId:x})]])}function T(B,I){if(!B)return !0;switch(B.type){case"plain":case"quoteSingle":case"quoteDouble":break;case"alias":return !0;default:return !1}if(I.proseWrap==="preserve")return B.position.start.line===B.position.end.line;if(/\\$/m.test(I.originalText.slice(B.position.start.offset,B.position.end.offset)))return !1;switch(I.proseWrap){case"never":return !B.value.includes(`
	`);case"always":return !/[\n ]/.test(B.value);default:return !1}}function A(B){return B.key.content&&B.key.content.type==="alias"}function S(B){if(!B)return !0;switch(B.type){case"plain":case"quoteDouble":case"quoteSingle":return B.position.start.line===B.position.end.line;case"alias":return !0;default:return !1}}n.exports=w;}}),Cg=Z({"src/language-yaml/print/block.js"(e,n){re();var{builders:{dedent:t,dedentToRoot:s,fill:a,hardline:r,join:u,line:i,literalline:o,markAsRoot:c},utils:{getDocParts:v}}=Oe(),{getAncestorCount:m,getBlockValueLineContents:d,hasIndicatorComment:p,isLastDescendantNode:f,isNode:h}=Mt(),{alignWithSpaces:w}=jr();function T(A,S,B){let I=A.getValue(),k=m(A,F=>h(F,["sequence","mapping"])),P=f(A),C=[I.type==="blockFolded"?">":"|"];I.indent!==null&&C.push(I.indent.toString()),I.chomping!=="clip"&&C.push(I.chomping==="keep"?"+":"-"),p(I)&&C.push(" ",S("indicatorComment"));let D=d(I,{parentIndent:k,isLastDescendant:P,options:B}),g=[];for(let[F,l]of D.entries())F===0&&g.push(r),g.push(a(v(u(i,l)))),F!==D.length-1?g.push(l.length===0?r:c(o)):I.chomping==="keep"&&P&&g.push(s(l.length===0?r:o));return I.indent===null?C.push(t(w(B.tabWidth,g))):C.push(s(w(I.indent-1+k,g))),C}n.exports=T;}}),Eg=Z({"src/language-yaml/printer-yaml.js"(e,n){re();var{builders:{breakParent:t,fill:s,group:a,hardline:r,join:u,line:i,lineSuffix:o,literalline:c},utils:{getDocParts:v,replaceTextEndOfLine:m}}=Oe(),{isPreviousLineEmpty:d}=Ue(),{insertPragma:p,isPragma:f}=mg(),{locStart:h}=dg(),w=gg(),{getFlowScalarLineContents:T,getLastDescendantNode:A,hasLeadingComments:S,hasMiddleComments:B,hasTrailingComment:I,hasEndComments:k,hasPrettierIgnore:P,isLastDescendantNode:C,isNode:D,isInlineNode:g}=Mt(),F=yg(),{alignWithSpaces:l,printNextEmptyLine:E,shouldPrintEndComments:y}=jr(),{printFlowMapping:N,printFlowSequence:x}=hg(),b=vg(),L=Cg();function M(R,Q,ee){let te=R.getValue(),oe=[];te.type!=="mappingValue"&&S(te)&&oe.push([u(r,R.map(ee,"leadingComments")),r]);let{tag:W,anchor:X}=te;W&&oe.push(ee("tag")),W&&X&&oe.push(" "),X&&oe.push(ee("anchor"));let ue="";D(te,["mapping","sequence","comment","directive","mappingItem","sequenceItem"])&&!C(R)&&(ue=E(R,Q.originalText)),(W||X)&&(D(te,["sequence","mapping"])&&!B(te)?oe.push(r):oe.push(" ")),B(te)&&oe.push([te.middleComments.length===1?"":r,u(r,R.map(ee,"middleComments")),r]);let De=R.getParentNode();return P(R)?oe.push(m(Q.originalText.slice(te.position.start.offset,te.position.end.offset).trimEnd(),c)):oe.push(a(j(te,De,R,Q,ee))),I(te)&&!D(te,["document","documentHead"])&&oe.push(o([te.type==="mappingValue"&&!te.content?"":" ",De.type==="mappingKey"&&R.getParentNode(2).type==="mapping"&&g(te)?"":t,ee("trailingComment")])),y(te)&&oe.push(l(te.type==="sequenceItem"?2:0,[r,u(r,R.map(ie=>[d(Q.originalText,ie.getValue(),h)?r:"",ee()],"endComments"))])),oe.push(ue),oe}function j(R,Q,ee,te,oe){switch(R.type){case"root":{let{children:W}=R,X=[];ee.each((De,ie)=>{let G=W[ie],z=W[ie+1];ie!==0&&X.push(r),X.push(oe()),V(G,z)?(X.push(r,"..."),I(G)&&X.push(" ",oe("trailingComment"))):z&&!I(z.head)&&X.push(r,"---");},"children");let ue=A(R);return (!D(ue,["blockLiteral","blockFolded"])||ue.chomping!=="keep")&&X.push(r),X}case"document":{let W=Q.children[ee.getName()+1],X=[];return q(R,W,Q,te)==="head"&&((R.head.children.length>0||R.head.endComments.length>0)&&X.push(oe("head")),I(R.head)?X.push(["---"," ",oe(["head","trailingComment"])]):X.push("---")),$(R)&&X.push(oe("body")),u(r,X)}case"documentHead":return u(r,[...ee.map(oe,"children"),...ee.map(oe,"endComments")]);case"documentBody":{let{children:W,endComments:X}=R,ue="";if(W.length>0&&X.length>0){let De=A(R);D(De,["blockFolded","blockLiteral"])?De.chomping!=="keep"&&(ue=[r,r]):ue=r;}return [u(r,ee.map(oe,"children")),ue,u(r,ee.map(oe,"endComments"))]}case"directive":return ["%",u(" ",[R.name,...R.parameters])];case"comment":return ["#",R.value];case"alias":return ["*",R.value];case"tag":return te.originalText.slice(R.position.start.offset,R.position.end.offset);case"anchor":return ["&",R.value];case"plain":return Y(R.type,te.originalText.slice(R.position.start.offset,R.position.end.offset),te);case"quoteDouble":case"quoteSingle":{let W="'",X='"',ue=te.originalText.slice(R.position.start.offset+1,R.position.end.offset-1);if(R.type==="quoteSingle"&&ue.includes("\\")||R.type==="quoteDouble"&&/\\[^"]/.test(ue)){let ie=R.type==="quoteDouble"?X:W;return [ie,Y(R.type,ue,te),ie]}if(ue.includes(X))return [W,Y(R.type,R.type==="quoteDouble"?ue.replace(/\\"/g,X).replace(/'/g,W.repeat(2)):ue,te),W];if(ue.includes(W))return [X,Y(R.type,R.type==="quoteSingle"?ue.replace(/''/g,W):ue,te),X];let De=te.singleQuote?W:X;return [De,Y(R.type,ue,te),De]}case"blockFolded":case"blockLiteral":return L(ee,oe,te);case"mapping":case"sequence":return u(r,ee.map(oe,"children"));case"sequenceItem":return ["- ",l(2,R.content?oe("content"):"")];case"mappingKey":case"mappingValue":return R.content?oe("content"):"";case"mappingItem":case"flowMappingItem":return b(R,Q,ee,oe,te);case"flowMapping":return N(ee,oe,te);case"flowSequence":return x(ee,oe,te);case"flowSequenceItem":return oe("content");default:throw new Error("Unexpected node type ".concat(R.type))}}function $(R){return R.body.children.length>0||k(R.body)}function V(R,Q){return I(R)||Q&&(Q.head.children.length>0||k(Q.head))}function q(R,Q,ee,te){return ee.children[0]===R&&/---(?:\s|$)/.test(te.originalText.slice(h(R),h(R)+4))||R.head.children.length>0||k(R.head)||I(R.head)?"head":V(R,Q)?!1:Q?"root":!1}function Y(R,Q,ee){let te=T(R,Q,ee);return u(r,te.map(oe=>s(v(u(i,oe)))))}function H(R,Q){if(D(Q))switch(delete Q.position,Q.type){case"comment":if(f(Q.value))return null;break;case"quoteDouble":case"quoteSingle":Q.type="quote";break}}n.exports={preprocess:F,embed:w,print:M,massageAstNode:H,insertPragma:p};}}),Fg=Z({"src/language-yaml/options.js"(e,n){re();var t=Ot();n.exports={bracketSpacing:t.bracketSpacing,singleQuote:t.singleQuote,proseWrap:t.proseWrap};}}),Ag=Z({"src/language-yaml/parsers.js"(){re();}}),Sg=Z({"node_modules/linguist-languages/data/YAML.json"(e,n){n.exports={name:"YAML",type:"data",color:"#cb171e",tmScope:"source.yaml",aliases:["yml"],extensions:[".yml",".mir",".reek",".rviz",".sublime-syntax",".syntax",".yaml",".yaml-tmlanguage",".yaml.sed",".yml.mysql"],filenames:[".clang-format",".clang-tidy",".gemrc","CITATION.cff","glide.lock","yarn.lock"],aceMode:"yaml",codemirrorMode:"yaml",codemirrorMimeType:"text/x-yaml",languageId:407};}}),xg=Z({"src/language-yaml/index.js"(e,n){re();var t=Bt(),s=Eg(),a=Fg(),r=Ag(),u=[t(Sg(),i=>({since:"1.14.0",parsers:["yaml"],vscodeLanguageIds:["yaml","ansible","home-assistant"],filenames:[...i.filenames.filter(o=>o!=="yarn.lock"),".prettierrc",".stylelintrc"]}))];n.exports={languages:u,printers:{yaml:s},options:a,parsers:r};}}),bg=Z({"src/languages.js"(e,n){re(),n.exports=[id(),Sd(),Pd(),Md(),Ud(),Dg(),xg()];}});re();var{version:Tg}=ya(),kt=Sm(),{getSupportInfo:Bg}=Mn(),Ng=xm(),wg=bg(),_g=Oe();function bt(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;return function(){for(var t=arguments.length,s=new Array(t),a=0;a<t;a++)s[a]=arguments[a];let r=s[n]||{},u=r.plugins||[];return s[n]=Object.assign(Object.assign({},r),{},{plugins:[...wg,...Array.isArray(u)?u:Object.values(u)]}),e(...s)}}var bn=bt(kt.formatWithCursor);Co.exports={formatWithCursor:bn,format(e,n){return bn(e,n).formatted},check(e,n){let{formatted:t}=bn(e,n);return t===e},doc:_g,getSupportInfo:bt(Bg,0),version:Tg,util:Ng,__debug:{parse:bt(kt.parse),formatAST:bt(kt.formatAST),formatDoc:bt(kt.formatDoc),printToDoc:bt(kt.printToDoc),printDocToString:bt(kt.printDocToString)}};});return Pg();});
} (standalone));

var prettier = /*@__PURE__*/getDefaultExportFromCjs(standalone.exports);

const { util } = prettier;
/**
 * Override the default behavior to attach comments to syntax node.
 */
const commentHandler = {
    ownLine: (comment) => [addEmptyInterfaceComment, addEmptyModelComment, addStatementDecoratorComment].some((x) => x(comment)),
};
/**
 * When a comment is on an empty interface make sure it gets added as a dangling comment on it and not on the identifier.
 *
 * @example
 *
 * interface Foo {
 *   // My comment
 * }
 */
function addEmptyInterfaceComment(comment) {
    const { precedingNode, enclosingNode } = comment;
    if (enclosingNode &&
        enclosingNode.kind === SyntaxKind.InterfaceStatement &&
        enclosingNode.operations.length === 0 &&
        precedingNode &&
        precedingNode.kind === SyntaxKind.Identifier) {
        util.addDanglingComment(enclosingNode, comment, undefined);
        return true;
    }
    return false;
}
/**
 * When a comment is in between a decorator and a statement.
 *
 * @example
 *
 * @foo
 * // My comment
 * model Foo {
 * }
 */
function addStatementDecoratorComment(comment) {
    const { enclosingNode, precedingNode } = comment;
    if (precedingNode &&
        precedingNode.kind === SyntaxKind.DecoratorExpression &&
        enclosingNode &&
        (enclosingNode.kind === SyntaxKind.NamespaceStatement ||
            enclosingNode.kind === SyntaxKind.ModelStatement ||
            enclosingNode.kind === SyntaxKind.EnumStatement ||
            enclosingNode.kind === SyntaxKind.UnionStatement)) {
        util.addLeadingComment(enclosingNode, comment);
        return true;
    }
    return false;
}
/**
 * When a comment is on an empty model make sure it gets added as a dangling comment on it and not on the identifier.
 *
 * @example
 *
 * model Foo {
 *   // My comment
 * }
 */
function addEmptyModelComment(comment) {
    const { precedingNode, enclosingNode } = comment;
    if (enclosingNode &&
        enclosingNode.kind === SyntaxKind.ModelStatement &&
        enclosingNode.properties.length === 0 &&
        precedingNode &&
        (precedingNode === enclosingNode.is ||
            precedingNode === enclosingNode.id ||
            precedingNode === enclosingNode.extends)) {
        util.addDanglingComment(enclosingNode, comment, undefined);
        return true;
    }
    return false;
}

/**
 * Check if the current path should be wrapped in parentheses
 * @param path Prettier print path.
 * @param options Prettier options
 */
function needsParens(path, options) {
    const parent = path.getParentNode();
    if (!parent) {
        return false;
    }
    const node = path.getValue();
    switch (node.kind) {
        case SyntaxKind.IntersectionExpression:
            return (parent.kind === SyntaxKind.UnionExpression || parent.kind === SyntaxKind.ArrayExpression);
        case SyntaxKind.UnionExpression:
            return (parent.kind === SyntaxKind.IntersectionExpression ||
                parent.kind === SyntaxKind.ArrayExpression);
        default:
            return false;
    }
}

const { align, breakParent, group, hardline, ifBreak, indent, join, line, softline } = prettier.doc.builders;
const { isNextLineEmpty } = prettier.util;
const cadlPrinter = {
    print: printCadl,
    canAttachComment: canAttachComment,
    printComment: printComment,
    handleComments: commentHandler,
};
function printCadl(
// Path to the AST node to print
path, options, print) {
    const directives = printDirectives(path, options, print);
    const node = printNode(path, options, print);
    const value = needsParens(path) ? ["(", node, ")"] : node;
    return [directives, value];
}
function printNode(
// Path to the AST node to print
path, options, print) {
    const node = path.getValue();
    printDirectives(path, options, print);
    switch (node.kind) {
        // Root
        case SyntaxKind.CadlScript:
            return [
                printStatementSequence(path, options, print, "statements"),
                line,
            ];
        // Statements
        case SyntaxKind.ImportStatement:
            return [`import "${node.path.value}";`];
        case SyntaxKind.UsingStatement:
            return [`using `, path.call(print, "name"), `;`];
        case SyntaxKind.OperationStatement:
            return printOperationStatement(path, options, print);
        case SyntaxKind.OperationSignatureDeclaration:
            return printOperationSignatureDeclaration(path, options, print);
        case SyntaxKind.OperationSignatureReference:
            return printOperationSignatureReference(path, options, print);
        case SyntaxKind.NamespaceStatement:
            return printNamespaceStatement(path, options, print);
        case SyntaxKind.ModelStatement:
            return printModelStatement(path, options, print);
        case SyntaxKind.AliasStatement:
            return printAliasStatement(path, options, print);
        case SyntaxKind.EnumStatement:
            return printEnumStatement(path, options, print);
        case SyntaxKind.UnionStatement:
            return printUnionStatement(path, options, print);
        case SyntaxKind.InterfaceStatement:
            return printInterfaceStatement(path, options, print);
        // Others.
        case SyntaxKind.Identifier:
            return node.sv;
        case SyntaxKind.StringLiteral:
            return printStringLiteral(path, options);
        case SyntaxKind.NumericLiteral:
            return printNumberLiteral(path, options);
        case SyntaxKind.BooleanLiteral:
            return printBooleanLiteral(path);
        case SyntaxKind.ModelExpression:
            return printModelExpression(path, options, print);
        case SyntaxKind.ModelProperty:
            return printModelProperty(path, options, print);
        case SyntaxKind.DecoratorExpression:
            return printDecorator(path, options, print);
        case SyntaxKind.DirectiveExpression:
            return printDirective(path, options, print);
        case SyntaxKind.UnionExpression:
            return printUnion(path, options, print);
        case SyntaxKind.IntersectionExpression:
            return printIntersection(path, options, print);
        case SyntaxKind.ArrayExpression:
            return printArray(path, options, print);
        case SyntaxKind.TupleExpression:
            return printTuple(path, options, print);
        case SyntaxKind.MemberExpression:
            return printMemberExpression(path, options, print);
        case SyntaxKind.EnumMember:
            return printEnumMember(path, options, print);
        case SyntaxKind.EnumSpreadMember:
            return printEnumSpreadMember(path, options, print);
        case SyntaxKind.UnionVariant:
            return printUnionVariant(path, options, print);
        case SyntaxKind.TypeReference:
            return printTypeReference(path, options, print);
        case SyntaxKind.TemplateParameterDeclaration:
            return printTemplateParameterDeclaration(path, options, print);
        case SyntaxKind.ModelSpreadProperty:
            return printModelSpread(path, options, print);
        case SyntaxKind.VoidKeyword:
            return "void";
        case SyntaxKind.NeverKeyword:
            return "never";
        case SyntaxKind.UnknownKeyword:
            return "unknown";
        // TODO: projection formatting
        case SyntaxKind.Projection:
        case SyntaxKind.ProjectionParameterDeclaration:
        case SyntaxKind.ProjectionModelSelector:
        case SyntaxKind.ProjectionOperationSelector:
        case SyntaxKind.ProjectionUnionSelector:
        case SyntaxKind.ProjectionInterfaceSelector:
        case SyntaxKind.ProjectionEnumSelector:
        case SyntaxKind.ProjectionExpressionStatement:
        case SyntaxKind.ProjectionIfExpression:
        case SyntaxKind.ProjectionBlockExpression:
        case SyntaxKind.ProjectionMemberExpression:
        case SyntaxKind.ProjectionLogicalExpression:
        case SyntaxKind.ProjectionEqualityExpression:
        case SyntaxKind.ProjectionUnaryExpression:
        case SyntaxKind.ProjectionRelationalExpression:
        case SyntaxKind.ProjectionArithmeticExpression:
        case SyntaxKind.ProjectionCallExpression:
        case SyntaxKind.ProjectionLambdaExpression:
        case SyntaxKind.ProjectionLambdaParameterDeclaration:
        case SyntaxKind.ProjectionModelExpression:
        case SyntaxKind.ProjectionModelProperty:
        case SyntaxKind.ProjectionModelSpreadProperty:
        case SyntaxKind.ProjectionTupleExpression:
        case SyntaxKind.ProjectionStatement:
        case SyntaxKind.ProjectionDecoratorReferenceExpression:
        case SyntaxKind.Return:
            return getRawText(node, options);
        // END-TODO: projection formatting
        case SyntaxKind.JsSourceFile:
        case SyntaxKind.EmptyStatement:
        case SyntaxKind.InvalidStatement:
            return getRawText(node, options);
        // default:
        //   return getRawText(node, options);
        default:
            return getRawText(node, options);
    }
}
function printAliasStatement(path, options, print) {
    const id = path.call(print, "id");
    const template = printTemplateParameters(path, options, print, "templateParameters");
    return ["alias ", id, template, " = ", path.call(print, "value"), ";"];
}
function printTemplateParameters(path, options, print, propertyName) {
    const node = path.getValue();
    const args = node[propertyName];
    if (args.length === 0) {
        return "";
    }
    const shouldHug = args.length === 1;
    if (shouldHug) {
        return ["<", join(", ", path.map(print, propertyName)), ">"];
    }
    else {
        const body = indent([softline, join([", ", softline], path.map(print, propertyName))]);
        return group(["<", body, softline, ">"]);
    }
}
function canAttachComment(node) {
    const kind = node.kind;
    return Boolean(kind &&
        kind !== SyntaxKind.LineComment &&
        kind !== SyntaxKind.BlockComment &&
        !(node.flags & 8 /* NodeFlags.Synthetic */));
}
function printComment(commentPath, options) {
    const comment = commentPath.getValue();
    comment.printed = true;
    switch (comment.kind) {
        case SyntaxKind.BlockComment:
            return printBlockComment(commentPath, options);
        case SyntaxKind.LineComment:
            return `${options.originalText.slice(comment.pos, comment.end).trimRight()}`;
        default:
            throw new Error(`Not a comment: ${JSON.stringify(comment)}`);
    }
}
function printBlockComment(commentPath, options) {
    const comment = commentPath.getValue();
    const rawComment = options.originalText.slice(comment.pos + 2, comment.end - 2);
    if (isIndentableBlockComment(rawComment)) {
        const printed = printIndentableBlockComment(rawComment);
        return printed;
    }
    return ["/*", rawComment, "*/"];
}
function isIndentableBlockComment(rawComment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    const lines = `*${rawComment}*`.split("\n");
    return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");
}
function printIndentableBlockComment(rawComment) {
    const lines = rawComment.split("\n");
    return [
        "/*",
        join(hardline, lines.map((line, index) => index === 0
            ? line.trimEnd()
            : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))),
        "*/",
    ];
}
function printDecorators(path, options, print, { tryInline }) {
    const node = path.getValue();
    if (node.decorators.length === 0) {
        return { decorators: "", multiline: false };
    }
    const shouldBreak = !tryInline || node.decorators.length >= 3 || hasNewlineBetweenOrAfterDecorators(node, options);
    const decorators = path.map((x) => [print(x), ifBreak(line, " ")], "decorators");
    return {
        decorators: group([shouldBreak ? breakParent : "", decorators]),
        multiline: shouldBreak,
    };
}
/**
 * Check if there is already new lines in between the decorators of the node.
 */
function hasNewlineBetweenOrAfterDecorators(node, options) {
    return node.decorators.some((decorator) => prettier.util.hasNewline(options.originalText, decorator.end));
}
function printDecorator(path, options, print) {
    const args = printDecoratorArgs(path, options, print);
    return ["@", path.call(print, "target"), args];
}
function printDirectives(path, options, print) {
    const node = path.getValue();
    if (node.directives === undefined || node.directives.length === 0) {
        return "";
    }
    const directives = path.map((x) => [print(x), line], "directives");
    return group([...directives, breakParent]);
}
function printDirective(path, options, print) {
    const args = printDirectiveArgs(path, options, print);
    return ["#", path.call(print, "target"), " ", args];
}
function printDecoratorArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    // So that decorator with single object arguments have ( and { hugging.
    // @deco({
    //   value: "foo"
    // })
    const shouldHug = node.arguments.length === 1 &&
        (node.arguments[0].kind === SyntaxKind.ModelExpression ||
            node.arguments[0].kind === SyntaxKind.StringLiteral);
    if (shouldHug) {
        return [
            "(",
            join(", ", path.map((arg) => [print(arg)], "arguments")),
            ")",
        ];
    }
    return [
        "(",
        group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "arguments"))),
            softline,
        ]),
        ")",
    ];
}
function printDirectiveArgs(path, options, print) {
    const node = path.getValue();
    if (node.arguments.length === 0) {
        return "";
    }
    return join(" ", path.map((arg) => [print(arg)], "arguments"));
}
function printEnumStatement(path, options, print) {
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const id = path.call(print, "id");
    return [decorators, "enum ", id, " ", printEnumBlock(path, options, print)];
}
function printEnumBlock(path, options, print) {
    const node = path.getValue();
    if (node.members.length === 0) {
        return "{}";
    }
    return group([
        "{",
        indent([
            hardline,
            join(hardline, path.map((x) => [print(x), ","], "members")),
        ]),
        hardline,
        "}",
    ]);
}
function printEnumMember(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const value = node.value ? [": ", path.call(print, "value")] : "";
    const { decorators, multiline } = printDecorators(path, options, print, { tryInline: true });
    const propertyIndex = path.stack[path.stack.length - 2];
    const isNotFirst = typeof propertyIndex === "number" && propertyIndex > 0;
    return [multiline && isNotFirst ? hardline : "", decorators, id, value];
}
function printEnumSpreadMember(path, options, print) {
    return ["...", path.call(print, "target")];
}
function printUnionStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    return [decorators, "union ", id, generic, " ", printUnionVariantsBlock(path, options, print)];
}
function printUnionVariantsBlock(path, options, print) {
    const node = path.getValue();
    if (node.options.length === 0) {
        return "{}";
    }
    return group([
        "{",
        indent([
            hardline,
            join(hardline, path.map((x) => [print(x), ","], "options")),
        ]),
        hardline,
        "}",
    ]);
}
function printUnionVariant(path, options, print) {
    const id = path.call(print, "id");
    const value = [": ", path.call(print, "value")];
    const { decorators } = printDecorators(path, options, print, { tryInline: true });
    return [decorators, id, value];
}
function printInterfaceStatement(path, options, print) {
    const id = path.call(print, "id");
    const { decorators } = printDecorators(path, options, print, { tryInline: false });
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const extendList = printInterfaceExtends(path, options, print);
    return [
        decorators,
        "interface ",
        id,
        generic,
        extendList,
        " ",
        printInterfaceMembers(path, options, print),
    ];
}
function printInterfaceExtends(path, options, print) {
    const node = path.getValue();
    if (node.extends.length === 0) {
        return "";
    }
    const keyword = "extends ";
    return [group(indent([line, keyword, indent(join([",", line], path.map(print, "extends")))]))];
}
function printInterfaceMembers(path, options, print) {
    const node = path.getValue();
    const hasOperations = node.operations.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasOperations && !nodeHasComments) {
        return "{}";
    }
    const lastOperation = node.operations[node.operations.length - 1];
    const parts = [];
    path.each((operationPath) => {
        const node = operationPath.getValue();
        const printed = print(operationPath);
        parts.push(printed);
        if (node !== lastOperation) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, "operations");
    const body = [hardline, parts];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), hardline, "}"]);
}
function printDanglingComments(path, options, { sameIndent }) {
    const node = path.getValue();
    const parts = [];
    if (!node || !node.comments) {
        return "";
    }
    path.each((commentPath) => {
        const comment = commentPath.getValue();
        if (!comment.leading && !comment.trailing) {
            parts.push(printComment(path, options));
        }
    }, "comments");
    if (parts.length === 0) {
        return "";
    }
    if (sameIndent) {
        return join(hardline, parts);
    }
    return indent([hardline, join(hardline, parts)]);
}
/**
 * Handle printing an intersection node.
 * @example `Foo & Bar` or `{foo: string} & {bar: string}`
 *
 * @param path Prettier AST Path.
 * @param options Prettier options
 * @param print Prettier child print callback.
 * @returns Prettier document.
 */
function printIntersection(path, options, print) {
    const node = path.getValue();
    const types = path.map(print, "options");
    const result = [];
    let wasIndented = false;
    for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
            result.push(types[i]);
        }
        else if (isModelNode(node.options[i - 1]) && isModelNode(node.options[i])) {
            // If both are objects, don't indent
            result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);
        }
        else if (!isModelNode(node.options[i - 1]) && !isModelNode(node.options[i])) {
            // If no object is involved, go to the next line if it breaks
            result.push(indent([" &", line, types[i]]));
        }
        else {
            // If you go from object to non-object or vis-versa, then inline it
            if (i > 1) {
                wasIndented = true;
            }
            result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
        }
    }
    return group(result);
}
function isModelNode(node) {
    return node.kind === SyntaxKind.ModelExpression;
}
function printArray(path, options, print) {
    return [path.call(print, "elementType"), "[]"];
}
function printTuple(path, options, print) {
    return group([
        "[",
        indent(join(", ", path.map((arg) => [softline, print(arg)], "values"))),
        softline,
        "]",
    ]);
}
function printMemberExpression(path, options, print) {
    const node = path.getValue();
    return [node.base ? [path.call(print, "base"), "."] : "", path.call(print, "id")];
}
function printModelExpression(path, options, print) {
    const inBlock = isModelExpressionInBlock(path);
    if (inBlock) {
        return group(printModelPropertiesBlock(path, options, print));
    }
    else {
        return group([
            indent(join(", ", path.map((arg) => [softline, print(arg)], "properties"))),
            softline,
        ]);
    }
}
function printModelStatement(path, options, print) {
    const node = path.getValue();
    const id = path.call(print, "id");
    const heritage = node.extends
        ? [ifBreak(line, " "), "extends ", path.call(print, "extends")]
        : "";
    const isBase = node.is ? [ifBreak(line, " "), "is ", path.call(print, "is")] : "";
    const generic = printTemplateParameters(path, options, print, "templateParameters");
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    const shouldPrintBody = nodeHasComments || !(node.properties.length === 0 && node.is);
    const body = shouldPrintBody ? [" ", printModelPropertiesBlock(path, options, print)] : ";";
    return [
        printDecorators(path, options, print, { tryInline: false }).decorators,
        "model ",
        id,
        generic,
        group(indent(["", heritage, isBase])),
        body,
    ];
}
function printModelPropertiesBlock(path, options, print) {
    var _a;
    const node = path.getValue();
    const hasProperties = node.properties && node.properties.length > 0;
    const nodeHasComments = hasComments(node, CommentCheckFlags.Dangling);
    if (!hasProperties && !nodeHasComments) {
        return "{}";
    }
    const tryInline = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.TemplateParameterDeclaration;
    const lineDoc = tryInline ? softline : hardline;
    const seperator = isModelAValue(path) ? "," : ";";
    const body = [
        lineDoc,
        join([seperator, lineDoc], path.map((x) => [print(x)], "properties")),
        hasProperties ? ifBreak(seperator) : "",
    ];
    if (nodeHasComments) {
        body.push(printDanglingComments(path, options, { sameIndent: true }));
    }
    return group(["{", indent(body), lineDoc, "}"]);
}
/**
 * Figure out if this model is being used as a definition or value.
 * @returns true if the model is used as a value(e.g. decorator value), false if it is used as a model definition.
 */
function isModelAValue(path) {
    let count = 0;
    let node = path.getValue();
    do {
        switch (node.kind) {
            case SyntaxKind.ModelStatement:
            case SyntaxKind.AliasStatement:
            case SyntaxKind.OperationStatement:
                return false;
            case SyntaxKind.DecoratorExpression:
                return true;
        }
    } while ((node = path.getParentNode(count++)));
    return true;
}
function printModelProperty(path, options, print) {
    const node = path.getValue();
    const propertyIndex = path.stack[path.stack.length - 2];
    const isNotFirst = typeof propertyIndex === "number" && propertyIndex > 0;
    const { decorators, multiline } = printDecorators(path, options, print, {
        tryInline: true,
    });
    let id;
    if (node.id.kind === SyntaxKind.StringLiteral && isStringSafeToUnquote(node.id, options)) {
        id = node.id.value;
    }
    else {
        id = path.call(print, "id");
    }
    return [
        multiline && isNotFirst ? hardline : "",
        decorators,
        id,
        node.optional ? "?: " : ": ",
        path.call(print, "value"),
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function isStringSafeToUnquote(id, options) {
    const unquotedRawText = getRawText(id, options).slice(1, -1);
    if (id.value !== unquotedRawText) {
        return false;
    }
    let hasError = false;
    const scanner = createScanner(id.value, (d) => (hasError = true));
    if (scanner.scan() !== Token.Identifier) {
        return false;
    }
    if (scanner.scan() !== Token.EndOfFile) {
        return false;
    }
    return !hasError;
}
function isModelExpressionInBlock(path) {
    const parent = path.getParentNode();
    switch (parent === null || parent === void 0 ? void 0 : parent.kind) {
        case SyntaxKind.OperationSignatureDeclaration:
            return parent.parameters !== path.getNode();
        default:
            return true;
    }
}
function printNamespaceStatement(path, options, print) {
    const printNested = (currentPath, parentNames) => {
        var _a;
        const names = [...parentNames, currentPath.call(print, "id")];
        const currentNode = currentPath.getNode();
        if (!isArray(currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) &&
            ((_a = currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.NamespaceStatement) {
            return path.call((x) => printNested(x, names), "statements");
        }
        const suffix = (currentNode === null || currentNode === void 0 ? void 0 : currentNode.statements) === undefined
            ? ";"
            : [
                " {",
                indent([hardline, printStatementSequence(path, options, print, "statements")]),
                hardline,
                "}",
            ];
        const { decorators } = printDecorators(path, options, print, { tryInline: false });
        return [decorators, `namespace `, join(".", names), suffix];
    };
    return printNested(path, []);
}
function printOperationSignatureDeclaration(path, options, print) {
    return ["(", path.call(print, "parameters"), "): ", path.call(print, "returnType")];
}
function printOperationSignatureReference(path, options, print) {
    return [" is ", path.call(print, "baseOperation")];
}
function printOperationStatement(path, options, print) {
    var _a;
    const inInterface = ((_a = path.getParentNode()) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.InterfaceStatement;
    const templateParams = printTemplateParameters(path, options, print, "templateParameters");
    const { decorators } = printDecorators(path, options, print, {
        tryInline: true,
    });
    return [
        decorators,
        inInterface ? "" : "op ",
        path.call(print, "id"),
        templateParams,
        path.call(print, "signature"),
        `;`,
    ];
}
function printStatementSequence(path, options, print, property) {
    const node = path.getValue();
    const parts = [];
    const lastStatement = getLastStatement(node[property]);
    path.each((statementPath) => {
        const node = path.getValue();
        if (node.kind === SyntaxKind.EmptyStatement) {
            return;
        }
        const printed = print(statementPath);
        parts.push(printed);
        if (node !== lastStatement) {
            parts.push(hardline);
            if (isNextLineEmpty(options.originalText, node, options.locEnd)) {
                parts.push(hardline);
            }
        }
    }, property);
    return parts;
}
function getLastStatement(statements) {
    for (let i = statements.length - 1; i >= 0; i--) {
        const statement = statements[i];
        if (statement.kind !== SyntaxKind.EmptyStatement) {
            return statement;
        }
    }
    return undefined;
}
function printUnion(path, options, print) {
    const node = path.getValue();
    const shouldHug = shouldHugType(node);
    const types = path.map((typePath) => {
        let printedType = print(typePath);
        if (!shouldHug) {
            printedType = align(2, printedType);
        }
        return printedType;
    }, "options");
    if (shouldHug) {
        return join(" | ", types);
    }
    const code = [ifBreak([line , "| "], ""), join([line, "| "], types)];
    return group(indent(code));
}
function shouldHugType(node) {
    if (node.kind === SyntaxKind.UnionExpression || node.kind === SyntaxKind.IntersectionExpression) {
        return node.options.length < 4;
    }
    return false;
}
function printTypeReference(path, options, print) {
    const type = path.call(print, "target");
    const template = printTemplateParameters(path, options, print, "arguments");
    return [type, template];
}
function printTemplateParameterDeclaration(path, options, print) {
    const node = path.getValue();
    return [
        path.call(print, "id"),
        node.constraint ? [" extends ", path.call(print, "constraint")] : "",
        node.default ? [" = ", path.call(print, "default")] : "",
    ];
}
function printModelSpread(path, options, print) {
    return ["...", path.call(print, "target")];
}
function printStringLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
function printNumberLiteral(path, options) {
    const node = path.getValue();
    return getRawText(node, options);
}
function printBooleanLiteral(path, options) {
    const node = path.getValue();
    return node.value ? "true" : "false";
}
/**
 * @param node Node that has postition information.
 * @param options Prettier options
 * @returns Raw text in the file for the given node.
 */
function getRawText(node, options) {
    return options.originalText.slice(node.pos, node.end);
}
function hasComments(node, flags) {
    if (!node.comments || node.comments.length === 0) {
        return false;
    }
    const test = getCommentTestFunction(flags);
    return test ? node.comments.some(test) : true;
}
var CommentCheckFlags;
(function (CommentCheckFlags) {
    /** Check comment is a leading comment */
    CommentCheckFlags[CommentCheckFlags["Leading"] = 2] = "Leading";
    /** Check comment is a trailing comment */
    CommentCheckFlags[CommentCheckFlags["Trailing"] = 4] = "Trailing";
    /** Check comment is a dangling comment */
    CommentCheckFlags[CommentCheckFlags["Dangling"] = 8] = "Dangling";
    /** Check comment is a block comment */
    CommentCheckFlags[CommentCheckFlags["Block"] = 16] = "Block";
    /** Check comment is a line comment */
    CommentCheckFlags[CommentCheckFlags["Line"] = 32] = "Line";
    /** Check comment is a `prettier-ignore` comment */
    CommentCheckFlags[CommentCheckFlags["PrettierIgnore"] = 64] = "PrettierIgnore";
    /** Check comment is the first attached comment */
    CommentCheckFlags[CommentCheckFlags["First"] = 128] = "First";
    /** Check comment is the last attached comment */
    CommentCheckFlags[CommentCheckFlags["Last"] = 256] = "Last";
})(CommentCheckFlags || (CommentCheckFlags = {}));
function getCommentTestFunction(flags) {
    if (flags) {
        return (comment, index, comments) => !((flags & CommentCheckFlags.Leading && !comment.leading) ||
            (flags & CommentCheckFlags.Trailing && !comment.trailing) ||
            (flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing)) ||
            (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||
            (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||
            (flags & CommentCheckFlags.First && index !== 0) ||
            (flags & CommentCheckFlags.Last && index !== comments.length - 1));
    }
    return undefined;
}
function isBlockComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}
function isLineComment(comment) {
    return comment.kind === SyntaxKind.BlockComment;
}

const defaultOptions = {};
const languages = [
    {
        name: "Cadl",
        parsers: ["cadl"],
        extensions: [".cadl"],
        vscodeLanguageIds: ["cadl"],
    },
];
const CadlParser = {
    parse,
    astFormat: "cadl-format",
    locStart(node) {
        return node.pos;
    },
    locEnd(node) {
        return node.end;
    },
};
const parsers = {
    cadl: CadlParser,
};
const printers = {
    "cadl-format": cadlPrinter,
};

var formatter = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultOptions: defaultOptions,
    languages: languages,
    parsers: parsers,
    printers: printers
});

const CadlPrettierPlugin = formatter;

const CadlJSSources = {
"dist/lib/decorators.js": f0,
};
const CadlSources = {
  "package.json": "{\"name\":\"@cadl-lang/compiler\",\"version\":\"0.34.0\",\"description\":\"Cadl Compiler Preview\",\"author\":\"Microsoft Corporation\",\"license\":\"MIT\",\"homepage\":\"https://github.com/Microsoft/cadl\",\"readme\":\"https://github.com/Microsoft/cadl/blob/master/README.md\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/Microsoft/cadl.git\"},\"bugs\":{\"url\":\"https://github.com/Microsoft/cadl/issues\"},\"keywords\":[\"cadl\",\"cli\"],\"type\":\"module\",\"main\":\"dist/core/index.js\",\"cadlMain\":\"lib/main.cadl\",\"exports\":{\".\":\"./dist/core/index.js\",\"./testing\":\"./dist/testing/index.js\"},\"browser\":{\"./dist/core/node-host.js\":\"./dist/core/node-host.browser.js\",\"./dist/core/logger/console-sink.js\":\"./dist/core/logger/console-sink.browser.js\"},\"types\":\"dist/core/index.d.ts\",\"engines\":{\"node\":\">=16.0.0\"},\"bin\":{\"cadl\":\"cmd/cadl.js\",\"cadl-server\":\"cmd/cadl-server.js\"},\"files\":[\"lib/*.cadl\",\"dist/**\",\"!dist/test/**\"],\"dependencies\":{\"@babel/code-frame\":\"~7.16.7\",\"ajv\":\"~8.9.0\",\"picocolors\":\"~1.0.0\",\"globby\":\"~13.1.1\",\"js-yaml\":\"~4.1.0\",\"mkdirp\":\"~1.0.4\",\"mustache\":\"~4.2.0\",\"prettier\":\"~2.7.1\",\"node-fetch\":\"~3.2.0\",\"prompts\":\"~2.4.1\",\"vscode-languageserver\":\"~7.0.0\",\"vscode-languageserver-textdocument\":\"~1.0.1\",\"yargs\":\"~17.3.1\",\"node-watch\":\"~0.7.1\",\"change-case\":\"~4.1.2\"},\"devDependencies\":{\"@types/babel__code-frame\":\"~7.0.3\",\"@types/js-yaml\":\"~4.0.1\",\"@types/mkdirp\":\"~1.0.1\",\"@types/mocha\":\"~9.1.0\",\"@types/mustache\":\"~4.1.2\",\"@types/node\":\"~16.0.3\",\"@types/prettier\":\"2.6.0\",\"@types/prompts\":\"~2.0.14\",\"@types/yargs\":\"~17.0.2\",\"@cadl-lang/eslint-config-cadl\":\"~0.4.0\",\"@cadl-lang/internal-build-utils\":\"~0.3.1\",\"eslint\":\"^8.12.0\",\"grammarkdown\":\"~3.1.2\",\"mocha\":\"~9.2.0\",\"mocha-junit-reporter\":\"~2.0.2\",\"mocha-multi-reporters\":\"~1.5.1\",\"c8\":\"~7.11.0\",\"prettier-plugin-organize-imports\":\"~2.3.4\",\"source-map-support\":\"~0.5.19\",\"rimraf\":\"~3.0.2\",\"tmlanguage-generator\":\"~0.3.1\",\"typescript\":\"~4.7.2\",\"vscode-oniguruma\":\"~1.6.1\",\"vscode-textmate\":\"~6.0.0\"},\"scripts\":{\"clean\":\"rimraf ./dist ./temp\",\"build\":\"npm run gen-manifest && npm run compile && npm run generate-tmlanguage\",\"compile\":\"tsc -p .\",\"watch\":\"tsc -p . --watch\",\"watch-tmlanguage\":\"node scripts/watch-tmlanguage.js\",\"generate-tmlanguage\":\"node scripts/generate-tmlanguage.js\",\"dogfood\":\"node scripts/dogfood.js\",\"test\":\"mocha\",\"test-official\":\"c8 mocha --forbid-only --reporter mocha-multi-reporters\",\"gen-manifest\":\"node scripts/generate-manifest.js\",\"regen-nonascii\":\"node scripts/regen-nonascii.js\",\"fuzz\":\"node dist/test/manual/fuzz.js run\",\"lint\":\"eslint . --ext .ts --max-warnings=0\",\"lint:fix\":\"eslint . --fix --ext .ts\"}}",
  "../../../../cadl-azure/core/packages/compiler/lib/main.cadl": "import \"../dist/lib/decorators.js\";\nimport \"./lib.cadl\";\nimport \"./projected-names.cadl\";\n",
  "../../../../cadl-azure/core/packages/compiler/lib/lib.cadl": "namespace Cadl;\n\nmodel object {}\n\n@indexer(integer, T)\nmodel Array<T> {}\n\n@indexer(string, T)\nmodel Record<T> {}\n\n@intrinsic(\"bytes\")\nmodel bytes {}\n\n@numeric\n@intrinsic(\"numeric\")\nmodel numeric {}\n\n@numeric\n@intrinsic(\"integer\")\nmodel integer {}\n\n@numeric\n@intrinsic(\"float\")\nmodel float {}\n\n@numeric\n@intrinsic(\"int64\")\nmodel int64 {}\n\n@numeric\n@intrinsic(\"int32\")\nmodel int32 {}\n\n@numeric\n@intrinsic(\"int16\")\nmodel int16 {}\n\n@numeric\n@intrinsic(\"int8\")\nmodel int8 {}\n\n@numeric\n@intrinsic(\"uint64\")\nmodel uint64 {}\n\n@numeric\n@intrinsic(\"uint32\")\nmodel uint32 {}\n\n@numeric\n@intrinsic(\"uint16\")\nmodel uint16 {}\n\n@numeric\n@intrinsic(\"uint8\")\nmodel uint8 {}\n\n@numeric\n@intrinsic(\"safeint\")\nmodel safeint {}\n\n@numeric\n@intrinsic(\"float32\")\nmodel float32 {}\n\n@numeric\n@intrinsic(\"float64\")\nmodel float64 {}\n\n@intrinsic(\"string\")\nmodel string {}\n\n@intrinsic(\"plainDate\")\nmodel plainDate {}\n\n@intrinsic(\"plainTime\")\nmodel plainTime {}\n\n@intrinsic(\"zonedDateTime\")\nmodel zonedDateTime {}\n\n@intrinsic(\"duration\")\nmodel duration {}\n\n@intrinsic(\"boolean\")\nmodel boolean {}\n\n@intrinsic(\"null\")\nmodel null {}\n\n@deprecated(\"Map is deprecated, use Record<T> instead\")\nmodel Map<K, V> is Record<V>;\n\n@doc(\"The template for adding optional properties.\")\n@withOptionalProperties\nmodel OptionalProperties<T> {\n  ...T;\n}\n\n@doc(\"The template for adding updateable properties.\")\n@withUpdateableProperties\nmodel UpdateableProperties<T> {\n  ...T;\n}\n\n@doc(\"The template for omitting properties.\")\n@withoutOmittedProperties(TStringOrTuple)\nmodel OmitProperties<T, TStringOrTuple> {\n  ...T;\n}\n\n@withoutDefaultValues\nmodel OmitDefaults<T> {\n  ...T;\n}\n\n@doc(\"The template for setting the default visibility of key properties.\")\n@withDefaultKeyVisibility(Visibility)\nmodel DefaultKeyVisibility<T, Visibility> {\n  ...T;\n}\n",
  "../../../../cadl-azure/core/packages/compiler/lib/projected-names.cadl": "// Set of projections consuming the @projectedName decorator\n\n#suppress \"projections-are-experimental\"\nprojection op#target {\n  to(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(getProjectedName(self, targetName));\n    };\n  }\n  from(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(self::projectionBase::name);\n    };\n  }\n}\n\n#suppress \"projections-are-experimental\"\nprojection interface#target {\n  to(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(getProjectedName(self, targetName));\n    };\n  }\n  from(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(self::projectionBase::name);\n    };\n  }\n}\n\n#suppress \"projections-are-experimental\"\nprojection model#target {\n  to(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(getProjectedName(self, targetName));\n    };\n\n    self::properties::forEach((p) => {\n      if hasProjectedName(p, targetName) {\n        self::renameProperty(p::name, getProjectedName(p, targetName));\n      };\n    });\n  }\n  from(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(self::projectionBase::name);\n    };\n\n    self::projectionBase::properties::forEach((p) => {\n      if hasProjectedName(p, targetName) {\n        self::renameProperty(getProjectedName(p, targetName), p::name);\n      };\n    });\n  }\n}\n\n#suppress \"projections-are-experimental\"\nprojection enum#target {\n  to(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(getProjectedName(self, targetName));\n    };\n\n    self::members::forEach((p) => {\n      if hasProjectedName(p, targetName) {\n        self::renameMember(p::name, getProjectedName(p, targetName));\n      };\n    });\n  }\n  from(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(self::projectionBase::name);\n    };\n\n    self::projectionBase::members::forEach((p) => {\n      if hasProjectedName(p, targetName) {\n        self::renameMember(getProjectedName(p, targetName), p::name);\n      };\n    });\n  }\n}\n\n#suppress \"projections-are-experimental\"\nprojection union#target {\n  to(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(getProjectedName(self, targetName));\n    };\n  }\n  from(targetName) {\n    if hasProjectedName(self, targetName) {\n      self::rename(self::projectionBase::name);\n    };\n  }\n}\n",
  "lib/main.cadl": "import \"../dist/lib/decorators.js\";\nimport \"./lib.cadl\";\n",
  "lib/lib.cadl": "namespace Cadl;\n\nmodel object {}\n\n@indexer(integer, T)\nmodel Array<T> {}\n\n@indexer(string, T)\nmodel Record<T> {}\n\n@intrinsic(\"bytes\")\nmodel bytes {}\n\n@numeric\n@intrinsic(\"numeric\")\nmodel numeric {}\n\n@numeric\n@intrinsic(\"integer\")\nmodel integer {}\n\n@numeric\n@intrinsic(\"float\")\nmodel float {}\n\n@numeric\n@intrinsic(\"int64\")\nmodel int64 {}\n\n@numeric\n@intrinsic(\"int32\")\nmodel int32 {}\n\n@numeric\n@intrinsic(\"int16\")\nmodel int16 {}\n\n@numeric\n@intrinsic(\"int8\")\nmodel int8 {}\n\n@numeric\n@intrinsic(\"uint64\")\nmodel uint64 {}\n\n@numeric\n@intrinsic(\"uint32\")\nmodel uint32 {}\n\n@numeric\n@intrinsic(\"uint16\")\nmodel uint16 {}\n\n@numeric\n@intrinsic(\"uint8\")\nmodel uint8 {}\n\n@numeric\n@intrinsic(\"safeint\")\nmodel safeint {}\n\n@numeric\n@intrinsic(\"float32\")\nmodel float32 {}\n\n@numeric\n@intrinsic(\"float64\")\nmodel float64 {}\n\n@intrinsic(\"string\")\nmodel string {}\n\n@intrinsic(\"plainDate\")\nmodel plainDate {}\n\n@intrinsic(\"plainTime\")\nmodel plainTime {}\n\n@intrinsic(\"zonedDateTime\")\nmodel zonedDateTime {}\n\n@intrinsic(\"duration\")\nmodel duration {}\n\n@intrinsic(\"boolean\")\nmodel boolean {}\n\n@intrinsic(\"null\")\nmodel null {}\n\n@deprecated(\"Map is deprecated, use Record<T> instead\")\nmodel Map<K, V> is Record<V>;\n\n@doc(\"The template for adding optional properties.\")\n@withOptionalProperties\nmodel OptionalProperties<T> {\n  ...T;\n}\n\n@doc(\"The template for adding updateable properties.\")\n@withUpdateableProperties\nmodel UpdateableProperties<T> {\n  ...T;\n}\n\n@doc(\"The template for omitting properties.\")\n@withoutOmittedProperties(TStringOrTuple)\nmodel OmitProperties<T, TStringOrTuple> {\n  ...T;\n}\n\n@withoutDefaultValues\nmodel OmitDefaults<T> {\n  ...T;\n}\n\n@doc(\"The template for setting the default visibility of key properties.\")\n@withDefaultKeyVisibility(Visibility)\nmodel DefaultKeyVisibility<T, Visibility> {\n  ...T;\n}\n"
};
const _CadlLibrary_ = {
  jsSourceFiles: CadlJSSources,
  cadlSourceFiles: CadlSources,
};

export { $deprecated, $doc, $error, $format, $friendlyName, $indexer, $inspectType, $inspectTypeName, $intrinsic, $key, $knownValues, $list, $maxLength, $maxValue, $minLength, $minValue, $numeric, $overload, $pattern, $secret, $serviceTitle, $serviceVersion, $summary, $tag, $visibility, $withDefaultKeyVisibility, $withOptionalProperties, $withUpdateableProperties, $withVisibility, $withoutDefaultValues, $withoutOmittedProperties, CadlLanguageConfiguration, CadlPrettierPlugin, EventEmitter, IdentifierKind, Keywords, MANIFEST, NoTarget, NodeHost, ProjectionError, SemanticTokenKind, SyntaxKind, Token, TokenDisplay, _CadlLibrary_, altDirectorySeparator, assertType, cadlTypeToJson, cadlVersion, checkIfServiceNamespace, compile, compilerAssert, createCadlLibrary, createChecker, createDecoratorDefinition, createDiagnosticCollector, createDiagnosticCreator, createProgram, createScanner, createServer, createSourceFile, f0 as decorators, directorySeparator, emitFile, ensureTrailingDirectorySeparator, formatDiagnostic, getAllTags, getAnyExtensionFromPath, getBaseFileName, getDeprecated, getDirectoryPath, getDoc, getFirstAncestor, getFormat, getFriendlyName, getIdentifierContext, getIndexer, getIntrinsicModelName, getKeyName, getKnownValues, getListOperationType, getMaxLength, getMaxValue, getMinLength, getMinValue, getNodeAtPosition, getNormalizedAbsolutePath, getNormalizedAbsolutePathWithoutRoot, getNormalizedPathComponents, getOverloadedOperation, getOverloads, getPathComponents, getPathFromPathComponents, getPattern, getProperty, getPropertyType, getRootLength, getServiceNamespace, getServiceNamespaceString, getServiceTitle, getServiceVersion, getSourceFileKindFromExt, getSourceLocation, getSummary, getTags, getVisibility, hasParseError, hasTrailingDirectorySeparator, ignoreDiagnostics, isAnyDirectorySeparator, isArrayModelType, isCadlValueTypeOf, isComment, isDeprecated, isErrorModel, isErrorType$1 as isErrorType, isGlobalNamespace, isImportStatement, isIntrinsic, isKey, isKeyword, isListOperation, isLiteral, isNeverIndexer, isNeverType, isNumericType, isPathAbsolute, isPunctuation, isRecordModelType, isSecret, isStatementKeyword, isStringType, isTemplateDeclaration, isTemplateDeclarationOrInstance, isTemplateInstance, isTrivia, isUnknownType, isUrl, isVoidType, joinPaths, logDiagnostics, logVerboseTestOutput, namespace, navigateProgram, normalizePath, normalizeSlashes, paramMessage, parse$1 as parse, reducePathComponents, removeTrailingDirectorySeparator, reportDeprecated, resolvePath, setCadlNamespace, setServiceNamespace, skipTrivia, skipWhiteSpace, validateDecoratorParamCount, validateDecoratorParamType, validateDecoratorTarget, validateDecoratorTargetIntrinsic, visitChildren };
